{
  "/typeshed/stdlib/VERSIONS": "# The structure of this file is as follows:\n# - Blank lines and comments starting with `#` are ignored.\n# - Lines contain the name of a module, followed by a colon,\n#   a space, and a version range (for example: `symbol: 3.0-3.9`).\n#\n# Version ranges may be of the form \"X.Y-A.B\" or \"X.Y-\". The\n# first form means that a module was introduced in version X.Y and last\n# available in version A.B. The second form means that the module was\n# introduced in version X.Y and is still available in the latest\n# version of Python.\n#\n# If a submodule is not listed separately, it has the same lifetime as\n# its parent module.\n#\n# Python versions before 3.0 are ignored, so any module that was already\n# present in 3.0 will have \"3.0\" as its minimum version. Version ranges\n# for unsupported versions of Python 3 are generally accurate but we do\n# not guarantee their correctness.\n\n__future__: 3.0-\n__main__: 3.0-\n_ast: 3.0-\n_asyncio: 3.0-\n_bisect: 3.0-\n_blake2: 3.6-\n_bootlocale: 3.4-3.9\n_bz2: 3.3-\n_codecs: 3.0-\n_collections_abc: 3.3-\n_compat_pickle: 3.1-\n_compression: 3.5-3.13\n_contextvars: 3.7-\n_csv: 3.0-\n_ctypes: 3.0-\n_curses: 3.0-\n_curses_panel: 3.0-\n_dbm: 3.0-\n_decimal: 3.3-\n_frozen_importlib: 3.0-\n_frozen_importlib_external: 3.5-\n_gdbm: 3.0-\n_hashlib: 3.0-\n_heapq: 3.0-\n_imp: 3.0-\n_interpchannels: 3.13-\n_interpqueues: 3.13-\n_interpreters: 3.13-\n_io: 3.0-\n_json: 3.0-\n_locale: 3.0-\n_lsprof: 3.0-\n_lzma: 3.3-\n_markupbase: 3.0-\n_msi: 3.0-3.12\n_multibytecodec: 3.0-\n_operator: 3.4-\n_osx_support: 3.0-\n_pickle: 3.0-\n_posixsubprocess: 3.2-\n_py_abc: 3.7-\n_pydecimal: 3.5-\n_queue: 3.7-\n_random: 3.0-\n_sitebuiltins: 3.4-\n_socket: 3.0-  # present in 3.0 at runtime, but not in typeshed\n_sqlite3: 3.0-\n_ssl: 3.0-\n_stat: 3.4-\n_struct: 3.0-\n_thread: 3.0-\n_threading_local: 3.0-\n_tkinter: 3.0-\n_tracemalloc: 3.4-\n_typeshed: 3.0-  # not present at runtime, only for type checking\n_warnings: 3.0-\n_weakref: 3.0-\n_weakrefset: 3.0-\n_winapi: 3.3-\n_zstd: 3.14-\nabc: 3.0-\naifc: 3.0-3.12\nannotationlib: 3.14-\nantigravity: 3.0-\nargparse: 3.0-\narray: 3.0-\nast: 3.0-\nasynchat: 3.0-3.11\nasyncio: 3.4-\nasyncio.exceptions: 3.8-\nasyncio.format_helpers: 3.7-\nasyncio.graph: 3.14-\nasyncio.mixins: 3.10-\nasyncio.runners: 3.7-\nasyncio.staggered: 3.8-\nasyncio.taskgroups: 3.11-\nasyncio.threads: 3.9-\nasyncio.timeouts: 3.11-\nasyncio.tools: 3.14-\nasyncio.trsock: 3.8-\nasyncore: 3.0-3.11\natexit: 3.0-\naudioop: 3.0-3.12\nbase64: 3.0-\nbdb: 3.0-\nbinascii: 3.0-\nbinhex: 3.0-3.10\nbisect: 3.0-\nbuiltins: 3.0-\nbz2: 3.0-\ncProfile: 3.0-\ncalendar: 3.0-\ncgi: 3.0-3.12\ncgitb: 3.0-3.12\nchunk: 3.0-3.12\ncmath: 3.0-\ncmd: 3.0-\ncode: 3.0-\ncodecs: 3.0-\ncodeop: 3.0-\ncollections: 3.0-\ncollections.abc: 3.3-\ncolorsys: 3.0-\ncompileall: 3.0-\ncompression: 3.14-\nconcurrent: 3.2-\nconcurrent.futures.interpreter: 3.14-\nconcurrent.interpreters: 3.14-\nconfigparser: 3.0-\ncontextlib: 3.0-\ncontextvars: 3.7-\ncopy: 3.0-\ncopyreg: 3.0-\ncrypt: 3.0-3.12\ncsv: 3.0-\nctypes: 3.0-\ncurses: 3.0-\ndataclasses: 3.7-\ndatetime: 3.0-\ndbm: 3.0-\ndbm.sqlite3: 3.13-\ndecimal: 3.0-\ndifflib: 3.0-\ndis: 3.0-\ndistutils: 3.0-3.11\ndistutils.command.bdist_msi: 3.0-3.10\ndistutils.command.bdist_wininst: 3.0-3.9\ndoctest: 3.0-\nemail: 3.0-\nencodings: 3.0-\nencodings.cp1125: 3.4-\nencodings.cp273: 3.4-\nencodings.cp858: 3.2-\nencodings.koi8_t: 3.5-\nencodings.kz1048: 3.5-\nensurepip: 3.0-\nenum: 3.4-\nerrno: 3.0-\nfaulthandler: 3.3-\nfcntl: 3.0-\nfilecmp: 3.0-\nfileinput: 3.0-\nfnmatch: 3.0-\nformatter: 3.0-3.9\nfractions: 3.0-\nftplib: 3.0-\nfunctools: 3.0-\ngc: 3.0-\ngenericpath: 3.0-\ngetopt: 3.0-\ngetpass: 3.0-\ngettext: 3.0-\nglob: 3.0-\ngraphlib: 3.9-\ngrp: 3.0-\ngzip: 3.0-\nhashlib: 3.0-\nheapq: 3.0-\nhmac: 3.0-\nhtml: 3.0-\nhttp: 3.0-\nimaplib: 3.0-\nimghdr: 3.0-3.12\nimp: 3.0-3.11\nimportlib: 3.0-\nimportlib._abc: 3.10-\nimportlib._bootstrap: 3.0-\nimportlib._bootstrap_external: 3.5-\nimportlib.metadata: 3.8-\nimportlib.metadata._meta: 3.10-\nimportlib.metadata.diagnose: 3.13-\nimportlib.readers: 3.10-\nimportlib.resources: 3.7-\nimportlib.resources._common: 3.11-\nimportlib.resources._functional: 3.13-\nimportlib.resources.abc: 3.11-\nimportlib.resources.readers: 3.11-\nimportlib.resources.simple: 3.11-\nimportlib.simple: 3.11-\ninspect: 3.0-\nio: 3.0-\nipaddress: 3.3-\nitertools: 3.0-\njson: 3.0-\nkeyword: 3.0-\nlib2to3: 3.0-3.12\nlinecache: 3.0-\nlocale: 3.0-\nlogging: 3.0-\nlzma: 3.3-\nmailbox: 3.0-\nmailcap: 3.0-3.12\nmarshal: 3.0-\nmath: 3.0-\nmimetypes: 3.0-\nmmap: 3.0-\nmodulefinder: 3.0-\nmsilib: 3.0-3.12\nmsvcrt: 3.0-\nmultiprocessing: 3.0-\nmultiprocessing.resource_tracker: 3.8-\nmultiprocessing.shared_memory: 3.8-\nnetrc: 3.0-\nnis: 3.0-3.12\nnntplib: 3.0-3.12\nnt: 3.0-\nntpath: 3.0-\nnturl2path: 3.0-\nnumbers: 3.0-\nopcode: 3.0-\noperator: 3.0-\noptparse: 3.0-\nos: 3.0-\nossaudiodev: 3.0-3.12\nparser: 3.0-3.9\npathlib: 3.4-\npathlib.types: 3.14-\npdb: 3.0-\npickle: 3.0-\npickletools: 3.0-\npipes: 3.0-3.12\npkgutil: 3.0-\nplatform: 3.0-\nplistlib: 3.0-\npoplib: 3.0-\nposix: 3.0-\nposixpath: 3.0-\npprint: 3.0-\nprofile: 3.0-\npstats: 3.0-\npty: 3.0-\npwd: 3.0-\npy_compile: 3.0-\npyclbr: 3.0-\npydoc: 3.0-\npydoc_data: 3.0-\npyexpat: 3.0-\nqueue: 3.0-\nquopri: 3.0-\nrandom: 3.0-\nre: 3.0-\nreadline: 3.0-\nreprlib: 3.0-\nresource: 3.0-\nrlcompleter: 3.0-\nrunpy: 3.0-\nsched: 3.0-\nsecrets: 3.6-\nselect: 3.0-\nselectors: 3.4-\nshelve: 3.0-\nshlex: 3.0-\nshutil: 3.0-\nsignal: 3.0-\nsite: 3.0-\nsmtpd: 3.0-3.11\nsmtplib: 3.0-\nsndhdr: 3.0-3.12\nsocket: 3.0-\nsocketserver: 3.0-\nspwd: 3.0-3.12\nsqlite3: 3.0-\nsre_compile: 3.0-\nsre_constants: 3.0-\nsre_parse: 3.0-\nssl: 3.0-\nstat: 3.0-\nstatistics: 3.4-\nstring: 3.0-\nstring.templatelib: 3.14-\nstringprep: 3.0-\nstruct: 3.0-\nsubprocess: 3.0-\nsunau: 3.0-3.12\nsymbol: 3.0-3.9\nsymtable: 3.0-\nsys: 3.0-\nsys._monitoring: 3.12-  # Doesn't actually exist. See comments in the stub.\nsysconfig: 3.0-\nsyslog: 3.0-\ntabnanny: 3.0-\ntarfile: 3.0-\ntelnetlib: 3.0-3.12\ntempfile: 3.0-\ntermios: 3.0-\ntextwrap: 3.0-\nthis: 3.0-\nthreading: 3.0-\ntime: 3.0-\ntimeit: 3.0-\ntkinter: 3.0-\ntkinter.tix: 3.0-3.12\ntoken: 3.0-\ntokenize: 3.0-\ntomllib: 3.11-\ntrace: 3.0-\ntraceback: 3.0-\ntracemalloc: 3.4-\ntty: 3.0-\nturtle: 3.0-\ntypes: 3.0-\ntyping: 3.5-\ntyping_extensions: 3.0-\nunicodedata: 3.0-\nunittest: 3.0-\nunittest._log: 3.9-\nunittest.async_case: 3.8-\nurllib: 3.0-\nuu: 3.0-3.12\nuuid: 3.0-\nvenv: 3.3-\nwarnings: 3.0-\nwave: 3.0-\nweakref: 3.0-\nwebbrowser: 3.0-\nwinreg: 3.0-\nwinsound: 3.0-\nwsgiref: 3.0-\nwsgiref.types: 3.11-\nxdrlib: 3.0-3.12\nxml: 3.0-\nxmlrpc: 3.0-\nxxlimited: 3.2-\nzipapp: 3.5-\nzipfile: 3.0-\nzipfile._path: 3.12-\nzipimport: 3.0-\nzlib: 3.0-\nzoneinfo: 3.9-\n",
  "/typeshed/stdlib/_typeshed/__init__.pyi": "# Utility types for typeshed\n#\n# See the README.md file in this directory for more information.\n\nimport sys\nfrom collections.abc import Awaitable, Callable, Iterable, Iterator, Sequence, Set as AbstractSet, Sized\nfrom dataclasses import Field\nfrom os import PathLike\nfrom types import FrameType, TracebackType\nfrom typing import (\n    Any,\n    AnyStr,\n    ClassVar,\n    Final,\n    Generic,\n    Literal,\n    Protocol,\n    SupportsFloat,\n    SupportsIndex,\n    SupportsInt,\n    TypeVar,\n    final,\n    overload,\n)\nfrom typing_extensions import Buffer, LiteralString, Self as _Self, TypeAlias\n\n_KT = TypeVar(\"_KT\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_KT_contra = TypeVar(\"_KT_contra\", contravariant=True)\n_VT = TypeVar(\"_VT\")\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n\n# Alternative to `typing_extensions.Self`, exclusively for use with `__new__`\n# in metaclasses:\n#     def __new__(cls: type[Self], ...) -> Self: ...\n# In other cases, use `typing_extensions.Self`.\nSelf = TypeVar(\"Self\")  # noqa: Y001\n\n# covariant version of typing.AnyStr, useful for protocols\nAnyStr_co = TypeVar(\"AnyStr_co\", str, bytes, covariant=True)  # noqa: Y001\n\n# For partially known annotations. Usually, fields where type annotations\n# haven't been added are left unannotated, but in some situations this\n# isn't possible or a type is already partially known. In cases like these,\n# use Incomplete instead of Any as a marker. For example, use\n# \"Incomplete | None\" instead of \"Any | None\".\nIncomplete: TypeAlias = Any  # stable\n\n# To describe a function parameter that is unused and will work with anything.\nUnused: TypeAlias = object  # stable\n\n# Marker for return types that include None, but where forcing the user to\n# check for None can be detrimental. Sometimes called \"the Any trick\". See\n# https://typing.python.org/en/latest/guides/writing_stubs.html#the-any-trick\n# for more information.\nMaybeNone: TypeAlias = Any  # stable\n\n# Used to mark arguments that default to a sentinel value. This prevents\n# stubtest from complaining about the default value not matching.\n#\n# def foo(x: int | None = sentinel) -> None: ...\n#\n# In cases where the sentinel object is exported and can be used by user code,\n# a construct like this is better:\n#\n# _SentinelType = NewType(\"_SentinelType\", object)  # does not exist at runtime\n# sentinel: Final[_SentinelType]\n# def foo(x: int | None | _SentinelType = ...) -> None: ...\nsentinel: Any  # stable\n\n# stable\nclass IdentityFunction(Protocol):\n    def __call__(self, x: _T, /) -> _T: ...\n\n# stable\nclass SupportsNext(Protocol[_T_co]):\n    def __next__(self) -> _T_co: ...\n\n# stable\nclass SupportsAnext(Protocol[_T_co]):\n    def __anext__(self) -> Awaitable[_T_co]: ...\n\nclass SupportsBool(Protocol):\n    def __bool__(self) -> bool: ...\n\n# Comparison protocols\nclass SupportsDunderLT(Protocol[_T_contra]):\n    def __lt__(self, other: _T_contra, /) -> SupportsBool: ...\n\nclass SupportsDunderGT(Protocol[_T_contra]):\n    def __gt__(self, other: _T_contra, /) -> SupportsBool: ...\n\nclass SupportsDunderLE(Protocol[_T_contra]):\n    def __le__(self, other: _T_contra, /) -> SupportsBool: ...\n\nclass SupportsDunderGE(Protocol[_T_contra]):\n    def __ge__(self, other: _T_contra, /) -> SupportsBool: ...\n\nclass SupportsAllComparisons(\n    SupportsDunderLT[Any], SupportsDunderGT[Any], SupportsDunderLE[Any], SupportsDunderGE[Any], Protocol\n): ...\n\nSupportsRichComparison: TypeAlias = SupportsDunderLT[Any] | SupportsDunderGT[Any]\nSupportsRichComparisonT = TypeVar(\"SupportsRichComparisonT\", bound=SupportsRichComparison)  # noqa: Y001\n\n# Dunder protocols\n\nclass SupportsAdd(Protocol[_T_contra, _T_co]):\n    def __add__(self, x: _T_contra, /) -> _T_co: ...\n\nclass SupportsRAdd(Protocol[_T_contra, _T_co]):\n    def __radd__(self, x: _T_contra, /) -> _T_co: ...\n\nclass SupportsSub(Protocol[_T_contra, _T_co]):\n    def __sub__(self, x: _T_contra, /) -> _T_co: ...\n\nclass SupportsRSub(Protocol[_T_contra, _T_co]):\n    def __rsub__(self, x: _T_contra, /) -> _T_co: ...\n\nclass SupportsMul(Protocol[_T_contra, _T_co]):\n    def __mul__(self, x: _T_contra, /) -> _T_co: ...\n\nclass SupportsRMul(Protocol[_T_contra, _T_co]):\n    def __rmul__(self, x: _T_contra, /) -> _T_co: ...\n\nclass SupportsDivMod(Protocol[_T_contra, _T_co]):\n    def __divmod__(self, other: _T_contra, /) -> _T_co: ...\n\nclass SupportsRDivMod(Protocol[_T_contra, _T_co]):\n    def __rdivmod__(self, other: _T_contra, /) -> _T_co: ...\n\n# This protocol is generic over the iterator type, while Iterable is\n# generic over the type that is iterated over.\nclass SupportsIter(Protocol[_T_co]):\n    def __iter__(self) -> _T_co: ...\n\n# This protocol is generic over the iterator type, while AsyncIterable is\n# generic over the type that is iterated over.\nclass SupportsAiter(Protocol[_T_co]):\n    def __aiter__(self) -> _T_co: ...\n\nclass SupportsLen(Protocol):\n    def __len__(self) -> int: ...\n\nclass SupportsLenAndGetItem(Protocol[_T_co]):\n    def __len__(self) -> int: ...\n    def __getitem__(self, k: int, /) -> _T_co: ...\n\nclass SupportsTrunc(Protocol):\n    def __trunc__(self) -> int: ...\n\n# Mapping-like protocols\n\n# stable\nclass SupportsItems(Protocol[_KT_co, _VT_co]):\n    def items(self) -> AbstractSet[tuple[_KT_co, _VT_co]]: ...\n\n# stable\nclass SupportsKeysAndGetItem(Protocol[_KT, _VT_co]):\n    def keys(self) -> Iterable[_KT]: ...\n    def __getitem__(self, key: _KT, /) -> _VT_co: ...\n\n# stable\nclass SupportsGetItem(Protocol[_KT_contra, _VT_co]):\n    def __getitem__(self, key: _KT_contra, /) -> _VT_co: ...\n\n# stable\nclass SupportsContainsAndGetItem(Protocol[_KT_contra, _VT_co]):\n    def __contains__(self, x: Any, /) -> bool: ...\n    def __getitem__(self, key: _KT_contra, /) -> _VT_co: ...\n\n# stable\nclass SupportsItemAccess(Protocol[_KT_contra, _VT]):\n    def __contains__(self, x: Any, /) -> bool: ...\n    def __getitem__(self, key: _KT_contra, /) -> _VT: ...\n    def __setitem__(self, key: _KT_contra, value: _VT, /) -> None: ...\n    def __delitem__(self, key: _KT_contra, /) -> None: ...\n\nStrPath: TypeAlias = str | PathLike[str]  # stable\nBytesPath: TypeAlias = bytes | PathLike[bytes]  # stable\nGenericPath: TypeAlias = AnyStr | PathLike[AnyStr]\nStrOrBytesPath: TypeAlias = str | bytes | PathLike[str] | PathLike[bytes]  # stable\n\nOpenTextModeUpdating: TypeAlias = Literal[\n    \"r+\",\n    \"+r\",\n    \"rt+\",\n    \"r+t\",\n    \"+rt\",\n    \"tr+\",\n    \"t+r\",\n    \"+tr\",\n    \"w+\",\n    \"+w\",\n    \"wt+\",\n    \"w+t\",\n    \"+wt\",\n    \"tw+\",\n    \"t+w\",\n    \"+tw\",\n    \"a+\",\n    \"+a\",\n    \"at+\",\n    \"a+t\",\n    \"+at\",\n    \"ta+\",\n    \"t+a\",\n    \"+ta\",\n    \"x+\",\n    \"+x\",\n    \"xt+\",\n    \"x+t\",\n    \"+xt\",\n    \"tx+\",\n    \"t+x\",\n    \"+tx\",\n]\nOpenTextModeWriting: TypeAlias = Literal[\"w\", \"wt\", \"tw\", \"a\", \"at\", \"ta\", \"x\", \"xt\", \"tx\"]\nOpenTextModeReading: TypeAlias = Literal[\"r\", \"rt\", \"tr\", \"U\", \"rU\", \"Ur\", \"rtU\", \"rUt\", \"Urt\", \"trU\", \"tUr\", \"Utr\"]\nOpenTextMode: TypeAlias = OpenTextModeUpdating | OpenTextModeWriting | OpenTextModeReading\nOpenBinaryModeUpdating: TypeAlias = Literal[\n    \"rb+\",\n    \"r+b\",\n    \"+rb\",\n    \"br+\",\n    \"b+r\",\n    \"+br\",\n    \"wb+\",\n    \"w+b\",\n    \"+wb\",\n    \"bw+\",\n    \"b+w\",\n    \"+bw\",\n    \"ab+\",\n    \"a+b\",\n    \"+ab\",\n    \"ba+\",\n    \"b+a\",\n    \"+ba\",\n    \"xb+\",\n    \"x+b\",\n    \"+xb\",\n    \"bx+\",\n    \"b+x\",\n    \"+bx\",\n]\nOpenBinaryModeWriting: TypeAlias = Literal[\"wb\", \"bw\", \"ab\", \"ba\", \"xb\", \"bx\"]\nOpenBinaryModeReading: TypeAlias = Literal[\"rb\", \"br\", \"rbU\", \"rUb\", \"Urb\", \"brU\", \"bUr\", \"Ubr\"]\nOpenBinaryMode: TypeAlias = OpenBinaryModeUpdating | OpenBinaryModeReading | OpenBinaryModeWriting\n\n# stable\nclass HasFileno(Protocol):\n    def fileno(self) -> int: ...\n\nFileDescriptor: TypeAlias = int  # stable\nFileDescriptorLike: TypeAlias = int | HasFileno  # stable\nFileDescriptorOrPath: TypeAlias = int | StrOrBytesPath\n\n# stable\nclass SupportsRead(Protocol[_T_co]):\n    def read(self, length: int = ..., /) -> _T_co: ...\n\n# stable\nclass SupportsReadline(Protocol[_T_co]):\n    def readline(self, length: int = ..., /) -> _T_co: ...\n\n# stable\nclass SupportsNoArgReadline(Protocol[_T_co]):\n    def readline(self) -> _T_co: ...\n\n# stable\nclass SupportsWrite(Protocol[_T_contra]):\n    def write(self, s: _T_contra, /) -> object: ...\n\n# stable\nclass SupportsFlush(Protocol):\n    def flush(self) -> object: ...\n\n# Suitable for dictionary view objects\nclass Viewable(Protocol[_T_co]):\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n\nclass SupportsGetItemViewable(Protocol[_KT, _VT_co]):\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __getitem__(self, key: _KT, /) -> _VT_co: ...\n\n# Unfortunately PEP 688 does not allow us to distinguish read-only\n# from writable buffers. We use these aliases for readability for now.\n# Perhaps a future extension of the buffer protocol will allow us to\n# distinguish these cases in the type system.\nReadOnlyBuffer: TypeAlias = Buffer  # stable\n# Anything that implements the read-write buffer interface.\nWriteableBuffer: TypeAlias = Buffer\n# Same as WriteableBuffer, but also includes read-only buffer types (like bytes).\nReadableBuffer: TypeAlias = Buffer  # stable\n\nclass SliceableBuffer(Buffer, Protocol):\n    def __getitem__(self, slice: slice, /) -> Sequence[int]: ...\n\nclass IndexableBuffer(Buffer, Protocol):\n    def __getitem__(self, i: int, /) -> int: ...\n\nclass SupportsGetItemBuffer(SliceableBuffer, IndexableBuffer, Protocol):\n    def __contains__(self, x: Any, /) -> bool: ...\n    @overload\n    def __getitem__(self, slice: slice, /) -> Sequence[int]: ...\n    @overload\n    def __getitem__(self, i: int, /) -> int: ...\n\nclass SizedBuffer(Sized, Buffer, Protocol): ...\n\nExcInfo: TypeAlias = tuple[type[BaseException], BaseException, TracebackType]\nOptExcInfo: TypeAlias = ExcInfo | tuple[None, None, None]\n\n# stable\nif sys.version_info >= (3, 10):\n    from types import NoneType as NoneType\nelse:\n    # Used by type checkers for checks involving None (does not exist at runtime)\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n\n# This is an internal CPython type that is like, but subtly different from, a NamedTuple\n# Subclasses of this type are found in multiple modules.\n# In typeshed, `structseq` is only ever used as a mixin in combination with a fixed-length `Tuple`\n# See discussion at #6546 & #6560\n# `structseq` classes are unsubclassable, so are all decorated with `@final`.\nclass structseq(Generic[_T_co]):\n    n_fields: Final[int]\n    n_unnamed_fields: Final[int]\n    n_sequence_fields: Final[int]\n    # The first parameter will generally only take an iterable of a specific length.\n    # E.g. `os.uname_result` takes any iterable of length exactly 5.\n    #\n    # The second parameter will accept a dict of any kind without raising an exception,\n    # but only has any meaning if you supply it a dict where the keys are strings.\n    # https://github.com/python/typeshed/pull/6560#discussion_r767149830\n    def __new__(cls, sequence: Iterable[_T_co], dict: dict[str, Any] = ...) -> _Self: ...\n    if sys.version_info >= (3, 13):\n        def __replace__(self, **kwargs: Any) -> _Self: ...\n\n# Superset of typing.AnyStr that also includes LiteralString\nAnyOrLiteralStr = TypeVar(\"AnyOrLiteralStr\", str, bytes, LiteralString)  # noqa: Y001\n\n# Represents when str or LiteralStr is acceptable. Useful for string processing\n# APIs where literalness of return value depends on literalness of inputs\nStrOrLiteralStr = TypeVar(\"StrOrLiteralStr\", LiteralString, str)  # noqa: Y001\n\n# Objects suitable to be passed to sys.setprofile, threading.setprofile, and similar\nProfileFunction: TypeAlias = Callable[[FrameType, str, Any], object]\n\n# Objects suitable to be passed to sys.settrace, threading.settrace, and similar\nTraceFunction: TypeAlias = Callable[[FrameType, str, Any], TraceFunction | None]\n\n# experimental\n# Might not work as expected for pyright, see\n#   https://github.com/python/typeshed/pull/9362\n#   https://github.com/microsoft/pyright/issues/4339\nclass DataclassInstance(Protocol):\n    __dataclass_fields__: ClassVar[dict[str, Field[Any]]]\n\n# Anything that can be passed to the int/float constructors\nif sys.version_info >= (3, 14):\n    ConvertibleToInt: TypeAlias = str | ReadableBuffer | SupportsInt | SupportsIndex\nelse:\n    ConvertibleToInt: TypeAlias = str | ReadableBuffer | SupportsInt | SupportsIndex | SupportsTrunc\nConvertibleToFloat: TypeAlias = str | ReadableBuffer | SupportsFloat | SupportsIndex\n\n# A few classes updated from Foo(str, Enum) to Foo(StrEnum). This is a convenience so these\n# can be accurate on all python versions without getting too wordy\nif sys.version_info >= (3, 11):\n    from enum import StrEnum as StrEnum\nelse:\n    from enum import Enum\n\n    class StrEnum(str, Enum): ...\n\n# Objects that appear in annotations or in type expressions.\n# Similar to PEP 747's TypeForm but a little broader.\nAnnotationForm: TypeAlias = Any\n\nif sys.version_info >= (3, 14):\n    from annotationlib import Format\n\n    # These return annotations, which can be arbitrary objects\n    AnnotateFunc: TypeAlias = Callable[[Format], dict[str, AnnotationForm]]\n    EvaluateFunc: TypeAlias = Callable[[Format], AnnotationForm]\n",
  "/typeshed/stdlib/_typeshed/_type_checker_internals.pyi": "# Internals used by some type checkers.\n#\n# Don't use this module directly. It is only for type checkers to use.\n\nimport sys\nimport typing_extensions\nfrom _collections_abc import dict_items, dict_keys, dict_values\nfrom abc import ABCMeta\nfrom collections.abc import Awaitable, Generator, Iterable, Mapping\nfrom typing import Any, ClassVar, Generic, TypeVar, overload\nfrom typing_extensions import Never\n\n_T = TypeVar(\"_T\")\n\n# Used for an undocumented mypy feature. Does not exist at runtime.\npromote = object()\n\n# Fallback type providing methods and attributes that appear on all `TypedDict` types.\n# N.B. Keep this mostly in sync with typing_extensions._TypedDict/mypy_extensions._TypedDict\nclass TypedDictFallback(Mapping[str, object], metaclass=ABCMeta):\n    __total__: ClassVar[bool]\n    __required_keys__: ClassVar[frozenset[str]]\n    __optional_keys__: ClassVar[frozenset[str]]\n    # __orig_bases__ sometimes exists on <3.12, but not consistently,\n    # so we only add it to the stub on 3.12+\n    if sys.version_info >= (3, 12):\n        __orig_bases__: ClassVar[tuple[Any, ...]]\n    if sys.version_info >= (3, 13):\n        __readonly_keys__: ClassVar[frozenset[str]]\n        __mutable_keys__: ClassVar[frozenset[str]]\n\n    def copy(self) -> typing_extensions.Self: ...\n    # Using Never so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: Never, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: Never, default: _T = ...) -> object: ...  # pyright: ignore[reportInvalidTypeVarUse]\n    def update(self, m: typing_extensions.Self, /) -> None: ...\n    def __delitem__(self, k: Never) -> None: ...\n    def items(self) -> dict_items[str, object]: ...\n    def keys(self) -> dict_keys[str, object]: ...\n    def values(self) -> dict_values[str, object]: ...\n    @overload\n    def __or__(self, value: typing_extensions.Self, /) -> typing_extensions.Self: ...\n    @overload\n    def __or__(self, value: dict[str, Any], /) -> dict[str, object]: ...\n    @overload\n    def __ror__(self, value: typing_extensions.Self, /) -> typing_extensions.Self: ...\n    @overload\n    def __ror__(self, value: dict[str, Any], /) -> dict[str, object]: ...\n    # supposedly incompatible definitions of __or__ and __ior__\n    def __ior__(self, value: typing_extensions.Self, /) -> typing_extensions.Self: ...  # type: ignore[misc]\n\n# Fallback type providing methods and attributes that appear on all `NamedTuple` types.\nclass NamedTupleFallback(tuple[Any, ...]):\n    _field_defaults: ClassVar[dict[str, Any]]\n    _fields: ClassVar[tuple[str, ...]]\n    # __orig_bases__ sometimes exists on <3.12, but not consistently\n    # So we only add it to the stub on 3.12+.\n    if sys.version_info >= (3, 12):\n        __orig_bases__: ClassVar[tuple[Any, ...]]\n\n    @overload\n    def __init__(self, typename: str, fields: Iterable[tuple[str, Any]], /) -> None: ...\n    @overload\n    @typing_extensions.deprecated(\n        \"Creating a typing.NamedTuple using keyword arguments is deprecated and support will be removed in Python 3.15\"\n    )\n    def __init__(self, typename: str, fields: None = None, /, **kwargs: Any) -> None: ...\n    @classmethod\n    def _make(cls, iterable: Iterable[Any]) -> typing_extensions.Self: ...\n    def _asdict(self) -> dict[str, Any]: ...\n    def _replace(self, **kwargs: Any) -> typing_extensions.Self: ...\n    if sys.version_info >= (3, 13):\n        def __replace__(self, **kwargs: Any) -> typing_extensions.Self: ...\n\n# Non-default variations to accommodate couroutines, and `AwaitableGenerator` having a 4th type parameter.\n_S = TypeVar(\"_S\")\n_YieldT_co = TypeVar(\"_YieldT_co\", covariant=True)\n_SendT_nd_contra = TypeVar(\"_SendT_nd_contra\", contravariant=True)\n_ReturnT_nd_co = TypeVar(\"_ReturnT_nd_co\", covariant=True)\n\n# The parameters correspond to Generator, but the 4th is the original type.\nclass AwaitableGenerator(\n    Awaitable[_ReturnT_nd_co],\n    Generator[_YieldT_co, _SendT_nd_contra, _ReturnT_nd_co],\n    Generic[_YieldT_co, _SendT_nd_contra, _ReturnT_nd_co, _S],\n    metaclass=ABCMeta,\n): ...\n",
  "/typeshed/stdlib/_typeshed/dbapi.pyi": "# PEP 249 Database API 2.0 Types\n# https://www.python.org/dev/peps/pep-0249/\n\nfrom collections.abc import Mapping, Sequence\nfrom typing import Any, Protocol\nfrom typing_extensions import TypeAlias\n\nDBAPITypeCode: TypeAlias = Any | None\n# Strictly speaking, this should be a Sequence, but the type system does\n# not support fixed-length sequences.\nDBAPIColumnDescription: TypeAlias = tuple[str, DBAPITypeCode, int | None, int | None, int | None, int | None, bool | None]\n\nclass DBAPIConnection(Protocol):\n    def close(self) -> object: ...\n    def commit(self) -> object: ...\n    # optional:\n    # def rollback(self) -> Any: ...\n    def cursor(self) -> DBAPICursor: ...\n\nclass DBAPICursor(Protocol):\n    @property\n    def description(self) -> Sequence[DBAPIColumnDescription] | None: ...\n    @property\n    def rowcount(self) -> int: ...\n    # optional:\n    # def callproc(self, procname: str, parameters: Sequence[Any] = ..., /) -> Sequence[Any]: ...\n    def close(self) -> object: ...\n    def execute(self, operation: str, parameters: Sequence[Any] | Mapping[str, Any] = ..., /) -> object: ...\n    def executemany(self, operation: str, seq_of_parameters: Sequence[Sequence[Any]], /) -> object: ...\n    def fetchone(self) -> Sequence[Any] | None: ...\n    def fetchmany(self, size: int = ..., /) -> Sequence[Sequence[Any]]: ...\n    def fetchall(self) -> Sequence[Sequence[Any]]: ...\n    # optional:\n    # def nextset(self) -> None | Literal[True]: ...\n    arraysize: int\n    def setinputsizes(self, sizes: Sequence[DBAPITypeCode | int | None], /) -> object: ...\n    def setoutputsize(self, size: int, column: int = ..., /) -> object: ...\n",
  "/typeshed/stdlib/_typeshed/importlib.pyi": "# Implicit protocols used in importlib.\n# We intentionally omit deprecated and optional methods.\n\nfrom collections.abc import Sequence\nfrom importlib.machinery import ModuleSpec\nfrom types import ModuleType\nfrom typing import Protocol\n\n__all__ = [\"LoaderProtocol\", \"MetaPathFinderProtocol\", \"PathEntryFinderProtocol\"]\n\nclass LoaderProtocol(Protocol):\n    def load_module(self, fullname: str, /) -> ModuleType: ...\n\nclass MetaPathFinderProtocol(Protocol):\n    def find_spec(self, fullname: str, path: Sequence[str] | None, target: ModuleType | None = ..., /) -> ModuleSpec | None: ...\n\nclass PathEntryFinderProtocol(Protocol):\n    def find_spec(self, fullname: str, target: ModuleType | None = ..., /) -> ModuleSpec | None: ...\n",
  "/typeshed/stdlib/_typeshed/wsgi.pyi": "# Types to support PEP 3333 (WSGI)\n#\n# Obsolete since Python 3.11: Use wsgiref.types instead.\n#\n# See the README.md file in this directory for more information.\n\nimport sys\nfrom _typeshed import OptExcInfo\nfrom collections.abc import Callable, Iterable, Iterator\nfrom typing import Any, Protocol\nfrom typing_extensions import TypeAlias\n\nclass _Readable(Protocol):\n    def read(self, size: int = ..., /) -> bytes: ...\n    # Optional: def close(self) -> object: ...\n\nif sys.version_info >= (3, 11):\n    from wsgiref.types import *\nelse:\n    # stable\n    class StartResponse(Protocol):\n        def __call__(\n            self, status: str, headers: list[tuple[str, str]], exc_info: OptExcInfo | None = ..., /\n        ) -> Callable[[bytes], object]: ...\n\n    WSGIEnvironment: TypeAlias = dict[str, Any]  # stable\n    WSGIApplication: TypeAlias = Callable[[WSGIEnvironment, StartResponse], Iterable[bytes]]  # stable\n\n    # WSGI input streams per PEP 3333, stable\n    class InputStream(Protocol):\n        def read(self, size: int = ..., /) -> bytes: ...\n        def readline(self, size: int = ..., /) -> bytes: ...\n        def readlines(self, hint: int = ..., /) -> list[bytes]: ...\n        def __iter__(self) -> Iterator[bytes]: ...\n\n    # WSGI error streams per PEP 3333, stable\n    class ErrorStream(Protocol):\n        def flush(self) -> object: ...\n        def write(self, s: str, /) -> object: ...\n        def writelines(self, seq: list[str], /) -> object: ...\n\n    # Optional file wrapper in wsgi.file_wrapper\n    class FileWrapper(Protocol):\n        def __call__(self, file: _Readable, block_size: int = ..., /) -> Iterable[bytes]: ...\n",
  "/typeshed/stdlib/_typeshed/xml.pyi": "# See the README.md file in this directory for more information.\n\nfrom typing import Any, Protocol\n\n# As defined https://docs.python.org/3/library/xml.dom.html#domimplementation-objects\nclass DOMImplementation(Protocol):\n    def hasFeature(self, feature: str, version: str | None, /) -> bool: ...\n    def createDocument(self, namespaceUri: str, qualifiedName: str, doctype: Any | None, /) -> Any: ...\n    def createDocumentType(self, qualifiedName: str, publicId: str, systemId: str, /) -> Any: ...\n",
  "/typeshed/stdlib/abc.pyi": "import _typeshed\nimport sys\nfrom _typeshed import SupportsWrite\nfrom collections.abc import Callable\nfrom typing import Any, Literal, TypeVar\nfrom typing_extensions import Concatenate, ParamSpec, deprecated\n\n_T = TypeVar(\"_T\")\n_R_co = TypeVar(\"_R_co\", covariant=True)\n_FuncT = TypeVar(\"_FuncT\", bound=Callable[..., Any])\n_P = ParamSpec(\"_P\")\n\n# These definitions have special processing in mypy\nclass ABCMeta(type):\n    __abstractmethods__: frozenset[str]\n    if sys.version_info >= (3, 11):\n        def __new__(\n            mcls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], /, **kwargs: Any\n        ) -> _typeshed.Self: ...\n    else:\n        def __new__(\n            mcls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], **kwargs: Any\n        ) -> _typeshed.Self: ...\n\n    def __instancecheck__(cls: ABCMeta, instance: Any) -> bool: ...\n    def __subclasscheck__(cls: ABCMeta, subclass: type) -> bool: ...\n    def _dump_registry(cls: ABCMeta, file: SupportsWrite[str] | None = None) -> None: ...\n    def register(cls: ABCMeta, subclass: type[_T]) -> type[_T]: ...\n\ndef abstractmethod(funcobj: _FuncT) -> _FuncT: ...\n@deprecated(\"Deprecated since Python 3.3. Use `@classmethod` stacked on top of `@abstractmethod` instead.\")\nclass abstractclassmethod(classmethod[_T, _P, _R_co]):\n    __isabstractmethod__: Literal[True]\n    def __init__(self, callable: Callable[Concatenate[type[_T], _P], _R_co]) -> None: ...\n\n@deprecated(\"Deprecated since Python 3.3. Use `@staticmethod` stacked on top of `@abstractmethod` instead.\")\nclass abstractstaticmethod(staticmethod[_P, _R_co]):\n    __isabstractmethod__: Literal[True]\n    def __init__(self, callable: Callable[_P, _R_co]) -> None: ...\n\n@deprecated(\"Deprecated since Python 3.3. Use `@property` stacked on top of `@abstractmethod` instead.\")\nclass abstractproperty(property):\n    __isabstractmethod__: Literal[True]\n\nclass ABC(metaclass=ABCMeta):\n    __slots__ = ()\n\ndef get_cache_token() -> object: ...\n\nif sys.version_info >= (3, 10):\n    def update_abstractmethods(cls: type[_T]) -> type[_T]: ...\n",
  "/typeshed/stdlib/builtins.pyi": "import _ast\nimport _sitebuiltins\nimport _typeshed\nimport sys\nimport types\nfrom _collections_abc import dict_items, dict_keys, dict_values\nfrom _typeshed import (\n    AnnotationForm,\n    ConvertibleToFloat,\n    ConvertibleToInt,\n    FileDescriptorOrPath,\n    OpenBinaryMode,\n    OpenBinaryModeReading,\n    OpenBinaryModeUpdating,\n    OpenBinaryModeWriting,\n    OpenTextMode,\n    ReadableBuffer,\n    SupportsAdd,\n    SupportsAiter,\n    SupportsAnext,\n    SupportsDivMod,\n    SupportsFlush,\n    SupportsIter,\n    SupportsKeysAndGetItem,\n    SupportsLenAndGetItem,\n    SupportsNext,\n    SupportsRAdd,\n    SupportsRDivMod,\n    SupportsRichComparison,\n    SupportsRichComparisonT,\n    SupportsWrite,\n)\nfrom collections.abc import Awaitable, Callable, Iterable, Iterator, MutableSet, Reversible, Set as AbstractSet, Sized\nfrom io import BufferedRandom, BufferedReader, BufferedWriter, FileIO, TextIOWrapper\nfrom os import PathLike\nfrom types import CellType, CodeType, GenericAlias, TracebackType\n\n# mypy crashes if any of {ByteString, Sequence, MutableSequence, Mapping, MutableMapping}\n# are imported from collections.abc in builtins.pyi\nfrom typing import (  # noqa: Y022,UP035\n    IO,\n    Any,\n    BinaryIO,\n    ClassVar,\n    Final,\n    Generic,\n    Mapping,\n    MutableMapping,\n    MutableSequence,\n    Protocol,\n    Sequence,\n    SupportsAbs,\n    SupportsBytes,\n    SupportsComplex,\n    SupportsFloat,\n    SupportsIndex,\n    TypeVar,\n    final,\n    overload,\n    type_check_only,\n)\n\n# we can't import `Literal` from typing or mypy crashes: see #11247\nfrom typing_extensions import (  # noqa: Y023\n    Concatenate,\n    Literal,\n    LiteralString,\n    ParamSpec,\n    Self,\n    TypeAlias,\n    TypeGuard,\n    TypeIs,\n    TypeVarTuple,\n    deprecated,\n    disjoint_base,\n)\n\nif sys.version_info >= (3, 14):\n    from _typeshed import AnnotateFunc\n\n_T = TypeVar(\"_T\")\n_I = TypeVar(\"_I\", default=int)\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n_R_co = TypeVar(\"_R_co\", covariant=True)\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_S = TypeVar(\"_S\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_SupportsNextT_co = TypeVar(\"_SupportsNextT_co\", bound=SupportsNext[Any], covariant=True)\n_SupportsAnextT_co = TypeVar(\"_SupportsAnextT_co\", bound=SupportsAnext[Any], covariant=True)\n_AwaitableT = TypeVar(\"_AwaitableT\", bound=Awaitable[Any])\n_AwaitableT_co = TypeVar(\"_AwaitableT_co\", bound=Awaitable[Any], covariant=True)\n_P = ParamSpec(\"_P\")\n\n# Type variables for slice\n_StartT_co = TypeVar(\"_StartT_co\", covariant=True, default=Any)  # slice -> slice[Any, Any, Any]\n_StopT_co = TypeVar(\"_StopT_co\", covariant=True, default=_StartT_co)  #  slice[A] -> slice[A, A, A]\n# NOTE: step could differ from start and stop, (e.g. datetime/timedelta)l\n#   the default (start|stop) is chosen to cater to the most common case of int/index slices.\n# FIXME: https://github.com/python/typing/issues/213 (replace step=start|stop with step=start&stop)\n_StepT_co = TypeVar(\"_StepT_co\", covariant=True, default=_StartT_co | _StopT_co)  #  slice[A,B] -> slice[A, B, A|B]\n\n@disjoint_base\nclass object:\n    __doc__: str | None\n    __dict__: dict[str, Any]\n    __module__: str\n    __annotations__: dict[str, Any]\n    @property\n    def __class__(self) -> type[Self]: ...\n    @__class__.setter\n    def __class__(self, type: type[Self], /) -> None: ...\n    def __init__(self) -> None: ...\n    def __new__(cls) -> Self: ...\n    # N.B. `object.__setattr__` and `object.__delattr__` are heavily special-cased by type checkers.\n    # Overriding them in subclasses has different semantics, even if the override has an identical signature.\n    def __setattr__(self, name: str, value: Any, /) -> None: ...\n    def __delattr__(self, name: str, /) -> None: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __ne__(self, value: object, /) -> bool: ...\n    def __str__(self) -> str: ...  # noqa: Y029\n    def __repr__(self) -> str: ...  # noqa: Y029\n    def __hash__(self) -> int: ...\n    def __format__(self, format_spec: str, /) -> str: ...\n    def __getattribute__(self, name: str, /) -> Any: ...\n    def __sizeof__(self) -> int: ...\n    # return type of pickle methods is rather hard to express in the current type system\n    # see #6661 and https://docs.python.org/3/library/pickle.html#object.__reduce__\n    def __reduce__(self) -> str | tuple[Any, ...]: ...\n    def __reduce_ex__(self, protocol: SupportsIndex, /) -> str | tuple[Any, ...]: ...\n    if sys.version_info >= (3, 11):\n        def __getstate__(self) -> object: ...\n\n    def __dir__(self) -> Iterable[str]: ...\n    def __init_subclass__(cls) -> None: ...\n    @classmethod\n    def __subclasshook__(cls, subclass: type, /) -> bool: ...\n\n@disjoint_base\nclass staticmethod(Generic[_P, _R_co]):\n    @property\n    def __func__(self) -> Callable[_P, _R_co]: ...\n    @property\n    def __isabstractmethod__(self) -> bool: ...\n    def __init__(self, f: Callable[_P, _R_co], /) -> None: ...\n    @overload\n    def __get__(self, instance: None, owner: type, /) -> Callable[_P, _R_co]: ...\n    @overload\n    def __get__(self, instance: _T, owner: type[_T] | None = None, /) -> Callable[_P, _R_co]: ...\n    if sys.version_info >= (3, 10):\n        __name__: str\n        __qualname__: str\n        @property\n        def __wrapped__(self) -> Callable[_P, _R_co]: ...\n        def __call__(self, *args: _P.args, **kwargs: _P.kwargs) -> _R_co: ...\n    if sys.version_info >= (3, 14):\n        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n        __annotate__: AnnotateFunc | None\n\n@disjoint_base\nclass classmethod(Generic[_T, _P, _R_co]):\n    @property\n    def __func__(self) -> Callable[Concatenate[type[_T], _P], _R_co]: ...\n    @property\n    def __isabstractmethod__(self) -> bool: ...\n    def __init__(self, f: Callable[Concatenate[type[_T], _P], _R_co], /) -> None: ...\n    @overload\n    def __get__(self, instance: _T, owner: type[_T] | None = None, /) -> Callable[_P, _R_co]: ...\n    @overload\n    def __get__(self, instance: None, owner: type[_T], /) -> Callable[_P, _R_co]: ...\n    if sys.version_info >= (3, 10):\n        __name__: str\n        __qualname__: str\n        @property\n        def __wrapped__(self) -> Callable[Concatenate[type[_T], _P], _R_co]: ...\n    if sys.version_info >= (3, 14):\n        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n        __annotate__: AnnotateFunc | None\n\n@disjoint_base\nclass type:\n    # object.__base__ is None. Otherwise, it would be a type.\n    @property\n    def __base__(self) -> type | None: ...\n    __bases__: tuple[type, ...]\n    @property\n    def __basicsize__(self) -> int: ...\n    # type.__dict__ is read-only at runtime, but that can't be expressed currently.\n    # See https://github.com/python/typeshed/issues/11033 for a discussion.\n    __dict__: Final[types.MappingProxyType[str, Any]]  # type: ignore[assignment]\n    @property\n    def __dictoffset__(self) -> int: ...\n    @property\n    def __flags__(self) -> int: ...\n    @property\n    def __itemsize__(self) -> int: ...\n    __module__: str\n    @property\n    def __mro__(self) -> tuple[type, ...]: ...\n    __name__: str\n    __qualname__: str\n    @property\n    def __text_signature__(self) -> str | None: ...\n    @property\n    def __weakrefoffset__(self) -> int: ...\n    @overload\n    def __init__(self, o: object, /) -> None: ...\n    @overload\n    def __init__(self, name: str, bases: tuple[type, ...], dict: dict[str, Any], /, **kwds: Any) -> None: ...\n    @overload\n    def __new__(cls, o: object, /) -> type: ...\n    @overload\n    def __new__(\n        cls: type[_typeshed.Self], name: str, bases: tuple[type, ...], namespace: dict[str, Any], /, **kwds: Any\n    ) -> _typeshed.Self: ...\n    def __call__(self, *args: Any, **kwds: Any) -> Any: ...\n    def __subclasses__(self: _typeshed.Self) -> list[_typeshed.Self]: ...\n    # Note: the documentation doesn't specify what the return type is, the standard\n    # implementation seems to be returning a list.\n    def mro(self) -> list[type]: ...\n    def __instancecheck__(self, instance: Any, /) -> bool: ...\n    def __subclasscheck__(self, subclass: type, /) -> bool: ...\n    @classmethod\n    def __prepare__(metacls, name: str, bases: tuple[type, ...], /, **kwds: Any) -> MutableMapping[str, object]: ...\n    if sys.version_info >= (3, 10):\n        # `int | str` produces an instance of `UnionType`, but `int | int` produces an instance of `type`,\n        # and `abc.ABC | abc.ABC` produces an instance of `abc.ABCMeta`.\n        def __or__(self: _typeshed.Self, value: Any, /) -> types.UnionType | _typeshed.Self: ...\n        def __ror__(self: _typeshed.Self, value: Any, /) -> types.UnionType | _typeshed.Self: ...\n    if sys.version_info >= (3, 12):\n        __type_params__: tuple[TypeVar | ParamSpec | TypeVarTuple, ...]\n    __annotations__: dict[str, AnnotationForm]\n    if sys.version_info >= (3, 14):\n        __annotate__: AnnotateFunc | None\n\n@disjoint_base\nclass super:\n    @overload\n    def __init__(self, t: Any, obj: Any, /) -> None: ...\n    @overload\n    def __init__(self, t: Any, /) -> None: ...\n    @overload\n    def __init__(self) -> None: ...\n\n_PositiveInteger: TypeAlias = Literal[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n_NegativeInteger: TypeAlias = Literal[-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20]\n_LiteralInteger = _PositiveInteger | _NegativeInteger | Literal[0]  # noqa: Y026  # TODO: Use TypeAlias once mypy bugs are fixed\n\n@disjoint_base\nclass int:\n    @overload\n    def __new__(cls, x: ConvertibleToInt = 0, /) -> Self: ...\n    @overload\n    def __new__(cls, x: str | bytes | bytearray, /, base: SupportsIndex) -> Self: ...\n    def as_integer_ratio(self) -> tuple[int, Literal[1]]: ...\n    @property\n    def real(self) -> int: ...\n    @property\n    def imag(self) -> Literal[0]: ...\n    @property\n    def numerator(self) -> int: ...\n    @property\n    def denominator(self) -> Literal[1]: ...\n    def conjugate(self) -> int: ...\n    def bit_length(self) -> int: ...\n    if sys.version_info >= (3, 10):\n        def bit_count(self) -> int: ...\n\n    if sys.version_info >= (3, 11):\n        def to_bytes(\n            self, length: SupportsIndex = 1, byteorder: Literal[\"little\", \"big\"] = \"big\", *, signed: bool = False\n        ) -> bytes: ...\n        @classmethod\n        def from_bytes(\n            cls,\n            bytes: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer,\n            byteorder: Literal[\"little\", \"big\"] = \"big\",\n            *,\n            signed: bool = False,\n        ) -> Self: ...\n    else:\n        def to_bytes(self, length: SupportsIndex, byteorder: Literal[\"little\", \"big\"], *, signed: bool = False) -> bytes: ...\n        @classmethod\n        def from_bytes(\n            cls,\n            bytes: Iterable[SupportsIndex] | SupportsBytes | ReadableBuffer,\n            byteorder: Literal[\"little\", \"big\"],\n            *,\n            signed: bool = False,\n        ) -> Self: ...\n\n    if sys.version_info >= (3, 12):\n        def is_integer(self) -> Literal[True]: ...\n\n    def __add__(self, value: int, /) -> int: ...\n    def __sub__(self, value: int, /) -> int: ...\n    def __mul__(self, value: int, /) -> int: ...\n    def __floordiv__(self, value: int, /) -> int: ...\n    def __truediv__(self, value: int, /) -> float: ...\n    def __mod__(self, value: int, /) -> int: ...\n    def __divmod__(self, value: int, /) -> tuple[int, int]: ...\n    def __radd__(self, value: int, /) -> int: ...\n    def __rsub__(self, value: int, /) -> int: ...\n    def __rmul__(self, value: int, /) -> int: ...\n    def __rfloordiv__(self, value: int, /) -> int: ...\n    def __rtruediv__(self, value: int, /) -> float: ...\n    def __rmod__(self, value: int, /) -> int: ...\n    def __rdivmod__(self, value: int, /) -> tuple[int, int]: ...\n    @overload\n    def __pow__(self, x: Literal[0], /) -> Literal[1]: ...\n    @overload\n    def __pow__(self, value: Literal[0], mod: None, /) -> Literal[1]: ...\n    @overload\n    def __pow__(self, value: _PositiveInteger, mod: None = None, /) -> int: ...\n    @overload\n    def __pow__(self, value: _NegativeInteger, mod: None = None, /) -> float: ...\n    # positive __value -> int; negative __value -> float\n    # return type must be Any as `int | float` causes too many false-positive errors\n    @overload\n    def __pow__(self, value: int, mod: None = None, /) -> Any: ...\n    @overload\n    def __pow__(self, value: int, mod: int, /) -> int: ...\n    def __rpow__(self, value: int, mod: int | None = None, /) -> Any: ...\n    def __and__(self, value: int, /) -> int: ...\n    def __or__(self, value: int, /) -> int: ...\n    def __xor__(self, value: int, /) -> int: ...\n    def __lshift__(self, value: int, /) -> int: ...\n    def __rshift__(self, value: int, /) -> int: ...\n    def __rand__(self, value: int, /) -> int: ...\n    def __ror__(self, value: int, /) -> int: ...\n    def __rxor__(self, value: int, /) -> int: ...\n    def __rlshift__(self, value: int, /) -> int: ...\n    def __rrshift__(self, value: int, /) -> int: ...\n    def __neg__(self) -> int: ...\n    def __pos__(self) -> int: ...\n    def __invert__(self) -> int: ...\n    def __trunc__(self) -> int: ...\n    def __ceil__(self) -> int: ...\n    def __floor__(self) -> int: ...\n    if sys.version_info >= (3, 14):\n        def __round__(self, ndigits: SupportsIndex | None = None, /) -> int: ...\n    else:\n        def __round__(self, ndigits: SupportsIndex = ..., /) -> int: ...\n\n    def __getnewargs__(self) -> tuple[int]: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __ne__(self, value: object, /) -> bool: ...\n    def __lt__(self, value: int, /) -> bool: ...\n    def __le__(self, value: int, /) -> bool: ...\n    def __gt__(self, value: int, /) -> bool: ...\n    def __ge__(self, value: int, /) -> bool: ...\n    def __float__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __abs__(self) -> int: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    def __index__(self) -> int: ...\n    def __format__(self, format_spec: str, /) -> str: ...\n\n@disjoint_base\nclass float:\n    def __new__(cls, x: ConvertibleToFloat = 0, /) -> Self: ...\n    def as_integer_ratio(self) -> tuple[int, int]: ...\n    def hex(self) -> str: ...\n    def is_integer(self) -> bool: ...\n    @classmethod\n    def fromhex(cls, string: str, /) -> Self: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def conjugate(self) -> float: ...\n    def __add__(self, value: float, /) -> float: ...\n    def __sub__(self, value: float, /) -> float: ...\n    def __mul__(self, value: float, /) -> float: ...\n    def __floordiv__(self, value: float, /) -> float: ...\n    def __truediv__(self, value: float, /) -> float: ...\n    def __mod__(self, value: float, /) -> float: ...\n    def __divmod__(self, value: float, /) -> tuple[float, float]: ...\n    @overload\n    def __pow__(self, value: int, mod: None = None, /) -> float: ...\n    # positive __value -> float; negative __value -> complex\n    # return type must be Any as `float | complex` causes too many false-positive errors\n    @overload\n    def __pow__(self, value: float, mod: None = None, /) -> Any: ...\n    def __radd__(self, value: float, /) -> float: ...\n    def __rsub__(self, value: float, /) -> float: ...\n    def __rmul__(self, value: float, /) -> float: ...\n    def __rfloordiv__(self, value: float, /) -> float: ...\n    def __rtruediv__(self, value: float, /) -> float: ...\n    def __rmod__(self, value: float, /) -> float: ...\n    def __rdivmod__(self, value: float, /) -> tuple[float, float]: ...\n    @overload\n    def __rpow__(self, value: _PositiveInteger, mod: None = None, /) -> float: ...\n    @overload\n    def __rpow__(self, value: _NegativeInteger, mod: None = None, /) -> complex: ...\n    # Returning `complex` for the general case gives too many false-positive errors.\n    @overload\n    def __rpow__(self, value: float, mod: None = None, /) -> Any: ...\n    def __getnewargs__(self) -> tuple[float]: ...\n    def __trunc__(self) -> int: ...\n    def __ceil__(self) -> int: ...\n    def __floor__(self) -> int: ...\n    @overload\n    def __round__(self, ndigits: None = None, /) -> int: ...\n    @overload\n    def __round__(self, ndigits: SupportsIndex, /) -> float: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __ne__(self, value: object, /) -> bool: ...\n    def __lt__(self, value: float, /) -> bool: ...\n    def __le__(self, value: float, /) -> bool: ...\n    def __gt__(self, value: float, /) -> bool: ...\n    def __ge__(self, value: float, /) -> bool: ...\n    def __neg__(self) -> float: ...\n    def __pos__(self) -> float: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    def __format__(self, format_spec: str, /) -> str: ...\n    if sys.version_info >= (3, 14):\n        @classmethod\n        def from_number(cls, number: float | SupportsIndex | SupportsFloat, /) -> Self: ...\n\n@disjoint_base\nclass complex:\n    # Python doesn't currently accept SupportsComplex for the second argument\n    @overload\n    def __new__(\n        cls,\n        real: complex | SupportsComplex | SupportsFloat | SupportsIndex = 0,\n        imag: complex | SupportsFloat | SupportsIndex = 0,\n    ) -> Self: ...\n    @overload\n    def __new__(cls, real: str | SupportsComplex | SupportsFloat | SupportsIndex | complex) -> Self: ...\n    @property\n    def real(self) -> float: ...\n    @property\n    def imag(self) -> float: ...\n    def conjugate(self) -> complex: ...\n    def __add__(self, value: complex, /) -> complex: ...\n    def __sub__(self, value: complex, /) -> complex: ...\n    def __mul__(self, value: complex, /) -> complex: ...\n    def __pow__(self, value: complex, mod: None = None, /) -> complex: ...\n    def __truediv__(self, value: complex, /) -> complex: ...\n    def __radd__(self, value: complex, /) -> complex: ...\n    def __rsub__(self, value: complex, /) -> complex: ...\n    def __rmul__(self, value: complex, /) -> complex: ...\n    def __rpow__(self, value: complex, mod: None = None, /) -> complex: ...\n    def __rtruediv__(self, value: complex, /) -> complex: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __ne__(self, value: object, /) -> bool: ...\n    def __neg__(self) -> complex: ...\n    def __pos__(self) -> complex: ...\n    def __abs__(self) -> float: ...\n    def __hash__(self) -> int: ...\n    def __bool__(self) -> bool: ...\n    def __format__(self, format_spec: str, /) -> str: ...\n    if sys.version_info >= (3, 11):\n        def __complex__(self) -> complex: ...\n    if sys.version_info >= (3, 14):\n        @classmethod\n        def from_number(cls, number: complex | SupportsComplex | SupportsFloat | SupportsIndex, /) -> Self: ...\n\n@type_check_only\nclass _FormatMapMapping(Protocol):\n    def __getitem__(self, key: str, /) -> Any: ...\n\n@type_check_only\nclass _TranslateTable(Protocol):\n    def __getitem__(self, key: int, /) -> str | int | None: ...\n\n@disjoint_base\nclass str(Sequence[str]):\n    @overload\n    def __new__(cls, object: object = \"\") -> Self: ...\n    @overload\n    def __new__(cls, object: ReadableBuffer, encoding: str = \"utf-8\", errors: str = \"strict\") -> Self: ...\n    @overload\n    def capitalize(self: LiteralString) -> LiteralString: ...\n    @overload\n    def capitalize(self) -> str: ...  # type: ignore[misc]\n    @overload\n    def casefold(self: LiteralString) -> LiteralString: ...\n    @overload\n    def casefold(self) -> str: ...  # type: ignore[misc]\n    @overload\n    def center(self: LiteralString, width: SupportsIndex, fillchar: LiteralString = \" \", /) -> LiteralString: ...\n    @overload\n    def center(self, width: SupportsIndex, fillchar: str = \" \", /) -> str: ...  # type: ignore[misc]\n    def count(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...\n    def encode(self, encoding: str = \"utf-8\", errors: str = \"strict\") -> bytes: ...\n    def endswith(\n        self, suffix: str | tuple[str, ...], start: SupportsIndex | None = None, end: SupportsIndex | None = None, /\n    ) -> bool: ...\n    @overload\n    def expandtabs(self: LiteralString, tabsize: SupportsIndex = 8) -> LiteralString: ...\n    @overload\n    def expandtabs(self, tabsize: SupportsIndex = 8) -> str: ...  # type: ignore[misc]\n    def find(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...\n    @overload\n    def format(self: LiteralString, *args: LiteralString, **kwargs: LiteralString) -> LiteralString: ...\n    @overload\n    def format(self, *args: object, **kwargs: object) -> str: ...\n    def format_map(self, mapping: _FormatMapMapping, /) -> str: ...\n    def index(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...\n    def isalnum(self) -> bool: ...\n    def isalpha(self) -> bool: ...\n    def isascii(self) -> bool: ...\n    def isdecimal(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def isidentifier(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isnumeric(self) -> bool: ...\n    def isprintable(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    @overload\n    def join(self: LiteralString, iterable: Iterable[LiteralString], /) -> LiteralString: ...\n    @overload\n    def join(self, iterable: Iterable[str], /) -> str: ...  # type: ignore[misc]\n    @overload\n    def ljust(self: LiteralString, width: SupportsIndex, fillchar: LiteralString = \" \", /) -> LiteralString: ...\n    @overload\n    def ljust(self, width: SupportsIndex, fillchar: str = \" \", /) -> str: ...  # type: ignore[misc]\n    @overload\n    def lower(self: LiteralString) -> LiteralString: ...\n    @overload\n    def lower(self) -> str: ...  # type: ignore[misc]\n    @overload\n    def lstrip(self: LiteralString, chars: LiteralString | None = None, /) -> LiteralString: ...\n    @overload\n    def lstrip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]\n    @overload\n    def partition(self: LiteralString, sep: LiteralString, /) -> tuple[LiteralString, LiteralString, LiteralString]: ...\n    @overload\n    def partition(self, sep: str, /) -> tuple[str, str, str]: ...  # type: ignore[misc]\n    if sys.version_info >= (3, 13):\n        @overload\n        def replace(\n            self: LiteralString, old: LiteralString, new: LiteralString, /, count: SupportsIndex = -1\n        ) -> LiteralString: ...\n        @overload\n        def replace(self, old: str, new: str, /, count: SupportsIndex = -1) -> str: ...  # type: ignore[misc]\n    else:\n        @overload\n        def replace(\n            self: LiteralString, old: LiteralString, new: LiteralString, count: SupportsIndex = -1, /\n        ) -> LiteralString: ...\n        @overload\n        def replace(self, old: str, new: str, count: SupportsIndex = -1, /) -> str: ...  # type: ignore[misc]\n\n    @overload\n    def removeprefix(self: LiteralString, prefix: LiteralString, /) -> LiteralString: ...\n    @overload\n    def removeprefix(self, prefix: str, /) -> str: ...  # type: ignore[misc]\n    @overload\n    def removesuffix(self: LiteralString, suffix: LiteralString, /) -> LiteralString: ...\n    @overload\n    def removesuffix(self, suffix: str, /) -> str: ...  # type: ignore[misc]\n    def rfind(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...\n    def rindex(self, sub: str, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /) -> int: ...\n    @overload\n    def rjust(self: LiteralString, width: SupportsIndex, fillchar: LiteralString = \" \", /) -> LiteralString: ...\n    @overload\n    def rjust(self, width: SupportsIndex, fillchar: str = \" \", /) -> str: ...  # type: ignore[misc]\n    @overload\n    def rpartition(self: LiteralString, sep: LiteralString, /) -> tuple[LiteralString, LiteralString, LiteralString]: ...\n    @overload\n    def rpartition(self, sep: str, /) -> tuple[str, str, str]: ...  # type: ignore[misc]\n    @overload\n    def rsplit(self: LiteralString, sep: LiteralString | None = None, maxsplit: SupportsIndex = -1) -> list[LiteralString]: ...\n    @overload\n    def rsplit(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...  # type: ignore[misc]\n    @overload\n    def rstrip(self: LiteralString, chars: LiteralString | None = None, /) -> LiteralString: ...\n    @overload\n    def rstrip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]\n    @overload\n    def split(self: LiteralString, sep: LiteralString | None = None, maxsplit: SupportsIndex = -1) -> list[LiteralString]: ...\n    @overload\n    def split(self, sep: str | None = None, maxsplit: SupportsIndex = -1) -> list[str]: ...  # type: ignore[misc]\n    @overload\n    def splitlines(self: LiteralString, keepends: bool = False) -> list[LiteralString]: ...\n    @overload\n    def splitlines(self, keepends: bool = False) -> list[str]: ...  # type: ignore[misc]\n    def startswith(\n        self, prefix: str | tuple[str, ...], start: SupportsIndex | None = None, end: SupportsIndex | None = None, /\n    ) -> bool: ...\n    @overload\n    def strip(self: LiteralString, chars: LiteralString | None = None, /) -> LiteralString: ...\n    @overload\n    def strip(self, chars: str | None = None, /) -> str: ...  # type: ignore[misc]\n    @overload\n    def swapcase(self: LiteralString) -> LiteralString: ...\n    @overload\n    def swapcase(self) -> str: ...  # type: ignore[misc]\n    @overload\n    def title(self: LiteralString) -> LiteralString: ...\n    @overload\n    def title(self) -> str: ...  # type: ignore[misc]\n    def translate(self, table: _TranslateTable, /) -> str: ...\n    @overload\n    def upper(self: LiteralString) -> LiteralString: ...\n    @overload\n    def upper(self) -> str: ...  # type: ignore[misc]\n    @overload\n    def zfill(self: LiteralString, width: SupportsIndex, /) -> LiteralString: ...\n    @overload\n    def zfill(self, width: SupportsIndex, /) -> str: ...  # type: ignore[misc]\n    @staticmethod\n    @overload\n    def maketrans(x: dict[int, _T] | dict[str, _T] | dict[str | int, _T], /) -> dict[int, _T]: ...\n    @staticmethod\n    @overload\n    def maketrans(x: str, y: str, /) -> dict[int, int]: ...\n    @staticmethod\n    @overload\n    def maketrans(x: str, y: str, z: str, /) -> dict[int, int | None]: ...\n    @overload\n    def __add__(self: LiteralString, value: LiteralString, /) -> LiteralString: ...\n    @overload\n    def __add__(self, value: str, /) -> str: ...  # type: ignore[misc]\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, key: str, /) -> bool: ...  # type: ignore[override]\n    def __eq__(self, value: object, /) -> bool: ...\n    def __ge__(self, value: str, /) -> bool: ...\n    @overload\n    def __getitem__(self: LiteralString, key: SupportsIndex | slice, /) -> LiteralString: ...\n    @overload\n    def __getitem__(self, key: SupportsIndex | slice, /) -> str: ...  # type: ignore[misc]\n    def __gt__(self, value: str, /) -> bool: ...\n    def __hash__(self) -> int: ...\n    @overload\n    def __iter__(self: LiteralString) -> Iterator[LiteralString]: ...\n    @overload\n    def __iter__(self) -> Iterator[str]: ...  # type: ignore[misc]\n    def __le__(self, value: str, /) -> bool: ...\n    def __len__(self) -> int: ...\n    def __lt__(self, value: str, /) -> bool: ...\n    @overload\n    def __mod__(self: LiteralString, value: LiteralString | tuple[LiteralString, ...], /) -> LiteralString: ...\n    @overload\n    def __mod__(self, value: Any, /) -> str: ...\n    @overload\n    def __mul__(self: LiteralString, value: SupportsIndex, /) -> LiteralString: ...\n    @overload\n    def __mul__(self, value: SupportsIndex, /) -> str: ...  # type: ignore[misc]\n    def __ne__(self, value: object, /) -> bool: ...\n    @overload\n    def __rmul__(self: LiteralString, value: SupportsIndex, /) -> LiteralString: ...\n    @overload\n    def __rmul__(self, value: SupportsIndex, /) -> str: ...  # type: ignore[misc]\n    def __getnewargs__(self) -> tuple[str]: ...\n    def __format__(self, format_spec: str, /) -> str: ...\n\n@disjoint_base\nclass bytes(Sequence[int]):\n    @overload\n    def __new__(cls, o: Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | ReadableBuffer, /) -> Self: ...\n    @overload\n    def __new__(cls, string: str, /, encoding: str, errors: str = \"strict\") -> Self: ...\n    @overload\n    def __new__(cls) -> Self: ...\n    def capitalize(self) -> bytes: ...\n    def center(self, width: SupportsIndex, fillchar: bytes = b\" \", /) -> bytes: ...\n    def count(\n        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /\n    ) -> int: ...\n    def decode(self, encoding: str = \"utf-8\", errors: str = \"strict\") -> str: ...\n    def endswith(\n        self,\n        suffix: ReadableBuffer | tuple[ReadableBuffer, ...],\n        start: SupportsIndex | None = None,\n        end: SupportsIndex | None = None,\n        /,\n    ) -> bool: ...\n    def expandtabs(self, tabsize: SupportsIndex = 8) -> bytes: ...\n    def find(\n        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /\n    ) -> int: ...\n    def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = 1) -> str: ...\n    def index(\n        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /\n    ) -> int: ...\n    def isalnum(self) -> bool: ...\n    def isalpha(self) -> bool: ...\n    def isascii(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, iterable_of_bytes: Iterable[ReadableBuffer], /) -> bytes: ...\n    def ljust(self, width: SupportsIndex, fillchar: bytes | bytearray = b\" \", /) -> bytes: ...\n    def lower(self) -> bytes: ...\n    def lstrip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...\n    def partition(self, sep: ReadableBuffer, /) -> tuple[bytes, bytes, bytes]: ...\n    def replace(self, old: ReadableBuffer, new: ReadableBuffer, count: SupportsIndex = -1, /) -> bytes: ...\n    def removeprefix(self, prefix: ReadableBuffer, /) -> bytes: ...\n    def removesuffix(self, suffix: ReadableBuffer, /) -> bytes: ...\n    def rfind(\n        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /\n    ) -> int: ...\n    def rindex(\n        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /\n    ) -> int: ...\n    def rjust(self, width: SupportsIndex, fillchar: bytes | bytearray = b\" \", /) -> bytes: ...\n    def rpartition(self, sep: ReadableBuffer, /) -> tuple[bytes, bytes, bytes]: ...\n    def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...\n    def rstrip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...\n    def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytes]: ...\n    def splitlines(self, keepends: bool = False) -> list[bytes]: ...\n    def startswith(\n        self,\n        prefix: ReadableBuffer | tuple[ReadableBuffer, ...],\n        start: SupportsIndex | None = None,\n        end: SupportsIndex | None = None,\n        /,\n    ) -> bool: ...\n    def strip(self, bytes: ReadableBuffer | None = None, /) -> bytes: ...\n    def swapcase(self) -> bytes: ...\n    def title(self) -> bytes: ...\n    def translate(self, table: ReadableBuffer | None, /, delete: ReadableBuffer = b\"\") -> bytes: ...\n    def upper(self) -> bytes: ...\n    def zfill(self, width: SupportsIndex, /) -> bytes: ...\n    if sys.version_info >= (3, 14):\n        @classmethod\n        def fromhex(cls, string: str | ReadableBuffer, /) -> Self: ...\n    else:\n        @classmethod\n        def fromhex(cls, string: str, /) -> Self: ...\n\n    @staticmethod\n    def maketrans(frm: ReadableBuffer, to: ReadableBuffer, /) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    def __hash__(self) -> int: ...\n    @overload\n    def __getitem__(self, key: SupportsIndex, /) -> int: ...\n    @overload\n    def __getitem__(self, key: slice, /) -> bytes: ...\n    def __add__(self, value: ReadableBuffer, /) -> bytes: ...\n    def __mul__(self, value: SupportsIndex, /) -> bytes: ...\n    def __rmul__(self, value: SupportsIndex, /) -> bytes: ...\n    def __mod__(self, value: Any, /) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, key: SupportsIndex | ReadableBuffer, /) -> bool: ...  # type: ignore[override]\n    def __eq__(self, value: object, /) -> bool: ...\n    def __ne__(self, value: object, /) -> bool: ...\n    def __lt__(self, value: bytes, /) -> bool: ...\n    def __le__(self, value: bytes, /) -> bool: ...\n    def __gt__(self, value: bytes, /) -> bool: ...\n    def __ge__(self, value: bytes, /) -> bool: ...\n    def __getnewargs__(self) -> tuple[bytes]: ...\n    if sys.version_info >= (3, 11):\n        def __bytes__(self) -> bytes: ...\n\n    def __buffer__(self, flags: int, /) -> memoryview: ...\n\n@disjoint_base\nclass bytearray(MutableSequence[int]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, ints: Iterable[SupportsIndex] | SupportsIndex | ReadableBuffer, /) -> None: ...\n    @overload\n    def __init__(self, string: str, /, encoding: str, errors: str = \"strict\") -> None: ...\n    def append(self, item: SupportsIndex, /) -> None: ...\n    def capitalize(self) -> bytearray: ...\n    def center(self, width: SupportsIndex, fillchar: bytes = b\" \", /) -> bytearray: ...\n    def count(\n        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /\n    ) -> int: ...\n    def copy(self) -> bytearray: ...\n    def decode(self, encoding: str = \"utf-8\", errors: str = \"strict\") -> str: ...\n    def endswith(\n        self,\n        suffix: ReadableBuffer | tuple[ReadableBuffer, ...],\n        start: SupportsIndex | None = None,\n        end: SupportsIndex | None = None,\n        /,\n    ) -> bool: ...\n    def expandtabs(self, tabsize: SupportsIndex = 8) -> bytearray: ...\n    def extend(self, iterable_of_ints: Iterable[SupportsIndex], /) -> None: ...\n    def find(\n        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /\n    ) -> int: ...\n    def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = 1) -> str: ...\n    def index(\n        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /\n    ) -> int: ...\n    def insert(self, index: SupportsIndex, item: SupportsIndex, /) -> None: ...\n    def isalnum(self) -> bool: ...\n    def isalpha(self) -> bool: ...\n    def isascii(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def join(self, iterable_of_bytes: Iterable[ReadableBuffer], /) -> bytearray: ...\n    def ljust(self, width: SupportsIndex, fillchar: bytes | bytearray = b\" \", /) -> bytearray: ...\n    def lower(self) -> bytearray: ...\n    def lstrip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...\n    def partition(self, sep: ReadableBuffer, /) -> tuple[bytearray, bytearray, bytearray]: ...\n    def pop(self, index: int = -1, /) -> int: ...\n    def remove(self, value: int, /) -> None: ...\n    def removeprefix(self, prefix: ReadableBuffer, /) -> bytearray: ...\n    def removesuffix(self, suffix: ReadableBuffer, /) -> bytearray: ...\n    def replace(self, old: ReadableBuffer, new: ReadableBuffer, count: SupportsIndex = -1, /) -> bytearray: ...\n    def rfind(\n        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /\n    ) -> int: ...\n    def rindex(\n        self, sub: ReadableBuffer | SupportsIndex, start: SupportsIndex | None = None, end: SupportsIndex | None = None, /\n    ) -> int: ...\n    def rjust(self, width: SupportsIndex, fillchar: bytes | bytearray = b\" \", /) -> bytearray: ...\n    def rpartition(self, sep: ReadableBuffer, /) -> tuple[bytearray, bytearray, bytearray]: ...\n    def rsplit(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytearray]: ...\n    def rstrip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...\n    def split(self, sep: ReadableBuffer | None = None, maxsplit: SupportsIndex = -1) -> list[bytearray]: ...\n    def splitlines(self, keepends: bool = False) -> list[bytearray]: ...\n    def startswith(\n        self,\n        prefix: ReadableBuffer | tuple[ReadableBuffer, ...],\n        start: SupportsIndex | None = None,\n        end: SupportsIndex | None = None,\n        /,\n    ) -> bool: ...\n    def strip(self, bytes: ReadableBuffer | None = None, /) -> bytearray: ...\n    def swapcase(self) -> bytearray: ...\n    def title(self) -> bytearray: ...\n    def translate(self, table: ReadableBuffer | None, /, delete: bytes = b\"\") -> bytearray: ...\n    def upper(self) -> bytearray: ...\n    def zfill(self, width: SupportsIndex, /) -> bytearray: ...\n    if sys.version_info >= (3, 14):\n        @classmethod\n        def fromhex(cls, string: str | ReadableBuffer, /) -> Self: ...\n    else:\n        @classmethod\n        def fromhex(cls, string: str, /) -> Self: ...\n\n    @staticmethod\n    def maketrans(frm: ReadableBuffer, to: ReadableBuffer, /) -> bytes: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[int]: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    @overload\n    def __getitem__(self, key: SupportsIndex, /) -> int: ...\n    @overload\n    def __getitem__(self, key: slice, /) -> bytearray: ...\n    @overload\n    def __setitem__(self, key: SupportsIndex, value: SupportsIndex, /) -> None: ...\n    @overload\n    def __setitem__(self, key: slice, value: Iterable[SupportsIndex] | bytes, /) -> None: ...\n    def __delitem__(self, key: SupportsIndex | slice, /) -> None: ...\n    def __add__(self, value: ReadableBuffer, /) -> bytearray: ...\n    # The superclass wants us to accept Iterable[int], but that fails at runtime.\n    def __iadd__(self, value: ReadableBuffer, /) -> Self: ...  # type: ignore[override]\n    def __mul__(self, value: SupportsIndex, /) -> bytearray: ...\n    def __rmul__(self, value: SupportsIndex, /) -> bytearray: ...\n    def __imul__(self, value: SupportsIndex, /) -> Self: ...\n    def __mod__(self, value: Any, /) -> bytes: ...\n    # Incompatible with Sequence.__contains__\n    def __contains__(self, key: SupportsIndex | ReadableBuffer, /) -> bool: ...  # type: ignore[override]\n    def __eq__(self, value: object, /) -> bool: ...\n    def __ne__(self, value: object, /) -> bool: ...\n    def __lt__(self, value: ReadableBuffer, /) -> bool: ...\n    def __le__(self, value: ReadableBuffer, /) -> bool: ...\n    def __gt__(self, value: ReadableBuffer, /) -> bool: ...\n    def __ge__(self, value: ReadableBuffer, /) -> bool: ...\n    def __alloc__(self) -> int: ...\n    def __buffer__(self, flags: int, /) -> memoryview: ...\n    def __release_buffer__(self, buffer: memoryview, /) -> None: ...\n    if sys.version_info >= (3, 14):\n        def resize(self, size: int, /) -> None: ...\n\n_IntegerFormats: TypeAlias = Literal[\n    \"b\", \"B\", \"@b\", \"@B\", \"h\", \"H\", \"@h\", \"@H\", \"i\", \"I\", \"@i\", \"@I\", \"l\", \"L\", \"@l\", \"@L\", \"q\", \"Q\", \"@q\", \"@Q\", \"P\", \"@P\"\n]\n\n@final\nclass memoryview(Sequence[_I]):\n    @property\n    def format(self) -> str: ...\n    @property\n    def itemsize(self) -> int: ...\n    @property\n    def shape(self) -> tuple[int, ...] | None: ...\n    @property\n    def strides(self) -> tuple[int, ...] | None: ...\n    @property\n    def suboffsets(self) -> tuple[int, ...] | None: ...\n    @property\n    def readonly(self) -> bool: ...\n    @property\n    def ndim(self) -> int: ...\n    @property\n    def obj(self) -> ReadableBuffer: ...\n    @property\n    def c_contiguous(self) -> bool: ...\n    @property\n    def f_contiguous(self) -> bool: ...\n    @property\n    def contiguous(self) -> bool: ...\n    @property\n    def nbytes(self) -> int: ...\n    def __new__(cls, obj: ReadableBuffer) -> Self: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,  # noqa: PYI036 # This is the module declaring BaseException\n        exc_val: BaseException | None,\n        exc_tb: TracebackType | None,\n        /,\n    ) -> None: ...\n    @overload\n    def cast(self, format: Literal[\"c\", \"@c\"], shape: list[int] | tuple[int, ...] = ...) -> memoryview[bytes]: ...\n    @overload\n    def cast(self, format: Literal[\"f\", \"@f\", \"d\", \"@d\"], shape: list[int] | tuple[int, ...] = ...) -> memoryview[float]: ...\n    @overload\n    def cast(self, format: Literal[\"?\"], shape: list[int] | tuple[int, ...] = ...) -> memoryview[bool]: ...\n    @overload\n    def cast(self, format: _IntegerFormats, shape: list[int] | tuple[int, ...] = ...) -> memoryview: ...\n    @overload\n    def __getitem__(self, key: SupportsIndex | tuple[SupportsIndex, ...], /) -> _I: ...\n    @overload\n    def __getitem__(self, key: slice, /) -> memoryview[_I]: ...\n    def __contains__(self, x: object, /) -> bool: ...\n    def __iter__(self) -> Iterator[_I]: ...\n    def __len__(self) -> int: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n    @overload\n    def __setitem__(self, key: slice, value: ReadableBuffer, /) -> None: ...\n    @overload\n    def __setitem__(self, key: SupportsIndex | tuple[SupportsIndex, ...], value: _I, /) -> None: ...\n    if sys.version_info >= (3, 10):\n        def tobytes(self, order: Literal[\"C\", \"F\", \"A\"] | None = \"C\") -> bytes: ...\n    else:\n        def tobytes(self, order: Literal[\"C\", \"F\", \"A\"] | None = None) -> bytes: ...\n\n    def tolist(self) -> list[int]: ...\n    def toreadonly(self) -> memoryview: ...\n    def release(self) -> None: ...\n    def hex(self, sep: str | bytes = ..., bytes_per_sep: SupportsIndex = 1) -> str: ...\n    def __buffer__(self, flags: int, /) -> memoryview: ...\n    def __release_buffer__(self, buffer: memoryview, /) -> None: ...\n    if sys.version_info >= (3, 14):\n        def index(self, value: object, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...\n        def count(self, value: object, /) -> int: ...\n    else:\n        # These are inherited from the Sequence ABC, but don't actually exist on memoryview.\n        # See https://github.com/python/cpython/issues/125420\n        index: ClassVar[None]  # type: ignore[assignment]\n        count: ClassVar[None]  # type: ignore[assignment]\n\n    if sys.version_info >= (3, 14):\n        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n@final\nclass bool(int):\n    def __new__(cls, o: object = False, /) -> Self: ...\n    # The following overloads could be represented more elegantly with a TypeVar(\"_B\", bool, int),\n    # however mypy has a bug regarding TypeVar constraints (https://github.com/python/mypy/issues/11880).\n    @overload\n    def __and__(self, value: bool, /) -> bool: ...\n    @overload\n    def __and__(self, value: int, /) -> int: ...\n    @overload\n    def __or__(self, value: bool, /) -> bool: ...\n    @overload\n    def __or__(self, value: int, /) -> int: ...\n    @overload\n    def __xor__(self, value: bool, /) -> bool: ...\n    @overload\n    def __xor__(self, value: int, /) -> int: ...\n    @overload\n    def __rand__(self, value: bool, /) -> bool: ...\n    @overload\n    def __rand__(self, value: int, /) -> int: ...\n    @overload\n    def __ror__(self, value: bool, /) -> bool: ...\n    @overload\n    def __ror__(self, value: int, /) -> int: ...\n    @overload\n    def __rxor__(self, value: bool, /) -> bool: ...\n    @overload\n    def __rxor__(self, value: int, /) -> int: ...\n    def __getnewargs__(self) -> tuple[int]: ...\n    @deprecated(\"Will throw an error in Python 3.16. Use `not` for logical negation of bools instead.\")\n    def __invert__(self) -> int: ...\n\n@final\nclass slice(Generic[_StartT_co, _StopT_co, _StepT_co]):\n    @property\n    def start(self) -> _StartT_co: ...\n    @property\n    def step(self) -> _StepT_co: ...\n    @property\n    def stop(self) -> _StopT_co: ...\n    # Note: __new__ overloads map `None` to `Any`, since users expect slice(x, None)\n    #  to be compatible with slice(None, x).\n    # generic slice --------------------------------------------------------------------\n    @overload\n    def __new__(cls, start: None, stop: None = None, step: None = None, /) -> slice[Any, Any, Any]: ...\n    # unary overloads ------------------------------------------------------------------\n    @overload\n    def __new__(cls, stop: _T2, /) -> slice[Any, _T2, Any]: ...\n    # binary overloads -----------------------------------------------------------------\n    @overload\n    def __new__(cls, start: _T1, stop: None, step: None = None, /) -> slice[_T1, Any, Any]: ...\n    @overload\n    def __new__(cls, start: None, stop: _T2, step: None = None, /) -> slice[Any, _T2, Any]: ...\n    @overload\n    def __new__(cls, start: _T1, stop: _T2, step: None = None, /) -> slice[_T1, _T2, Any]: ...\n    # ternary overloads ----------------------------------------------------------------\n    @overload\n    def __new__(cls, start: None, stop: None, step: _T3, /) -> slice[Any, Any, _T3]: ...\n    @overload\n    def __new__(cls, start: _T1, stop: None, step: _T3, /) -> slice[_T1, Any, _T3]: ...\n    @overload\n    def __new__(cls, start: None, stop: _T2, step: _T3, /) -> slice[Any, _T2, _T3]: ...\n    @overload\n    def __new__(cls, start: _T1, stop: _T2, step: _T3, /) -> slice[_T1, _T2, _T3]: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    if sys.version_info >= (3, 12):\n        def __hash__(self) -> int: ...\n    else:\n        __hash__: ClassVar[None]  # type: ignore[assignment]\n\n    def indices(self, len: SupportsIndex, /) -> tuple[int, int, int]: ...\n\n@disjoint_base\nclass tuple(Sequence[_T_co]):\n    def __new__(cls, iterable: Iterable[_T_co] = (), /) -> Self: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, key: object, /) -> bool: ...\n    @overload\n    def __getitem__(self, key: SupportsIndex, /) -> _T_co: ...\n    @overload\n    def __getitem__(self, key: slice, /) -> tuple[_T_co, ...]: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __lt__(self, value: tuple[_T_co, ...], /) -> bool: ...\n    def __le__(self, value: tuple[_T_co, ...], /) -> bool: ...\n    def __gt__(self, value: tuple[_T_co, ...], /) -> bool: ...\n    def __ge__(self, value: tuple[_T_co, ...], /) -> bool: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n    @overload\n    def __add__(self, value: tuple[_T_co, ...], /) -> tuple[_T_co, ...]: ...\n    @overload\n    def __add__(self, value: tuple[_T, ...], /) -> tuple[_T_co | _T, ...]: ...\n    def __mul__(self, value: SupportsIndex, /) -> tuple[_T_co, ...]: ...\n    def __rmul__(self, value: SupportsIndex, /) -> tuple[_T_co, ...]: ...\n    def count(self, value: Any, /) -> int: ...\n    def index(self, value: Any, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n# Doesn't exist at runtime, but deleting this breaks mypy and pyright. See:\n# https://github.com/python/typeshed/issues/7580\n# https://github.com/python/mypy/issues/8240\n# Obsolete, use types.FunctionType instead.\n@final\n@type_check_only\nclass function:\n    # Make sure this class definition stays roughly in line with `types.FunctionType`\n    @property\n    def __closure__(self) -> tuple[CellType, ...] | None: ...\n    __code__: CodeType\n    __defaults__: tuple[Any, ...] | None\n    __dict__: dict[str, Any]\n    @property\n    def __globals__(self) -> dict[str, Any]: ...\n    __name__: str\n    __qualname__: str\n    __annotations__: dict[str, AnnotationForm]\n    if sys.version_info >= (3, 14):\n        __annotate__: AnnotateFunc | None\n    __kwdefaults__: dict[str, Any] | None\n    if sys.version_info >= (3, 10):\n        @property\n        def __builtins__(self) -> dict[str, Any]: ...\n    if sys.version_info >= (3, 12):\n        __type_params__: tuple[TypeVar | ParamSpec | TypeVarTuple, ...]\n\n    __module__: str\n    if sys.version_info >= (3, 13):\n        def __new__(\n            cls,\n            code: CodeType,\n            globals: dict[str, Any],\n            name: str | None = None,\n            argdefs: tuple[object, ...] | None = None,\n            closure: tuple[CellType, ...] | None = None,\n            kwdefaults: dict[str, object] | None = None,\n        ) -> Self: ...\n    else:\n        def __new__(\n            cls,\n            code: CodeType,\n            globals: dict[str, Any],\n            name: str | None = None,\n            argdefs: tuple[object, ...] | None = None,\n            closure: tuple[CellType, ...] | None = None,\n        ) -> Self: ...\n\n    # mypy uses `builtins.function.__get__` to represent methods, properties, and getset_descriptors so we type the return as Any.\n    def __get__(self, instance: object, owner: type | None = None, /) -> Any: ...\n\n@disjoint_base\nclass list(MutableSequence[_T]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T], /) -> None: ...\n    def copy(self) -> list[_T]: ...\n    def append(self, object: _T, /) -> None: ...\n    def extend(self, iterable: Iterable[_T], /) -> None: ...\n    def pop(self, index: SupportsIndex = -1, /) -> _T: ...\n    # Signature of `list.index` should be kept in line with `collections.UserList.index()`\n    # and multiprocessing.managers.ListProxy.index()\n    def index(self, value: _T, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...\n    def count(self, value: _T, /) -> int: ...\n    def insert(self, index: SupportsIndex, object: _T, /) -> None: ...\n    def remove(self, value: _T, /) -> None: ...\n    # Signature of `list.sort` should be kept inline with `collections.UserList.sort()`\n    # and multiprocessing.managers.ListProxy.sort()\n    #\n    # Use list[SupportsRichComparisonT] for the first overload rather than [SupportsRichComparison]\n    # to work around invariance\n    @overload\n    def sort(self: list[SupportsRichComparisonT], *, key: None = None, reverse: bool = False) -> None: ...\n    @overload\n    def sort(self, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> None: ...\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    @overload\n    def __getitem__(self, i: SupportsIndex, /) -> _T: ...\n    @overload\n    def __getitem__(self, s: slice, /) -> list[_T]: ...\n    @overload\n    def __setitem__(self, key: SupportsIndex, value: _T, /) -> None: ...\n    @overload\n    def __setitem__(self, key: slice, value: Iterable[_T], /) -> None: ...\n    def __delitem__(self, key: SupportsIndex | slice, /) -> None: ...\n    # Overloading looks unnecessary, but is needed to work around complex mypy problems\n    @overload\n    def __add__(self, value: list[_T], /) -> list[_T]: ...\n    @overload\n    def __add__(self, value: list[_S], /) -> list[_S | _T]: ...\n    def __iadd__(self, value: Iterable[_T], /) -> Self: ...  # type: ignore[misc]\n    def __mul__(self, value: SupportsIndex, /) -> list[_T]: ...\n    def __rmul__(self, value: SupportsIndex, /) -> list[_T]: ...\n    def __imul__(self, value: SupportsIndex, /) -> Self: ...\n    def __contains__(self, key: object, /) -> bool: ...\n    def __reversed__(self) -> Iterator[_T]: ...\n    def __gt__(self, value: list[_T], /) -> bool: ...\n    def __ge__(self, value: list[_T], /) -> bool: ...\n    def __lt__(self, value: list[_T], /) -> bool: ...\n    def __le__(self, value: list[_T], /) -> bool: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n@disjoint_base\nclass dict(MutableMapping[_KT, _VT]):\n    # __init__ should be kept roughly in line with `collections.UserDict.__init__`, which has similar semantics\n    # Also multiprocessing.managers.SyncManager.dict()\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self: dict[str, _VT], **kwargs: _VT) -> None: ...  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n    @overload\n    def __init__(self, map: SupportsKeysAndGetItem[_KT, _VT], /) -> None: ...\n    @overload\n    def __init__(\n        self: dict[str, _VT],  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n        map: SupportsKeysAndGetItem[str, _VT],\n        /,\n        **kwargs: _VT,\n    ) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[tuple[_KT, _VT]], /) -> None: ...\n    @overload\n    def __init__(\n        self: dict[str, _VT],  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n        iterable: Iterable[tuple[str, _VT]],\n        /,\n        **kwargs: _VT,\n    ) -> None: ...\n    # Next two overloads are for dict(string.split(sep) for string in iterable)\n    # Cannot be Iterable[Sequence[_T]] or otherwise dict([\"foo\", \"bar\", \"baz\"]) is not an error\n    @overload\n    def __init__(self: dict[str, str], iterable: Iterable[list[str]], /) -> None: ...\n    @overload\n    def __init__(self: dict[bytes, bytes], iterable: Iterable[list[bytes]], /) -> None: ...\n    def __new__(cls, *args: Any, **kwargs: Any) -> Self: ...\n    def copy(self) -> dict[_KT, _VT]: ...\n    def keys(self) -> dict_keys[_KT, _VT]: ...\n    def values(self) -> dict_values[_KT, _VT]: ...\n    def items(self) -> dict_items[_KT, _VT]: ...\n    # Signature of `dict.fromkeys` should be kept identical to\n    # `fromkeys` methods of `OrderedDict`/`ChainMap`/`UserDict` in `collections`\n    # TODO: the true signature of `dict.fromkeys` is not expressible in the current type system.\n    # See #3800 & https://github.com/python/typing/issues/548#issuecomment-683336963.\n    @classmethod\n    @overload\n    def fromkeys(cls, iterable: Iterable[_T], value: None = None, /) -> dict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, iterable: Iterable[_T], value: _S, /) -> dict[_T, _S]: ...\n    # Positional-only in dict, but not in MutableMapping\n    @overload  # type: ignore[override]\n    def get(self, key: _KT, default: None = None, /) -> _VT | None: ...\n    @overload\n    def get(self, key: _KT, default: _VT, /) -> _VT: ...\n    @overload\n    def get(self, key: _KT, default: _T, /) -> _VT | _T: ...\n    @overload\n    def pop(self, key: _KT, /) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _VT, /) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _T, /) -> _VT | _T: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, key: _KT, /) -> _VT: ...\n    def __setitem__(self, key: _KT, value: _VT, /) -> None: ...\n    def __delitem__(self, key: _KT, /) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __reversed__(self) -> Iterator[_KT]: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n    @overload\n    def __or__(self, value: dict[_KT, _VT], /) -> dict[_KT, _VT]: ...\n    @overload\n    def __or__(self, value: dict[_T1, _T2], /) -> dict[_KT | _T1, _VT | _T2]: ...\n    @overload\n    def __ror__(self, value: dict[_KT, _VT], /) -> dict[_KT, _VT]: ...\n    @overload\n    def __ror__(self, value: dict[_T1, _T2], /) -> dict[_KT | _T1, _VT | _T2]: ...\n    # dict.__ior__ should be kept roughly in line with MutableMapping.update()\n    @overload  # type: ignore[misc]\n    def __ior__(self, value: SupportsKeysAndGetItem[_KT, _VT], /) -> Self: ...\n    @overload\n    def __ior__(self, value: Iterable[tuple[_KT, _VT]], /) -> Self: ...\n\n@disjoint_base\nclass set(MutableSet[_T]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T], /) -> None: ...\n    def add(self, element: _T, /) -> None: ...\n    def copy(self) -> set[_T]: ...\n    def difference(self, *s: Iterable[Any]) -> set[_T]: ...\n    def difference_update(self, *s: Iterable[Any]) -> None: ...\n    def discard(self, element: _T, /) -> None: ...\n    def intersection(self, *s: Iterable[Any]) -> set[_T]: ...\n    def intersection_update(self, *s: Iterable[Any]) -> None: ...\n    def isdisjoint(self, s: Iterable[Any], /) -> bool: ...\n    def issubset(self, s: Iterable[Any], /) -> bool: ...\n    def issuperset(self, s: Iterable[Any], /) -> bool: ...\n    def remove(self, element: _T, /) -> None: ...\n    def symmetric_difference(self, s: Iterable[_T], /) -> set[_T]: ...\n    def symmetric_difference_update(self, s: Iterable[_T], /) -> None: ...\n    def union(self, *s: Iterable[_S]) -> set[_T | _S]: ...\n    def update(self, *s: Iterable[_T]) -> None: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object, /) -> bool: ...\n    def __iter__(self) -> Iterator[_T]: ...\n    def __and__(self, value: AbstractSet[object], /) -> set[_T]: ...\n    def __iand__(self, value: AbstractSet[object], /) -> Self: ...\n    def __or__(self, value: AbstractSet[_S], /) -> set[_T | _S]: ...\n    def __ior__(self, value: AbstractSet[_T], /) -> Self: ...  # type: ignore[override,misc]\n    def __sub__(self, value: AbstractSet[_T | None], /) -> set[_T]: ...\n    def __isub__(self, value: AbstractSet[object], /) -> Self: ...\n    def __xor__(self, value: AbstractSet[_S], /) -> set[_T | _S]: ...\n    def __ixor__(self, value: AbstractSet[_T], /) -> Self: ...  # type: ignore[override,misc]\n    def __le__(self, value: AbstractSet[object], /) -> bool: ...\n    def __lt__(self, value: AbstractSet[object], /) -> bool: ...\n    def __ge__(self, value: AbstractSet[object], /) -> bool: ...\n    def __gt__(self, value: AbstractSet[object], /) -> bool: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n@disjoint_base\nclass frozenset(AbstractSet[_T_co]):\n    @overload\n    def __new__(cls) -> Self: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T_co], /) -> Self: ...\n    def copy(self) -> frozenset[_T_co]: ...\n    def difference(self, *s: Iterable[object]) -> frozenset[_T_co]: ...\n    def intersection(self, *s: Iterable[object]) -> frozenset[_T_co]: ...\n    def isdisjoint(self, s: Iterable[_T_co], /) -> bool: ...\n    def issubset(self, s: Iterable[object], /) -> bool: ...\n    def issuperset(self, s: Iterable[object], /) -> bool: ...\n    def symmetric_difference(self, s: Iterable[_T_co], /) -> frozenset[_T_co]: ...\n    def union(self, *s: Iterable[_S]) -> frozenset[_T_co | _S]: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, o: object, /) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __and__(self, value: AbstractSet[_T_co], /) -> frozenset[_T_co]: ...\n    def __or__(self, value: AbstractSet[_S], /) -> frozenset[_T_co | _S]: ...\n    def __sub__(self, value: AbstractSet[_T_co], /) -> frozenset[_T_co]: ...\n    def __xor__(self, value: AbstractSet[_S], /) -> frozenset[_T_co | _S]: ...\n    def __le__(self, value: AbstractSet[object], /) -> bool: ...\n    def __lt__(self, value: AbstractSet[object], /) -> bool: ...\n    def __ge__(self, value: AbstractSet[object], /) -> bool: ...\n    def __gt__(self, value: AbstractSet[object], /) -> bool: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n@disjoint_base\nclass enumerate(Generic[_T]):\n    def __new__(cls, iterable: Iterable[_T], start: int = 0) -> Self: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> tuple[int, _T]: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n@final\nclass range(Sequence[int]):\n    @property\n    def start(self) -> int: ...\n    @property\n    def stop(self) -> int: ...\n    @property\n    def step(self) -> int: ...\n    @overload\n    def __new__(cls, stop: SupportsIndex, /) -> Self: ...\n    @overload\n    def __new__(cls, start: SupportsIndex, stop: SupportsIndex, step: SupportsIndex = 1, /) -> Self: ...\n    def count(self, value: int, /) -> int: ...\n    def index(self, value: int, /) -> int: ...  # type: ignore[override]\n    def __len__(self) -> int: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __contains__(self, key: object, /) -> bool: ...\n    def __iter__(self) -> Iterator[int]: ...\n    @overload\n    def __getitem__(self, key: SupportsIndex, /) -> int: ...\n    @overload\n    def __getitem__(self, key: slice, /) -> range: ...\n    def __reversed__(self) -> Iterator[int]: ...\n\n@disjoint_base\nclass property:\n    fget: Callable[[Any], Any] | None\n    fset: Callable[[Any, Any], None] | None\n    fdel: Callable[[Any], None] | None\n    __isabstractmethod__: bool\n    if sys.version_info >= (3, 13):\n        __name__: str\n\n    def __init__(\n        self,\n        fget: Callable[[Any], Any] | None = None,\n        fset: Callable[[Any, Any], None] | None = None,\n        fdel: Callable[[Any], None] | None = None,\n        doc: str | None = None,\n    ) -> None: ...\n    def getter(self, fget: Callable[[Any], Any], /) -> property: ...\n    def setter(self, fset: Callable[[Any, Any], None], /) -> property: ...\n    def deleter(self, fdel: Callable[[Any], None], /) -> property: ...\n    @overload\n    def __get__(self, instance: None, owner: type, /) -> Self: ...\n    @overload\n    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...\n    def __set__(self, instance: Any, value: Any, /) -> None: ...\n    def __delete__(self, instance: Any, /) -> None: ...\n\ndef abs(x: SupportsAbs[_T], /) -> _T: ...\ndef all(iterable: Iterable[object], /) -> bool: ...\ndef any(iterable: Iterable[object], /) -> bool: ...\ndef ascii(obj: object, /) -> str: ...\ndef bin(number: int | SupportsIndex, /) -> str: ...\ndef breakpoint(*args: Any, **kws: Any) -> None: ...\ndef callable(obj: object, /) -> TypeIs[Callable[..., object]]: ...\ndef chr(i: int | SupportsIndex, /) -> str: ...\n\nif sys.version_info >= (3, 10):\n    def aiter(async_iterable: SupportsAiter[_SupportsAnextT_co], /) -> _SupportsAnextT_co: ...\n    @type_check_only\n    class _SupportsSynchronousAnext(Protocol[_AwaitableT_co]):\n        def __anext__(self) -> _AwaitableT_co: ...\n\n    @overload\n    # `anext` is not, in fact, an async function. When default is not provided\n    # `anext` is just a passthrough for `obj.__anext__`\n    # See discussion in #7491 and pure-Python implementation of `anext` at https://github.com/python/cpython/blob/ea786a882b9ed4261eafabad6011bc7ef3b5bf94/Lib/test/test_asyncgen.py#L52-L80\n    def anext(i: _SupportsSynchronousAnext[_AwaitableT], /) -> _AwaitableT: ...\n    @overload\n    async def anext(i: SupportsAnext[_T], default: _VT, /) -> _T | _VT: ...\n\n# compile() returns a CodeType, unless the flags argument includes PyCF_ONLY_AST (=1024),\n# in which case it returns ast.AST. We have overloads for flag 0 (the default) and for\n# explicitly passing PyCF_ONLY_AST. We fall back to Any for other values of flags.\n@overload\ndef compile(\n    source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,\n    filename: str | bytes | PathLike[Any],\n    mode: str,\n    flags: Literal[0],\n    dont_inherit: bool = False,\n    optimize: int = -1,\n    *,\n    _feature_version: int = -1,\n) -> CodeType: ...\n@overload\ndef compile(\n    source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,\n    filename: str | bytes | PathLike[Any],\n    mode: str,\n    *,\n    dont_inherit: bool = False,\n    optimize: int = -1,\n    _feature_version: int = -1,\n) -> CodeType: ...\n@overload\ndef compile(\n    source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,\n    filename: str | bytes | PathLike[Any],\n    mode: str,\n    flags: Literal[1024],\n    dont_inherit: bool = False,\n    optimize: int = -1,\n    *,\n    _feature_version: int = -1,\n) -> _ast.AST: ...\n@overload\ndef compile(\n    source: str | ReadableBuffer | _ast.Module | _ast.Expression | _ast.Interactive,\n    filename: str | bytes | PathLike[Any],\n    mode: str,\n    flags: int,\n    dont_inherit: bool = False,\n    optimize: int = -1,\n    *,\n    _feature_version: int = -1,\n) -> Any: ...\n\ncopyright: _sitebuiltins._Printer\ncredits: _sitebuiltins._Printer\n\ndef delattr(obj: object, name: str, /) -> None: ...\ndef dir(o: object = ..., /) -> list[str]: ...\n@overload\ndef divmod(x: SupportsDivMod[_T_contra, _T_co], y: _T_contra, /) -> _T_co: ...\n@overload\ndef divmod(x: _T_contra, y: SupportsRDivMod[_T_contra, _T_co], /) -> _T_co: ...\n\n# The `globals` argument to `eval` has to be `dict[str, Any]` rather than `dict[str, object]` due to invariance.\n# (The `globals` argument has to be a \"real dict\", rather than any old mapping, unlike the `locals` argument.)\nif sys.version_info >= (3, 13):\n    def eval(\n        source: str | ReadableBuffer | CodeType,\n        /,\n        globals: dict[str, Any] | None = None,\n        locals: Mapping[str, object] | None = None,\n    ) -> Any: ...\n\nelse:\n    def eval(\n        source: str | ReadableBuffer | CodeType,\n        globals: dict[str, Any] | None = None,\n        locals: Mapping[str, object] | None = None,\n        /,\n    ) -> Any: ...\n\n# Comment above regarding `eval` applies to `exec` as well\nif sys.version_info >= (3, 13):\n    def exec(\n        source: str | ReadableBuffer | CodeType,\n        /,\n        globals: dict[str, Any] | None = None,\n        locals: Mapping[str, object] | None = None,\n        *,\n        closure: tuple[CellType, ...] | None = None,\n    ) -> None: ...\n\nelif sys.version_info >= (3, 11):\n    def exec(\n        source: str | ReadableBuffer | CodeType,\n        globals: dict[str, Any] | None = None,\n        locals: Mapping[str, object] | None = None,\n        /,\n        *,\n        closure: tuple[CellType, ...] | None = None,\n    ) -> None: ...\n\nelse:\n    def exec(\n        source: str | ReadableBuffer | CodeType,\n        globals: dict[str, Any] | None = None,\n        locals: Mapping[str, object] | None = None,\n        /,\n    ) -> None: ...\n\nexit: _sitebuiltins.Quitter\n\n@disjoint_base\nclass filter(Generic[_T]):\n    @overload\n    def __new__(cls, function: None, iterable: Iterable[_T | None], /) -> Self: ...\n    @overload\n    def __new__(cls, function: Callable[[_S], TypeGuard[_T]], iterable: Iterable[_S], /) -> Self: ...\n    @overload\n    def __new__(cls, function: Callable[[_S], TypeIs[_T]], iterable: Iterable[_S], /) -> Self: ...\n    @overload\n    def __new__(cls, function: Callable[[_T], Any], iterable: Iterable[_T], /) -> Self: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\ndef format(value: object, format_spec: str = \"\", /) -> str: ...\n@overload\ndef getattr(o: object, name: str, /) -> Any: ...\n\n# While technically covered by the last overload, spelling out the types for None, bool\n# and basic containers help mypy out in some tricky situations involving type context\n# (aka bidirectional inference)\n@overload\ndef getattr(o: object, name: str, default: None, /) -> Any | None: ...\n@overload\ndef getattr(o: object, name: str, default: bool, /) -> Any | bool: ...\n@overload\ndef getattr(o: object, name: str, default: list[Any], /) -> Any | list[Any]: ...\n@overload\ndef getattr(o: object, name: str, default: dict[Any, Any], /) -> Any | dict[Any, Any]: ...\n@overload\ndef getattr(o: object, name: str, default: _T, /) -> Any | _T: ...\ndef globals() -> dict[str, Any]: ...\ndef hasattr(obj: object, name: str, /) -> bool: ...\ndef hash(obj: object, /) -> int: ...\n\nhelp: _sitebuiltins._Helper\n\ndef hex(number: int | SupportsIndex, /) -> str: ...\ndef id(obj: object, /) -> int: ...\ndef input(prompt: object = \"\", /) -> str: ...\n@type_check_only\nclass _GetItemIterable(Protocol[_T_co]):\n    def __getitem__(self, i: int, /) -> _T_co: ...\n\n@overload\ndef iter(object: SupportsIter[_SupportsNextT_co], /) -> _SupportsNextT_co: ...\n@overload\ndef iter(object: _GetItemIterable[_T], /) -> Iterator[_T]: ...\n@overload\ndef iter(object: Callable[[], _T | None], sentinel: None, /) -> Iterator[_T]: ...\n@overload\ndef iter(object: Callable[[], _T], sentinel: object, /) -> Iterator[_T]: ...\n\nif sys.version_info >= (3, 10):\n    _ClassInfo: TypeAlias = type | types.UnionType | tuple[_ClassInfo, ...]\nelse:\n    _ClassInfo: TypeAlias = type | tuple[_ClassInfo, ...]\n\ndef isinstance(obj: object, class_or_tuple: _ClassInfo, /) -> bool: ...\ndef issubclass(cls: type, class_or_tuple: _ClassInfo, /) -> bool: ...\ndef len(obj: Sized, /) -> int: ...\n\nlicense: _sitebuiltins._Printer\n\ndef locals() -> dict[str, Any]: ...\n@disjoint_base\nclass map(Generic[_S]):\n    # 3.14 adds `strict` argument.\n    if sys.version_info >= (3, 14):\n        @overload\n        def __new__(cls, func: Callable[[_T1], _S], iterable: Iterable[_T1], /, *, strict: bool = False) -> Self: ...\n        @overload\n        def __new__(\n            cls, func: Callable[[_T1, _T2], _S], iterable: Iterable[_T1], iter2: Iterable[_T2], /, *, strict: bool = False\n        ) -> Self: ...\n        @overload\n        def __new__(\n            cls,\n            func: Callable[[_T1, _T2, _T3], _S],\n            iterable: Iterable[_T1],\n            iter2: Iterable[_T2],\n            iter3: Iterable[_T3],\n            /,\n            *,\n            strict: bool = False,\n        ) -> Self: ...\n        @overload\n        def __new__(\n            cls,\n            func: Callable[[_T1, _T2, _T3, _T4], _S],\n            iterable: Iterable[_T1],\n            iter2: Iterable[_T2],\n            iter3: Iterable[_T3],\n            iter4: Iterable[_T4],\n            /,\n            *,\n            strict: bool = False,\n        ) -> Self: ...\n        @overload\n        def __new__(\n            cls,\n            func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],\n            iterable: Iterable[_T1],\n            iter2: Iterable[_T2],\n            iter3: Iterable[_T3],\n            iter4: Iterable[_T4],\n            iter5: Iterable[_T5],\n            /,\n            *,\n            strict: bool = False,\n        ) -> Self: ...\n        @overload\n        def __new__(\n            cls,\n            func: Callable[..., _S],\n            iterable: Iterable[Any],\n            iter2: Iterable[Any],\n            iter3: Iterable[Any],\n            iter4: Iterable[Any],\n            iter5: Iterable[Any],\n            iter6: Iterable[Any],\n            /,\n            *iterables: Iterable[Any],\n            strict: bool = False,\n        ) -> Self: ...\n    else:\n        @overload\n        def __new__(cls, func: Callable[[_T1], _S], iterable: Iterable[_T1], /) -> Self: ...\n        @overload\n        def __new__(cls, func: Callable[[_T1, _T2], _S], iterable: Iterable[_T1], iter2: Iterable[_T2], /) -> Self: ...\n        @overload\n        def __new__(\n            cls, func: Callable[[_T1, _T2, _T3], _S], iterable: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /\n        ) -> Self: ...\n        @overload\n        def __new__(\n            cls,\n            func: Callable[[_T1, _T2, _T3, _T4], _S],\n            iterable: Iterable[_T1],\n            iter2: Iterable[_T2],\n            iter3: Iterable[_T3],\n            iter4: Iterable[_T4],\n            /,\n        ) -> Self: ...\n        @overload\n        def __new__(\n            cls,\n            func: Callable[[_T1, _T2, _T3, _T4, _T5], _S],\n            iterable: Iterable[_T1],\n            iter2: Iterable[_T2],\n            iter3: Iterable[_T3],\n            iter4: Iterable[_T4],\n            iter5: Iterable[_T5],\n            /,\n        ) -> Self: ...\n        @overload\n        def __new__(\n            cls,\n            func: Callable[..., _S],\n            iterable: Iterable[Any],\n            iter2: Iterable[Any],\n            iter3: Iterable[Any],\n            iter4: Iterable[Any],\n            iter5: Iterable[Any],\n            iter6: Iterable[Any],\n            /,\n            *iterables: Iterable[Any],\n        ) -> Self: ...\n\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _S: ...\n\n@overload\ndef max(\n    arg1: SupportsRichComparisonT, arg2: SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = None\n) -> SupportsRichComparisonT: ...\n@overload\ndef max(arg1: _T, arg2: _T, /, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...\n@overload\ndef max(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None) -> SupportsRichComparisonT: ...\n@overload\ndef max(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...\n@overload\ndef max(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...\n@overload\ndef max(iterable: Iterable[_T1], /, *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...\n@overload\ndef min(\n    arg1: SupportsRichComparisonT, arg2: SupportsRichComparisonT, /, *_args: SupportsRichComparisonT, key: None = None\n) -> SupportsRichComparisonT: ...\n@overload\ndef min(arg1: _T, arg2: _T, /, *_args: _T, key: Callable[[_T], SupportsRichComparison]) -> _T: ...\n@overload\ndef min(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None) -> SupportsRichComparisonT: ...\n@overload\ndef min(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison]) -> _T: ...\n@overload\ndef min(iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, default: _T) -> SupportsRichComparisonT | _T: ...\n@overload\ndef min(iterable: Iterable[_T1], /, *, key: Callable[[_T1], SupportsRichComparison], default: _T2) -> _T1 | _T2: ...\n@overload\ndef next(i: SupportsNext[_T], /) -> _T: ...\n@overload\ndef next(i: SupportsNext[_T], default: _VT, /) -> _T | _VT: ...\ndef oct(number: int | SupportsIndex, /) -> str: ...\n\n_Opener: TypeAlias = Callable[[str, int], int]\n\n# Text mode: always returns a TextIOWrapper\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: OpenTextMode = \"r\",\n    buffering: int = -1,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> TextIOWrapper: ...\n\n# Unbuffered binary mode: returns a FileIO\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: OpenBinaryMode,\n    buffering: Literal[0],\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> FileIO: ...\n\n# Buffering is on: return BufferedRandom, BufferedReader, or BufferedWriter\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: OpenBinaryModeUpdating,\n    buffering: Literal[-1, 1] = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> BufferedRandom: ...\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: OpenBinaryModeWriting,\n    buffering: Literal[-1, 1] = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> BufferedWriter: ...\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: OpenBinaryModeReading,\n    buffering: Literal[-1, 1] = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> BufferedReader: ...\n\n# Buffering cannot be determined: fall back to BinaryIO\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: OpenBinaryMode,\n    buffering: int = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> BinaryIO: ...\n\n# Fallback if mode is not specified\n@overload\ndef open(\n    file: FileDescriptorOrPath,\n    mode: str,\n    buffering: int = -1,\n    encoding: str | None = None,\n    errors: str | None = None,\n    newline: str | None = None,\n    closefd: bool = True,\n    opener: _Opener | None = None,\n) -> IO[Any]: ...\ndef ord(c: str | bytes | bytearray, /) -> int: ...\n@type_check_only\nclass _SupportsWriteAndFlush(SupportsWrite[_T_contra], SupportsFlush, Protocol[_T_contra]): ...\n\n@overload\ndef print(\n    *values: object,\n    sep: str | None = \" \",\n    end: str | None = \"\\n\",\n    file: SupportsWrite[str] | None = None,\n    flush: Literal[False] = False,\n) -> None: ...\n@overload\ndef print(\n    *values: object, sep: str | None = \" \", end: str | None = \"\\n\", file: _SupportsWriteAndFlush[str] | None = None, flush: bool\n) -> None: ...\n\n_E_contra = TypeVar(\"_E_contra\", contravariant=True)\n_M_contra = TypeVar(\"_M_contra\", contravariant=True)\n\n@type_check_only\nclass _SupportsPow2(Protocol[_E_contra, _T_co]):\n    def __pow__(self, other: _E_contra, /) -> _T_co: ...\n\n@type_check_only\nclass _SupportsPow3NoneOnly(Protocol[_E_contra, _T_co]):\n    def __pow__(self, other: _E_contra, modulo: None = None, /) -> _T_co: ...\n\n@type_check_only\nclass _SupportsPow3(Protocol[_E_contra, _M_contra, _T_co]):\n    def __pow__(self, other: _E_contra, modulo: _M_contra, /) -> _T_co: ...\n\n_SupportsSomeKindOfPow = (  # noqa: Y026  # TODO: Use TypeAlias once mypy bugs are fixed\n    _SupportsPow2[Any, Any] | _SupportsPow3NoneOnly[Any, Any] | _SupportsPow3[Any, Any, Any]\n)\n\n# TODO: `pow(int, int, Literal[0])` fails at runtime,\n# but adding a `NoReturn` overload isn't a good solution for expressing that (see #8566).\n@overload\ndef pow(base: int, exp: int, mod: int) -> int: ...\n@overload\ndef pow(base: int, exp: Literal[0], mod: None = None) -> Literal[1]: ...\n@overload\ndef pow(base: int, exp: _PositiveInteger, mod: None = None) -> int: ...\n@overload\ndef pow(base: int, exp: _NegativeInteger, mod: None = None) -> float: ...\n\n# int base & positive-int exp -> int; int base & negative-int exp -> float\n# return type must be Any as `int | float` causes too many false-positive errors\n@overload\ndef pow(base: int, exp: int, mod: None = None) -> Any: ...\n@overload\ndef pow(base: _PositiveInteger, exp: float, mod: None = None) -> float: ...\n@overload\ndef pow(base: _NegativeInteger, exp: float, mod: None = None) -> complex: ...\n@overload\ndef pow(base: float, exp: int, mod: None = None) -> float: ...\n\n# float base & float exp could return float or complex\n# return type must be Any (same as complex base, complex exp),\n# as `float | complex` causes too many false-positive errors\n@overload\ndef pow(base: float, exp: complex | _SupportsSomeKindOfPow, mod: None = None) -> Any: ...\n@overload\ndef pow(base: complex, exp: complex | _SupportsSomeKindOfPow, mod: None = None) -> complex: ...\n@overload\ndef pow(base: _SupportsPow2[_E_contra, _T_co], exp: _E_contra, mod: None = None) -> _T_co: ...  # type: ignore[overload-overlap]\n@overload\ndef pow(base: _SupportsPow3NoneOnly[_E_contra, _T_co], exp: _E_contra, mod: None = None) -> _T_co: ...  # type: ignore[overload-overlap]\n@overload\ndef pow(base: _SupportsPow3[_E_contra, _M_contra, _T_co], exp: _E_contra, mod: _M_contra) -> _T_co: ...\n@overload\ndef pow(base: _SupportsSomeKindOfPow, exp: float, mod: None = None) -> Any: ...\n@overload\ndef pow(base: _SupportsSomeKindOfPow, exp: complex, mod: None = None) -> complex: ...\n\nquit: _sitebuiltins.Quitter\n\n@disjoint_base\nclass reversed(Generic[_T]):\n    @overload\n    def __new__(cls, sequence: Reversible[_T], /) -> Iterator[_T]: ...  # type: ignore[misc]\n    @overload\n    def __new__(cls, sequence: SupportsLenAndGetItem[_T], /) -> Iterator[_T]: ...  # type: ignore[misc]\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n    def __length_hint__(self) -> int: ...\n\ndef repr(obj: object, /) -> str: ...\n\n# See https://github.com/python/typeshed/pull/9141\n# and https://github.com/python/typeshed/pull/9151\n# on why we don't use `SupportsRound` from `typing.pyi`\n\n@type_check_only\nclass _SupportsRound1(Protocol[_T_co]):\n    def __round__(self) -> _T_co: ...\n\n@type_check_only\nclass _SupportsRound2(Protocol[_T_co]):\n    def __round__(self, ndigits: int, /) -> _T_co: ...\n\n@overload\ndef round(number: _SupportsRound1[_T], ndigits: None = None) -> _T: ...\n@overload\ndef round(number: _SupportsRound2[_T], ndigits: SupportsIndex) -> _T: ...\n\n# See https://github.com/python/typeshed/pull/6292#discussion_r748875189\n# for why arg 3 of `setattr` should be annotated with `Any` and not `object`\ndef setattr(obj: object, name: str, value: Any, /) -> None: ...\n@overload\ndef sorted(\n    iterable: Iterable[SupportsRichComparisonT], /, *, key: None = None, reverse: bool = False\n) -> list[SupportsRichComparisonT]: ...\n@overload\ndef sorted(iterable: Iterable[_T], /, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> list[_T]: ...\n\n_AddableT1 = TypeVar(\"_AddableT1\", bound=SupportsAdd[Any, Any])\n_AddableT2 = TypeVar(\"_AddableT2\", bound=SupportsAdd[Any, Any])\n\n@type_check_only\nclass _SupportsSumWithNoDefaultGiven(SupportsAdd[Any, Any], SupportsRAdd[int, Any], Protocol): ...\n\n_SupportsSumNoDefaultT = TypeVar(\"_SupportsSumNoDefaultT\", bound=_SupportsSumWithNoDefaultGiven)\n\n# In general, the return type of `x + x` is *not* guaranteed to be the same type as x.\n# However, we can't express that in the stub for `sum()`\n# without creating many false-positive errors (see #7578).\n# Instead, we special-case the most common examples of this: bool and literal integers.\n@overload\ndef sum(iterable: Iterable[bool | _LiteralInteger], /, start: int = 0) -> int: ...\n@overload\ndef sum(iterable: Iterable[_SupportsSumNoDefaultT], /) -> _SupportsSumNoDefaultT | Literal[0]: ...\n@overload\ndef sum(iterable: Iterable[_AddableT1], /, start: _AddableT2) -> _AddableT1 | _AddableT2: ...\n\n# The argument to `vars()` has to have a `__dict__` attribute, so the second overload can't be annotated with `object`\n# (A \"SupportsDunderDict\" protocol doesn't work)\n@overload\ndef vars(object: type, /) -> types.MappingProxyType[str, Any]: ...\n@overload\ndef vars(object: Any = ..., /) -> dict[str, Any]: ...\n@disjoint_base\nclass zip(Generic[_T_co]):\n    if sys.version_info >= (3, 10):\n        @overload\n        def __new__(cls, *, strict: bool = False) -> zip[Any]: ...\n        @overload\n        def __new__(cls, iter1: Iterable[_T1], /, *, strict: bool = False) -> zip[tuple[_T1]]: ...\n        @overload\n        def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /, *, strict: bool = False) -> zip[tuple[_T1, _T2]]: ...\n        @overload\n        def __new__(\n            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /, *, strict: bool = False\n        ) -> zip[tuple[_T1, _T2, _T3]]: ...\n        @overload\n        def __new__(\n            cls,\n            iter1: Iterable[_T1],\n            iter2: Iterable[_T2],\n            iter3: Iterable[_T3],\n            iter4: Iterable[_T4],\n            /,\n            *,\n            strict: bool = False,\n        ) -> zip[tuple[_T1, _T2, _T3, _T4]]: ...\n        @overload\n        def __new__(\n            cls,\n            iter1: Iterable[_T1],\n            iter2: Iterable[_T2],\n            iter3: Iterable[_T3],\n            iter4: Iterable[_T4],\n            iter5: Iterable[_T5],\n            /,\n            *,\n            strict: bool = False,\n        ) -> zip[tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n        @overload\n        def __new__(\n            cls,\n            iter1: Iterable[Any],\n            iter2: Iterable[Any],\n            iter3: Iterable[Any],\n            iter4: Iterable[Any],\n            iter5: Iterable[Any],\n            iter6: Iterable[Any],\n            /,\n            *iterables: Iterable[Any],\n            strict: bool = False,\n        ) -> zip[tuple[Any, ...]]: ...\n    else:\n        @overload\n        def __new__(cls) -> zip[Any]: ...\n        @overload\n        def __new__(cls, iter1: Iterable[_T1], /) -> zip[tuple[_T1]]: ...\n        @overload\n        def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> zip[tuple[_T1, _T2]]: ...\n        @overload\n        def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /) -> zip[tuple[_T1, _T2, _T3]]: ...\n        @overload\n        def __new__(\n            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /\n        ) -> zip[tuple[_T1, _T2, _T3, _T4]]: ...\n        @overload\n        def __new__(\n            cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], iter5: Iterable[_T5], /\n        ) -> zip[tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n        @overload\n        def __new__(\n            cls,\n            iter1: Iterable[Any],\n            iter2: Iterable[Any],\n            iter3: Iterable[Any],\n            iter4: Iterable[Any],\n            iter5: Iterable[Any],\n            iter6: Iterable[Any],\n            /,\n            *iterables: Iterable[Any],\n        ) -> zip[tuple[Any, ...]]: ...\n\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T_co: ...\n\n# Signature of `builtins.__import__` should be kept identical to `importlib.__import__`\n# Return type of `__import__` should be kept the same as return type of `importlib.import_module`\ndef __import__(\n    name: str,\n    globals: Mapping[str, object] | None = None,\n    locals: Mapping[str, object] | None = None,\n    fromlist: Sequence[str] | None = (),\n    level: int = 0,\n) -> types.ModuleType: ...\ndef __build_class__(func: Callable[[], CellType | Any], name: str, /, *bases: Any, metaclass: Any = ..., **kwds: Any) -> Any: ...\n\nif sys.version_info >= (3, 10):\n    from types import EllipsisType, NotImplementedType\n\n    # Backwards compatibility hack for folks who relied on the ellipsis type\n    # existing in typeshed in Python 3.9 and earlier.\n    ellipsis = EllipsisType\n\n    Ellipsis: EllipsisType\n    NotImplemented: NotImplementedType\nelse:\n    # Actually the type of Ellipsis is <type 'ellipsis'>, but since it's\n    # not exposed anywhere under that name, we make it private here.\n    @final\n    @type_check_only\n    class ellipsis: ...\n\n    Ellipsis: ellipsis\n\n    @final\n    @type_check_only\n    class _NotImplementedType(Any): ...\n\n    NotImplemented: _NotImplementedType\n\n@disjoint_base\nclass BaseException:\n    args: tuple[Any, ...]\n    __cause__: BaseException | None\n    __context__: BaseException | None\n    __suppress_context__: bool\n    __traceback__: TracebackType | None\n    def __init__(self, *args: object) -> None: ...\n    def __new__(cls, *args: Any, **kwds: Any) -> Self: ...\n    def __setstate__(self, state: dict[str, Any] | None, /) -> None: ...\n    def with_traceback(self, tb: TracebackType | None, /) -> Self: ...\n    # Necessary for security-focused static analyzers (e.g, pysa)\n    # See https://github.com/python/typeshed/pull/14900\n    def __str__(self) -> str: ...  # noqa: Y029\n    def __repr__(self) -> str: ...  # noqa: Y029\n    if sys.version_info >= (3, 11):\n        # only present after add_note() is called\n        __notes__: list[str]\n        def add_note(self, note: str, /) -> None: ...\n\nclass GeneratorExit(BaseException): ...\nclass KeyboardInterrupt(BaseException): ...\n\n@disjoint_base\nclass SystemExit(BaseException):\n    code: sys._ExitCode\n\nclass Exception(BaseException): ...\n\n@disjoint_base\nclass StopIteration(Exception):\n    value: Any\n\n@disjoint_base\nclass OSError(Exception):\n    errno: int | None\n    strerror: str | None\n    # filename, filename2 are actually str | bytes | None\n    filename: Any\n    filename2: Any\n    if sys.platform == \"win32\":\n        winerror: int\n\nEnvironmentError = OSError\nIOError = OSError\nif sys.platform == \"win32\":\n    WindowsError = OSError\n\nclass ArithmeticError(Exception): ...\nclass AssertionError(Exception): ...\n\nif sys.version_info >= (3, 10):\n    @disjoint_base\n    class AttributeError(Exception):\n        def __init__(self, *args: object, name: str | None = None, obj: object = None) -> None: ...\n        name: str | None\n        obj: object\n\nelse:\n    class AttributeError(Exception): ...\n\nclass BufferError(Exception): ...\nclass EOFError(Exception): ...\n\n@disjoint_base\nclass ImportError(Exception):\n    def __init__(self, *args: object, name: str | None = None, path: str | None = None) -> None: ...\n    name: str | None\n    path: str | None\n    msg: str  # undocumented\n    if sys.version_info >= (3, 12):\n        name_from: str | None  # undocumented\n\nclass LookupError(Exception): ...\nclass MemoryError(Exception): ...\n\nif sys.version_info >= (3, 10):\n    @disjoint_base\n    class NameError(Exception):\n        def __init__(self, *args: object, name: str | None = None) -> None: ...\n        name: str | None\n\nelse:\n    class NameError(Exception): ...\n\nclass ReferenceError(Exception): ...\nclass RuntimeError(Exception): ...\nclass StopAsyncIteration(Exception): ...\n\n@disjoint_base\nclass SyntaxError(Exception):\n    msg: str\n    filename: str | None\n    lineno: int | None\n    offset: int | None\n    text: str | None\n    # Errors are displayed differently if this attribute exists on the exception.\n    # The value is always None.\n    print_file_and_line: None\n    if sys.version_info >= (3, 10):\n        end_lineno: int | None\n        end_offset: int | None\n\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self, msg: object, /) -> None: ...\n    # Second argument is the tuple (filename, lineno, offset, text)\n    @overload\n    def __init__(self, msg: str, info: tuple[str | None, int | None, int | None, str | None], /) -> None: ...\n    if sys.version_info >= (3, 10):\n        # end_lineno and end_offset must both be provided if one is.\n        @overload\n        def __init__(\n            self, msg: str, info: tuple[str | None, int | None, int | None, str | None, int | None, int | None], /\n        ) -> None: ...\n    # If you provide more than two arguments, it still creates the SyntaxError, but\n    # the arguments from the info tuple are not parsed. This form is omitted.\n\nclass SystemError(Exception): ...\nclass TypeError(Exception): ...\nclass ValueError(Exception): ...\nclass FloatingPointError(ArithmeticError): ...\nclass OverflowError(ArithmeticError): ...\nclass ZeroDivisionError(ArithmeticError): ...\nclass ModuleNotFoundError(ImportError): ...\nclass IndexError(LookupError): ...\nclass KeyError(LookupError): ...\nclass UnboundLocalError(NameError): ...\n\nclass BlockingIOError(OSError):\n    characters_written: int\n\nclass ChildProcessError(OSError): ...\nclass ConnectionError(OSError): ...\nclass BrokenPipeError(ConnectionError): ...\nclass ConnectionAbortedError(ConnectionError): ...\nclass ConnectionRefusedError(ConnectionError): ...\nclass ConnectionResetError(ConnectionError): ...\nclass FileExistsError(OSError): ...\nclass FileNotFoundError(OSError): ...\nclass InterruptedError(OSError): ...\nclass IsADirectoryError(OSError): ...\nclass NotADirectoryError(OSError): ...\nclass PermissionError(OSError): ...\nclass ProcessLookupError(OSError): ...\nclass TimeoutError(OSError): ...\nclass NotImplementedError(RuntimeError): ...\nclass RecursionError(RuntimeError): ...\nclass IndentationError(SyntaxError): ...\nclass TabError(IndentationError): ...\nclass UnicodeError(ValueError): ...\n\n@disjoint_base\nclass UnicodeDecodeError(UnicodeError):\n    encoding: str\n    object: bytes\n    start: int\n    end: int\n    reason: str\n    def __init__(self, encoding: str, object: ReadableBuffer, start: int, end: int, reason: str, /) -> None: ...\n\n@disjoint_base\nclass UnicodeEncodeError(UnicodeError):\n    encoding: str\n    object: str\n    start: int\n    end: int\n    reason: str\n    def __init__(self, encoding: str, object: str, start: int, end: int, reason: str, /) -> None: ...\n\n@disjoint_base\nclass UnicodeTranslateError(UnicodeError):\n    encoding: None\n    object: str\n    start: int\n    end: int\n    reason: str\n    def __init__(self, object: str, start: int, end: int, reason: str, /) -> None: ...\n\nclass Warning(Exception): ...\nclass UserWarning(Warning): ...\nclass DeprecationWarning(Warning): ...\nclass SyntaxWarning(Warning): ...\nclass RuntimeWarning(Warning): ...\nclass FutureWarning(Warning): ...\nclass PendingDeprecationWarning(Warning): ...\nclass ImportWarning(Warning): ...\nclass UnicodeWarning(Warning): ...\nclass BytesWarning(Warning): ...\nclass ResourceWarning(Warning): ...\n\nif sys.version_info >= (3, 10):\n    class EncodingWarning(Warning): ...\n\nif sys.version_info >= (3, 11):\n    _BaseExceptionT_co = TypeVar(\"_BaseExceptionT_co\", bound=BaseException, covariant=True, default=BaseException)\n    _BaseExceptionT = TypeVar(\"_BaseExceptionT\", bound=BaseException)\n    _ExceptionT_co = TypeVar(\"_ExceptionT_co\", bound=Exception, covariant=True, default=Exception)\n    _ExceptionT = TypeVar(\"_ExceptionT\", bound=Exception)\n\n    # See `check_exception_group.py` for use-cases and comments.\n    @disjoint_base\n    class BaseExceptionGroup(BaseException, Generic[_BaseExceptionT_co]):\n        def __new__(cls, message: str, exceptions: Sequence[_BaseExceptionT_co], /) -> Self: ...\n        def __init__(self, message: str, exceptions: Sequence[_BaseExceptionT_co], /) -> None: ...\n        @property\n        def message(self) -> str: ...\n        @property\n        def exceptions(self) -> tuple[_BaseExceptionT_co | BaseExceptionGroup[_BaseExceptionT_co], ...]: ...\n        @overload\n        def subgroup(\n            self, matcher_value: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /\n        ) -> ExceptionGroup[_ExceptionT] | None: ...\n        @overload\n        def subgroup(\n            self, matcher_value: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...], /\n        ) -> BaseExceptionGroup[_BaseExceptionT] | None: ...\n        @overload\n        def subgroup(\n            self, matcher_value: Callable[[_BaseExceptionT_co | Self], bool], /\n        ) -> BaseExceptionGroup[_BaseExceptionT_co] | None: ...\n        @overload\n        def split(\n            self, matcher_value: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /\n        ) -> tuple[ExceptionGroup[_ExceptionT] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...\n        @overload\n        def split(\n            self, matcher_value: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...], /\n        ) -> tuple[BaseExceptionGroup[_BaseExceptionT] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...\n        @overload\n        def split(\n            self, matcher_value: Callable[[_BaseExceptionT_co | Self], bool], /\n        ) -> tuple[BaseExceptionGroup[_BaseExceptionT_co] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...\n        # In reality it is `NonEmptySequence`:\n        @overload\n        def derive(self, excs: Sequence[_ExceptionT], /) -> ExceptionGroup[_ExceptionT]: ...\n        @overload\n        def derive(self, excs: Sequence[_BaseExceptionT], /) -> BaseExceptionGroup[_BaseExceptionT]: ...\n        def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n    class ExceptionGroup(BaseExceptionGroup[_ExceptionT_co], Exception):\n        def __new__(cls, message: str, exceptions: Sequence[_ExceptionT_co], /) -> Self: ...\n        def __init__(self, message: str, exceptions: Sequence[_ExceptionT_co], /) -> None: ...\n        @property\n        def exceptions(self) -> tuple[_ExceptionT_co | ExceptionGroup[_ExceptionT_co], ...]: ...\n        # We accept a narrower type, but that's OK.\n        @overload  # type: ignore[override]\n        def subgroup(\n            self, matcher_value: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /\n        ) -> ExceptionGroup[_ExceptionT] | None: ...\n        @overload\n        def subgroup(\n            self, matcher_value: Callable[[_ExceptionT_co | Self], bool], /\n        ) -> ExceptionGroup[_ExceptionT_co] | None: ...\n        @overload  # type: ignore[override]\n        def split(\n            self, matcher_value: type[_ExceptionT] | tuple[type[_ExceptionT], ...], /\n        ) -> tuple[ExceptionGroup[_ExceptionT] | None, ExceptionGroup[_ExceptionT_co] | None]: ...\n        @overload\n        def split(\n            self, matcher_value: Callable[[_ExceptionT_co | Self], bool], /\n        ) -> tuple[ExceptionGroup[_ExceptionT_co] | None, ExceptionGroup[_ExceptionT_co] | None]: ...\n\nif sys.version_info >= (3, 13):\n    class PythonFinalizationError(RuntimeError): ...\n",
  "/typeshed/stdlib/collections/__init__.pyi": "import sys\nfrom _collections_abc import dict_items, dict_keys, dict_values\nfrom _typeshed import SupportsItems, SupportsKeysAndGetItem, SupportsRichComparison, SupportsRichComparisonT\nfrom types import GenericAlias\nfrom typing import Any, ClassVar, Generic, NoReturn, SupportsIndex, TypeVar, final, overload, type_check_only\nfrom typing_extensions import Self, disjoint_base\n\nif sys.version_info >= (3, 10):\n    from collections.abc import (\n        Callable,\n        ItemsView,\n        Iterable,\n        Iterator,\n        KeysView,\n        Mapping,\n        MutableMapping,\n        MutableSequence,\n        Sequence,\n        ValuesView,\n    )\nelse:\n    from _collections_abc import *\n\n__all__ = [\"ChainMap\", \"Counter\", \"OrderedDict\", \"UserDict\", \"UserList\", \"UserString\", \"defaultdict\", \"deque\", \"namedtuple\"]\n\n_S = TypeVar(\"_S\")\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n\n# namedtuple is special-cased in the type checker; the initializer is ignored.\ndef namedtuple(\n    typename: str,\n    field_names: str | Iterable[str],\n    *,\n    rename: bool = False,\n    module: str | None = None,\n    defaults: Iterable[Any] | None = None,\n) -> type[tuple[Any, ...]]: ...\n\nclass UserDict(MutableMapping[_KT, _VT]):\n    data: dict[_KT, _VT]\n    # __init__ should be kept roughly in line with `dict.__init__`, which has the same semantics\n    @overload\n    def __init__(self, dict: None = None, /) -> None: ...\n    @overload\n    def __init__(\n        self: UserDict[str, _VT], dict: None = None, /, **kwargs: _VT  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n    ) -> None: ...\n    @overload\n    def __init__(self, dict: SupportsKeysAndGetItem[_KT, _VT], /) -> None: ...\n    @overload\n    def __init__(\n        self: UserDict[str, _VT],  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n        dict: SupportsKeysAndGetItem[str, _VT],\n        /,\n        **kwargs: _VT,\n    ) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[tuple[_KT, _VT]], /) -> None: ...\n    @overload\n    def __init__(\n        self: UserDict[str, _VT],  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n        iterable: Iterable[tuple[str, _VT]],\n        /,\n        **kwargs: _VT,\n    ) -> None: ...\n    @overload\n    def __init__(self: UserDict[str, str], iterable: Iterable[list[str]], /) -> None: ...\n    @overload\n    def __init__(self: UserDict[bytes, bytes], iterable: Iterable[list[bytes]], /) -> None: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, key: _KT) -> _VT: ...\n    def __setitem__(self, key: _KT, item: _VT) -> None: ...\n    def __delitem__(self, key: _KT) -> None: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __contains__(self, key: object) -> bool: ...\n    def copy(self) -> Self: ...\n    def __copy__(self) -> Self: ...\n\n    # `UserDict.fromkeys` has the same semantics as `dict.fromkeys`, so should be kept in line with `dict.fromkeys`.\n    # TODO: Much like `dict.fromkeys`, the true signature of `UserDict.fromkeys` is inexpressible in the current type system.\n    # See #3800 & https://github.com/python/typing/issues/548#issuecomment-683336963.\n    @classmethod\n    @overload\n    def fromkeys(cls, iterable: Iterable[_T], value: None = None) -> UserDict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, iterable: Iterable[_T], value: _S) -> UserDict[_T, _S]: ...\n    @overload\n    def __or__(self, other: UserDict[_KT, _VT] | dict[_KT, _VT]) -> Self: ...\n    @overload\n    def __or__(self, other: UserDict[_T1, _T2] | dict[_T1, _T2]) -> UserDict[_KT | _T1, _VT | _T2]: ...\n    @overload\n    def __ror__(self, other: UserDict[_KT, _VT] | dict[_KT, _VT]) -> Self: ...\n    @overload\n    def __ror__(self, other: UserDict[_T1, _T2] | dict[_T1, _T2]) -> UserDict[_KT | _T1, _VT | _T2]: ...\n    # UserDict.__ior__ should be kept roughly in line with MutableMapping.update()\n    @overload  # type: ignore[misc]\n    def __ior__(self, other: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...\n    @overload\n    def __ior__(self, other: Iterable[tuple[_KT, _VT]]) -> Self: ...\n    if sys.version_info >= (3, 12):\n        @overload\n        def get(self, key: _KT, default: None = None) -> _VT | None: ...\n        @overload\n        def get(self, key: _KT, default: _VT) -> _VT: ...\n        @overload\n        def get(self, key: _KT, default: _T) -> _VT | _T: ...\n\nclass UserList(MutableSequence[_T]):\n    data: list[_T]\n    @overload\n    def __init__(self, initlist: None = None) -> None: ...\n    @overload\n    def __init__(self, initlist: Iterable[_T]) -> None: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    def __lt__(self, other: list[_T] | UserList[_T]) -> bool: ...\n    def __le__(self, other: list[_T] | UserList[_T]) -> bool: ...\n    def __gt__(self, other: list[_T] | UserList[_T]) -> bool: ...\n    def __ge__(self, other: list[_T] | UserList[_T]) -> bool: ...\n    def __eq__(self, other: object) -> bool: ...\n    def __contains__(self, item: object) -> bool: ...\n    def __len__(self) -> int: ...\n    @overload\n    def __getitem__(self, i: SupportsIndex) -> _T: ...\n    @overload\n    def __getitem__(self, i: slice) -> Self: ...\n    @overload\n    def __setitem__(self, i: SupportsIndex, item: _T) -> None: ...\n    @overload\n    def __setitem__(self, i: slice, item: Iterable[_T]) -> None: ...\n    def __delitem__(self, i: SupportsIndex | slice) -> None: ...\n    def __add__(self, other: Iterable[_T]) -> Self: ...\n    def __radd__(self, other: Iterable[_T]) -> Self: ...\n    def __iadd__(self, other: Iterable[_T]) -> Self: ...\n    def __mul__(self, n: int) -> Self: ...\n    def __rmul__(self, n: int) -> Self: ...\n    def __imul__(self, n: int) -> Self: ...\n    def append(self, item: _T) -> None: ...\n    def insert(self, i: int, item: _T) -> None: ...\n    def pop(self, i: int = -1) -> _T: ...\n    def remove(self, item: _T) -> None: ...\n    def copy(self) -> Self: ...\n    def __copy__(self) -> Self: ...\n    def count(self, item: _T) -> int: ...\n    # The runtime signature is \"item, *args\", and the arguments are then passed\n    # to `list.index`. In order to give more precise types, we pretend that the\n    # `item` argument is positional-only.\n    def index(self, item: _T, start: SupportsIndex = 0, stop: SupportsIndex = sys.maxsize, /) -> int: ...\n    # All arguments are passed to `list.sort` at runtime, so the signature should be kept in line with `list.sort`.\n    @overload\n    def sort(self: UserList[SupportsRichComparisonT], *, key: None = None, reverse: bool = False) -> None: ...\n    @overload\n    def sort(self, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = False) -> None: ...\n    def extend(self, other: Iterable[_T]) -> None: ...\n\nclass UserString(Sequence[UserString]):\n    data: str\n    def __init__(self, seq: object) -> None: ...\n    def __int__(self) -> int: ...\n    def __float__(self) -> float: ...\n    def __complex__(self) -> complex: ...\n    def __getnewargs__(self) -> tuple[str]: ...\n    def __lt__(self, string: str | UserString) -> bool: ...\n    def __le__(self, string: str | UserString) -> bool: ...\n    def __gt__(self, string: str | UserString) -> bool: ...\n    def __ge__(self, string: str | UserString) -> bool: ...\n    def __eq__(self, string: object) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __contains__(self, char: object) -> bool: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, index: SupportsIndex | slice) -> Self: ...\n    def __iter__(self) -> Iterator[Self]: ...\n    def __reversed__(self) -> Iterator[Self]: ...\n    def __add__(self, other: object) -> Self: ...\n    def __radd__(self, other: object) -> Self: ...\n    def __mul__(self, n: int) -> Self: ...\n    def __rmul__(self, n: int) -> Self: ...\n    def __mod__(self, args: Any) -> Self: ...\n    def __rmod__(self, template: object) -> Self: ...\n    def capitalize(self) -> Self: ...\n    def casefold(self) -> Self: ...\n    def center(self, width: int, *args: Any) -> Self: ...\n    def count(self, sub: str | UserString, start: int = 0, end: int = sys.maxsize) -> int: ...\n    def encode(self: UserString, encoding: str | None = \"utf-8\", errors: str | None = \"strict\") -> bytes: ...\n    def endswith(self, suffix: str | tuple[str, ...], start: int | None = 0, end: int | None = sys.maxsize) -> bool: ...\n    def expandtabs(self, tabsize: int = 8) -> Self: ...\n    def find(self, sub: str | UserString, start: int = 0, end: int = sys.maxsize) -> int: ...\n    def format(self, *args: Any, **kwds: Any) -> str: ...\n    def format_map(self, mapping: Mapping[str, Any]) -> str: ...\n    def index(self, sub: str, start: int = 0, end: int = sys.maxsize) -> int: ...\n    def isalpha(self) -> bool: ...\n    def isalnum(self) -> bool: ...\n    def isdecimal(self) -> bool: ...\n    def isdigit(self) -> bool: ...\n    def isidentifier(self) -> bool: ...\n    def islower(self) -> bool: ...\n    def isnumeric(self) -> bool: ...\n    def isprintable(self) -> bool: ...\n    def isspace(self) -> bool: ...\n    def istitle(self) -> bool: ...\n    def isupper(self) -> bool: ...\n    def isascii(self) -> bool: ...\n    def join(self, seq: Iterable[str]) -> str: ...\n    def ljust(self, width: int, *args: Any) -> Self: ...\n    def lower(self) -> Self: ...\n    def lstrip(self, chars: str | None = None) -> Self: ...\n    maketrans = str.maketrans\n    def partition(self, sep: str) -> tuple[str, str, str]: ...\n    def removeprefix(self, prefix: str | UserString, /) -> Self: ...\n    def removesuffix(self, suffix: str | UserString, /) -> Self: ...\n    def replace(self, old: str | UserString, new: str | UserString, maxsplit: int = -1) -> Self: ...\n    def rfind(self, sub: str | UserString, start: int = 0, end: int = sys.maxsize) -> int: ...\n    def rindex(self, sub: str | UserString, start: int = 0, end: int = sys.maxsize) -> int: ...\n    def rjust(self, width: int, *args: Any) -> Self: ...\n    def rpartition(self, sep: str) -> tuple[str, str, str]: ...\n    def rstrip(self, chars: str | None = None) -> Self: ...\n    def split(self, sep: str | None = None, maxsplit: int = -1) -> list[str]: ...\n    def rsplit(self, sep: str | None = None, maxsplit: int = -1) -> list[str]: ...\n    def splitlines(self, keepends: bool = False) -> list[str]: ...\n    def startswith(self, prefix: str | tuple[str, ...], start: int | None = 0, end: int | None = sys.maxsize) -> bool: ...\n    def strip(self, chars: str | None = None) -> Self: ...\n    def swapcase(self) -> Self: ...\n    def title(self) -> Self: ...\n    def translate(self, *args: Any) -> Self: ...\n    def upper(self) -> Self: ...\n    def zfill(self, width: int) -> Self: ...\n\n@disjoint_base\nclass deque(MutableSequence[_T]):\n    @property\n    def maxlen(self) -> int | None: ...\n    @overload\n    def __init__(self, *, maxlen: int | None = None) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T], maxlen: int | None = None) -> None: ...\n    def append(self, x: _T, /) -> None: ...\n    def appendleft(self, x: _T, /) -> None: ...\n    def copy(self) -> Self: ...\n    def count(self, x: _T, /) -> int: ...\n    def extend(self, iterable: Iterable[_T], /) -> None: ...\n    def extendleft(self, iterable: Iterable[_T], /) -> None: ...\n    def insert(self, i: int, x: _T, /) -> None: ...\n    def index(self, x: _T, start: int = 0, stop: int = ..., /) -> int: ...\n    def pop(self) -> _T: ...  # type: ignore[override]\n    def popleft(self) -> _T: ...\n    def remove(self, value: _T, /) -> None: ...\n    def rotate(self, n: int = 1, /) -> None: ...\n    def __copy__(self) -> Self: ...\n    def __len__(self) -> int: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    # These methods of deque don't take slices, unlike MutableSequence, hence the type: ignores\n    def __getitem__(self, key: SupportsIndex, /) -> _T: ...  # type: ignore[override]\n    def __setitem__(self, key: SupportsIndex, value: _T, /) -> None: ...  # type: ignore[override]\n    def __delitem__(self, key: SupportsIndex, /) -> None: ...  # type: ignore[override]\n    def __contains__(self, key: object, /) -> bool: ...\n    def __reduce__(self) -> tuple[type[Self], tuple[()], None, Iterator[_T]]: ...\n    def __iadd__(self, value: Iterable[_T], /) -> Self: ...\n    def __add__(self, value: Self, /) -> Self: ...\n    def __mul__(self, value: int, /) -> Self: ...\n    def __imul__(self, value: int, /) -> Self: ...\n    def __lt__(self, value: deque[_T], /) -> bool: ...\n    def __le__(self, value: deque[_T], /) -> bool: ...\n    def __gt__(self, value: deque[_T], /) -> bool: ...\n    def __ge__(self, value: deque[_T], /) -> bool: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\nclass Counter(dict[_T, int], Generic[_T]):\n    @overload\n    def __init__(self, iterable: None = None, /) -> None: ...\n    @overload\n    def __init__(self: Counter[str], iterable: None = None, /, **kwargs: int) -> None: ...\n    @overload\n    def __init__(self, mapping: SupportsKeysAndGetItem[_T, int], /) -> None: ...\n    @overload\n    def __init__(self, iterable: Iterable[_T], /) -> None: ...\n    def copy(self) -> Self: ...\n    def elements(self) -> Iterator[_T]: ...\n    def most_common(self, n: int | None = None) -> list[tuple[_T, int]]: ...\n    @classmethod\n    def fromkeys(cls, iterable: Any, v: int | None = None) -> NoReturn: ...  # type: ignore[override]\n    @overload\n    def subtract(self, iterable: None = None, /) -> None: ...\n    @overload\n    def subtract(self, mapping: Mapping[_T, int], /) -> None: ...\n    @overload\n    def subtract(self, iterable: Iterable[_T], /) -> None: ...\n    # Unlike dict.update(), use Mapping instead of SupportsKeysAndGetItem for the first overload\n    # (source code does an `isinstance(other, Mapping)` check)\n    #\n    # The second overload is also deliberately different to dict.update()\n    # (if it were `Iterable[_T] | Iterable[tuple[_T, int]]`,\n    # the tuples would be added as keys, breaking type safety)\n    @overload  # type: ignore[override]\n    def update(self, m: Mapping[_T, int], /, **kwargs: int) -> None: ...\n    @overload\n    def update(self, iterable: Iterable[_T], /, **kwargs: int) -> None: ...\n    @overload\n    def update(self, iterable: None = None, /, **kwargs: int) -> None: ...\n    def __missing__(self, key: _T) -> int: ...\n    def __delitem__(self, elem: object) -> None: ...\n    if sys.version_info >= (3, 10):\n        def __eq__(self, other: object) -> bool: ...\n        def __ne__(self, other: object) -> bool: ...\n\n    def __add__(self, other: Counter[_S]) -> Counter[_T | _S]: ...\n    def __sub__(self, other: Counter[_T]) -> Counter[_T]: ...\n    def __and__(self, other: Counter[_T]) -> Counter[_T]: ...\n    def __or__(self, other: Counter[_S]) -> Counter[_T | _S]: ...  # type: ignore[override]\n    def __pos__(self) -> Counter[_T]: ...\n    def __neg__(self) -> Counter[_T]: ...\n    # several type: ignores because __iadd__ is supposedly incompatible with __add__, etc.\n    def __iadd__(self, other: SupportsItems[_T, int]) -> Self: ...  # type: ignore[misc]\n    def __isub__(self, other: SupportsItems[_T, int]) -> Self: ...\n    def __iand__(self, other: SupportsItems[_T, int]) -> Self: ...\n    def __ior__(self, other: SupportsItems[_T, int]) -> Self: ...  # type: ignore[override,misc]\n    if sys.version_info >= (3, 10):\n        def total(self) -> int: ...\n        def __le__(self, other: Counter[Any]) -> bool: ...\n        def __lt__(self, other: Counter[Any]) -> bool: ...\n        def __ge__(self, other: Counter[Any]) -> bool: ...\n        def __gt__(self, other: Counter[Any]) -> bool: ...\n\n# The pure-Python implementations of the \"views\" classes\n# These are exposed at runtime in `collections/__init__.py`\nclass _OrderedDictKeysView(KeysView[_KT_co]):\n    def __reversed__(self) -> Iterator[_KT_co]: ...\n\nclass _OrderedDictItemsView(ItemsView[_KT_co, _VT_co]):\n    def __reversed__(self) -> Iterator[tuple[_KT_co, _VT_co]]: ...\n\nclass _OrderedDictValuesView(ValuesView[_VT_co]):\n    def __reversed__(self) -> Iterator[_VT_co]: ...\n\n# The C implementations of the \"views\" classes\n# (At runtime, these are called `odict_keys`, `odict_items` and `odict_values`,\n# but they are not exposed anywhere)\n# pyright doesn't have a specific error code for subclassing error!\n@final\n@type_check_only\nclass _odict_keys(dict_keys[_KT_co, _VT_co]):  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues]\n    def __reversed__(self) -> Iterator[_KT_co]: ...\n\n@final\n@type_check_only\nclass _odict_items(dict_items[_KT_co, _VT_co]):  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues]\n    def __reversed__(self) -> Iterator[tuple[_KT_co, _VT_co]]: ...\n\n@final\n@type_check_only\nclass _odict_values(dict_values[_KT_co, _VT_co]):  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues]\n    def __reversed__(self) -> Iterator[_VT_co]: ...\n\n@disjoint_base\nclass OrderedDict(dict[_KT, _VT]):\n    def popitem(self, last: bool = True) -> tuple[_KT, _VT]: ...\n    def move_to_end(self, key: _KT, last: bool = True) -> None: ...\n    def copy(self) -> Self: ...\n    def __reversed__(self) -> Iterator[_KT]: ...\n    def keys(self) -> _odict_keys[_KT, _VT]: ...\n    def items(self) -> _odict_items[_KT, _VT]: ...\n    def values(self) -> _odict_values[_KT, _VT]: ...\n    # The signature of OrderedDict.fromkeys should be kept in line with `dict.fromkeys`, modulo positional-only differences.\n    # Like dict.fromkeys, its true signature is not expressible in the current type system.\n    # See #3800 & https://github.com/python/typing/issues/548#issuecomment-683336963.\n    @classmethod\n    @overload\n    def fromkeys(cls, iterable: Iterable[_T], value: None = None) -> OrderedDict[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, iterable: Iterable[_T], value: _S) -> OrderedDict[_T, _S]: ...\n    # Keep OrderedDict.setdefault in line with MutableMapping.setdefault, modulo positional-only differences.\n    @overload\n    def setdefault(self: OrderedDict[_KT, _T | None], key: _KT, default: None = None) -> _T | None: ...\n    @overload\n    def setdefault(self, key: _KT, default: _VT) -> _VT: ...\n    # Same as dict.pop, but accepts keyword arguments\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _VT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _T) -> _VT | _T: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    @overload\n    def __or__(self, value: dict[_KT, _VT], /) -> Self: ...\n    @overload\n    def __or__(self, value: dict[_T1, _T2], /) -> OrderedDict[_KT | _T1, _VT | _T2]: ...\n    @overload\n    def __ror__(self, value: dict[_KT, _VT], /) -> Self: ...\n    @overload\n    def __ror__(self, value: dict[_T1, _T2], /) -> OrderedDict[_KT | _T1, _VT | _T2]: ...  # type: ignore[misc]\n\n@disjoint_base\nclass defaultdict(dict[_KT, _VT]):\n    default_factory: Callable[[], _VT] | None\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(self: defaultdict[str, _VT], **kwargs: _VT) -> None: ...  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n    @overload\n    def __init__(self, default_factory: Callable[[], _VT] | None, /) -> None: ...\n    @overload\n    def __init__(\n        self: defaultdict[str, _VT],  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n        default_factory: Callable[[], _VT] | None,\n        /,\n        **kwargs: _VT,\n    ) -> None: ...\n    @overload\n    def __init__(self, default_factory: Callable[[], _VT] | None, map: SupportsKeysAndGetItem[_KT, _VT], /) -> None: ...\n    @overload\n    def __init__(\n        self: defaultdict[str, _VT],  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n        default_factory: Callable[[], _VT] | None,\n        map: SupportsKeysAndGetItem[str, _VT],\n        /,\n        **kwargs: _VT,\n    ) -> None: ...\n    @overload\n    def __init__(self, default_factory: Callable[[], _VT] | None, iterable: Iterable[tuple[_KT, _VT]], /) -> None: ...\n    @overload\n    def __init__(\n        self: defaultdict[str, _VT],  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n        default_factory: Callable[[], _VT] | None,\n        iterable: Iterable[tuple[str, _VT]],\n        /,\n        **kwargs: _VT,\n    ) -> None: ...\n    def __missing__(self, key: _KT, /) -> _VT: ...\n    def __copy__(self) -> Self: ...\n    def copy(self) -> Self: ...\n    @overload\n    def __or__(self, value: dict[_KT, _VT], /) -> Self: ...\n    @overload\n    def __or__(self, value: dict[_T1, _T2], /) -> defaultdict[_KT | _T1, _VT | _T2]: ...\n    @overload\n    def __ror__(self, value: dict[_KT, _VT], /) -> Self: ...\n    @overload\n    def __ror__(self, value: dict[_T1, _T2], /) -> defaultdict[_KT | _T1, _VT | _T2]: ...  # type: ignore[misc]\n\nclass ChainMap(MutableMapping[_KT, _VT]):\n    maps: list[MutableMapping[_KT, _VT]]\n    def __init__(self, *maps: MutableMapping[_KT, _VT]) -> None: ...\n    def new_child(self, m: MutableMapping[_KT, _VT] | None = None) -> Self: ...\n    @property\n    def parents(self) -> Self: ...\n    def __setitem__(self, key: _KT, value: _VT) -> None: ...\n    def __delitem__(self, key: _KT) -> None: ...\n    def __getitem__(self, key: _KT) -> _VT: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def __len__(self) -> int: ...\n    def __contains__(self, key: object) -> bool: ...\n    @overload\n    def get(self, key: _KT, default: None = None) -> _VT | None: ...\n    @overload\n    def get(self, key: _KT, default: _VT) -> _VT: ...\n    @overload\n    def get(self, key: _KT, default: _T) -> _VT | _T: ...\n    def __missing__(self, key: _KT) -> _VT: ...  # undocumented\n    def __bool__(self) -> bool: ...\n    # Keep ChainMap.setdefault in line with MutableMapping.setdefault, modulo positional-only differences.\n    @overload\n    def setdefault(self: ChainMap[_KT, _T | None], key: _KT, default: None = None) -> _T | None: ...\n    @overload\n    def setdefault(self, key: _KT, default: _VT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _VT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _T) -> _VT | _T: ...\n    def copy(self) -> Self: ...\n    __copy__ = copy\n    # All arguments to `fromkeys` are passed to `dict.fromkeys` at runtime,\n    # so the signature should be kept in line with `dict.fromkeys`.\n    if sys.version_info >= (3, 13):\n        @classmethod\n        @overload\n        def fromkeys(cls, iterable: Iterable[_T], /) -> ChainMap[_T, Any | None]: ...\n    else:\n        @classmethod\n        @overload\n        def fromkeys(cls, iterable: Iterable[_T]) -> ChainMap[_T, Any | None]: ...\n\n    @classmethod\n    @overload\n    # Special-case None: the user probably wants to add non-None values later.\n    def fromkeys(cls, iterable: Iterable[_T], value: None, /) -> ChainMap[_T, Any | None]: ...\n    @classmethod\n    @overload\n    def fromkeys(cls, iterable: Iterable[_T], value: _S, /) -> ChainMap[_T, _S]: ...\n    @overload\n    def __or__(self, other: Mapping[_KT, _VT]) -> Self: ...\n    @overload\n    def __or__(self, other: Mapping[_T1, _T2]) -> ChainMap[_KT | _T1, _VT | _T2]: ...\n    @overload\n    def __ror__(self, other: Mapping[_KT, _VT]) -> Self: ...\n    @overload\n    def __ror__(self, other: Mapping[_T1, _T2]) -> ChainMap[_KT | _T1, _VT | _T2]: ...\n    # ChainMap.__ior__ should be kept roughly in line with MutableMapping.update()\n    @overload  # type: ignore[misc]\n    def __ior__(self, other: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...\n    @overload\n    def __ior__(self, other: Iterable[tuple[_KT, _VT]]) -> Self: ...\n",
  "/typeshed/stdlib/collections/abc.pyi": "from _collections_abc import *\nfrom _collections_abc import __all__ as __all__\n",
  "/typeshed/stdlib/contextlib.pyi": "import abc\nimport sys\nfrom _typeshed import FileDescriptorOrPath, Unused\nfrom abc import ABC, abstractmethod\nfrom collections.abc import AsyncGenerator, AsyncIterator, Awaitable, Callable, Generator, Iterator\nfrom types import TracebackType\nfrom typing import Any, Generic, Protocol, TypeVar, overload, runtime_checkable, type_check_only\nfrom typing_extensions import ParamSpec, Self, TypeAlias\n\n__all__ = [\n    \"contextmanager\",\n    \"closing\",\n    \"AbstractContextManager\",\n    \"ContextDecorator\",\n    \"ExitStack\",\n    \"redirect_stdout\",\n    \"redirect_stderr\",\n    \"suppress\",\n    \"AbstractAsyncContextManager\",\n    \"AsyncExitStack\",\n    \"asynccontextmanager\",\n    \"nullcontext\",\n]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"aclosing\"]\n\nif sys.version_info >= (3, 11):\n    __all__ += [\"chdir\"]\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_ExitT_co = TypeVar(\"_ExitT_co\", covariant=True, bound=bool | None, default=bool | None)\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n_G_co = TypeVar(\"_G_co\", bound=Generator[Any, Any, Any] | AsyncGenerator[Any, Any], covariant=True)\n_P = ParamSpec(\"_P\")\n\n_SendT_contra = TypeVar(\"_SendT_contra\", contravariant=True, default=None)\n_ReturnT_co = TypeVar(\"_ReturnT_co\", covariant=True, default=None)\n\n_ExitFunc: TypeAlias = Callable[[type[BaseException] | None, BaseException | None, TracebackType | None], bool | None]\n_CM_EF = TypeVar(\"_CM_EF\", bound=AbstractContextManager[Any, Any] | _ExitFunc)\n\n# mypy and pyright object to this being both ABC and Protocol.\n# At runtime it inherits from ABC and is not a Protocol, but it is on the\n# allowlist for use as a Protocol.\n@runtime_checkable\nclass AbstractContextManager(ABC, Protocol[_T_co, _ExitT_co]):  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues]\n    __slots__ = ()\n    def __enter__(self) -> _T_co: ...\n    @abstractmethod\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None, /\n    ) -> _ExitT_co: ...\n\n# mypy and pyright object to this being both ABC and Protocol.\n# At runtime it inherits from ABC and is not a Protocol, but it is on the\n# allowlist for use as a Protocol.\n@runtime_checkable\nclass AbstractAsyncContextManager(ABC, Protocol[_T_co, _ExitT_co]):  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues]\n    __slots__ = ()\n    async def __aenter__(self) -> _T_co: ...\n    @abstractmethod\n    async def __aexit__(\n        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None, /\n    ) -> _ExitT_co: ...\n\nclass ContextDecorator:\n    def _recreate_cm(self) -> Self: ...\n    def __call__(self, func: _F) -> _F: ...\n\nclass _GeneratorContextManagerBase(Generic[_G_co]):\n    # Ideally this would use ParamSpec, but that requires (*args, **kwargs), which this isn't. see #6676\n    def __init__(self, func: Callable[..., _G_co], args: tuple[Any, ...], kwds: dict[str, Any]) -> None: ...\n    gen: _G_co\n    func: Callable[..., _G_co]\n    args: tuple[Any, ...]\n    kwds: dict[str, Any]\n\nclass _GeneratorContextManager(\n    _GeneratorContextManagerBase[Generator[_T_co, _SendT_contra, _ReturnT_co]],\n    AbstractContextManager[_T_co, bool | None],\n    ContextDecorator,\n):\n    def __exit__(\n        self, typ: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n    ) -> bool | None: ...\n\ndef contextmanager(func: Callable[_P, Iterator[_T_co]]) -> Callable[_P, _GeneratorContextManager[_T_co]]: ...\n\nif sys.version_info >= (3, 10):\n    _AF = TypeVar(\"_AF\", bound=Callable[..., Awaitable[Any]])\n\n    class AsyncContextDecorator:\n        def _recreate_cm(self) -> Self: ...\n        def __call__(self, func: _AF) -> _AF: ...\n\n    class _AsyncGeneratorContextManager(\n        _GeneratorContextManagerBase[AsyncGenerator[_T_co, _SendT_contra]],\n        AbstractAsyncContextManager[_T_co, bool | None],\n        AsyncContextDecorator,\n    ):\n        async def __aexit__(\n            self, typ: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n        ) -> bool | None: ...\n\nelse:\n    class _AsyncGeneratorContextManager(\n        _GeneratorContextManagerBase[AsyncGenerator[_T_co, _SendT_contra]], AbstractAsyncContextManager[_T_co, bool | None]\n    ):\n        async def __aexit__(\n            self, typ: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None\n        ) -> bool | None: ...\n\ndef asynccontextmanager(func: Callable[_P, AsyncIterator[_T_co]]) -> Callable[_P, _AsyncGeneratorContextManager[_T_co]]: ...\n@type_check_only\nclass _SupportsClose(Protocol):\n    def close(self) -> object: ...\n\n_SupportsCloseT = TypeVar(\"_SupportsCloseT\", bound=_SupportsClose)\n\nclass closing(AbstractContextManager[_SupportsCloseT, None]):\n    def __init__(self, thing: _SupportsCloseT) -> None: ...\n    def __exit__(self, *exc_info: Unused) -> None: ...\n\nif sys.version_info >= (3, 10):\n    @type_check_only\n    class _SupportsAclose(Protocol):\n        def aclose(self) -> Awaitable[object]: ...\n\n    _SupportsAcloseT = TypeVar(\"_SupportsAcloseT\", bound=_SupportsAclose)\n\n    class aclosing(AbstractAsyncContextManager[_SupportsAcloseT, None]):\n        def __init__(self, thing: _SupportsAcloseT) -> None: ...\n        async def __aexit__(self, *exc_info: Unused) -> None: ...\n\nclass suppress(AbstractContextManager[None, bool]):\n    def __init__(self, *exceptions: type[BaseException]) -> None: ...\n    def __exit__(\n        self, exctype: type[BaseException] | None, excinst: BaseException | None, exctb: TracebackType | None\n    ) -> bool: ...\n\n# This is trying to describe what is needed for (most?) uses\n# of `redirect_stdout` and `redirect_stderr`.\n# https://github.com/python/typeshed/issues/14903\n@type_check_only\nclass _SupportsRedirect(Protocol):\n    def write(self, s: str, /) -> int: ...\n    def flush(self) -> None: ...\n\n_SupportsRedirectT = TypeVar(\"_SupportsRedirectT\", bound=_SupportsRedirect | None)\n\nclass _RedirectStream(AbstractContextManager[_SupportsRedirectT, None]):\n    def __init__(self, new_target: _SupportsRedirectT) -> None: ...\n    def __exit__(\n        self, exctype: type[BaseException] | None, excinst: BaseException | None, exctb: TracebackType | None\n    ) -> None: ...\n\nclass redirect_stdout(_RedirectStream[_SupportsRedirectT]): ...\nclass redirect_stderr(_RedirectStream[_SupportsRedirectT]): ...\n\nclass _BaseExitStack(Generic[_ExitT_co]):\n    def enter_context(self, cm: AbstractContextManager[_T, _ExitT_co]) -> _T: ...\n    def push(self, exit: _CM_EF) -> _CM_EF: ...\n    def callback(self, callback: Callable[_P, _T], /, *args: _P.args, **kwds: _P.kwargs) -> Callable[_P, _T]: ...\n    def pop_all(self) -> Self: ...\n\n# In reality this is a subclass of `AbstractContextManager`;\n# see #7961 for why we don't do that in the stub\nclass ExitStack(_BaseExitStack[_ExitT_co], metaclass=abc.ABCMeta):\n    def close(self) -> None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None, /\n    ) -> _ExitT_co: ...\n\n_ExitCoroFunc: TypeAlias = Callable[\n    [type[BaseException] | None, BaseException | None, TracebackType | None], Awaitable[bool | None]\n]\n_ACM_EF = TypeVar(\"_ACM_EF\", bound=AbstractAsyncContextManager[Any, Any] | _ExitCoroFunc)\n\n# In reality this is a subclass of `AbstractAsyncContextManager`;\n# see #7961 for why we don't do that in the stub\nclass AsyncExitStack(_BaseExitStack[_ExitT_co], metaclass=abc.ABCMeta):\n    async def enter_async_context(self, cm: AbstractAsyncContextManager[_T, _ExitT_co]) -> _T: ...\n    def push_async_exit(self, exit: _ACM_EF) -> _ACM_EF: ...\n    def push_async_callback(\n        self, callback: Callable[_P, Awaitable[_T]], /, *args: _P.args, **kwds: _P.kwargs\n    ) -> Callable[_P, Awaitable[_T]]: ...\n    async def aclose(self) -> None: ...\n    async def __aenter__(self) -> Self: ...\n    async def __aexit__(\n        self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: TracebackType | None, /\n    ) -> _ExitT_co: ...\n\nif sys.version_info >= (3, 10):\n    class nullcontext(AbstractContextManager[_T, None], AbstractAsyncContextManager[_T, None]):\n        enter_result: _T\n        @overload\n        def __init__(self: nullcontext[None], enter_result: None = None) -> None: ...\n        @overload\n        def __init__(self: nullcontext[_T], enter_result: _T) -> None: ...  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n        def __enter__(self) -> _T: ...\n        def __exit__(self, *exctype: Unused) -> None: ...\n        async def __aenter__(self) -> _T: ...\n        async def __aexit__(self, *exctype: Unused) -> None: ...\n\nelse:\n    class nullcontext(AbstractContextManager[_T, None]):\n        enter_result: _T\n        @overload\n        def __init__(self: nullcontext[None], enter_result: None = None) -> None: ...\n        @overload\n        def __init__(self: nullcontext[_T], enter_result: _T) -> None: ...  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n        def __enter__(self) -> _T: ...\n        def __exit__(self, *exctype: Unused) -> None: ...\n\nif sys.version_info >= (3, 11):\n    _T_fd_or_any_path = TypeVar(\"_T_fd_or_any_path\", bound=FileDescriptorOrPath)\n\n    class chdir(AbstractContextManager[None, None], Generic[_T_fd_or_any_path]):\n        path: _T_fd_or_any_path\n        def __init__(self, path: _T_fd_or_any_path) -> None: ...\n        def __enter__(self) -> None: ...\n        def __exit__(self, *excinfo: Unused) -> None: ...\n",
  "/typeshed/stdlib/copy.pyi": "import sys\nfrom typing import Any, Protocol, TypeVar, type_check_only\n\n__all__ = [\"Error\", \"copy\", \"deepcopy\"]\n\n_T = TypeVar(\"_T\")\n_RT_co = TypeVar(\"_RT_co\", covariant=True)\n\n@type_check_only\nclass _SupportsReplace(Protocol[_RT_co]):\n    # In reality doesn't support args, but there's no great way to express this.\n    def __replace__(self, /, *_: Any, **changes: Any) -> _RT_co: ...\n\n# None in CPython but non-None in Jython\nPyStringMap: Any\n\n# Note: memo and _nil are internal kwargs.\ndef deepcopy(x: _T, memo: dict[int, Any] | None = None, _nil: Any = []) -> _T: ...\ndef copy(x: _T) -> _T: ...\n\nif sys.version_info >= (3, 13):\n    __all__ += [\"replace\"]\n    # The types accepted by `**changes` match those of `obj.__replace__`.\n    def replace(obj: _SupportsReplace[_RT_co], /, **changes: Any) -> _RT_co: ...\n\nclass Error(Exception): ...\n\nerror = Error\n",
  "/typeshed/stdlib/copyreg.pyi": "from collections.abc import Callable, Hashable\nfrom typing import Any, SupportsInt, TypeVar\nfrom typing_extensions import TypeAlias\n\n_T = TypeVar(\"_T\")\n_Reduce: TypeAlias = tuple[Callable[..., _T], tuple[Any, ...]] | tuple[Callable[..., _T], tuple[Any, ...], Any | None]\n\n__all__ = [\"pickle\", \"constructor\", \"add_extension\", \"remove_extension\", \"clear_extension_cache\"]\n\ndef pickle(\n    ob_type: type[_T],\n    pickle_function: Callable[[_T], str | _Reduce[_T]],\n    constructor_ob: Callable[[_Reduce[_T]], _T] | None = None,\n) -> None: ...\ndef constructor(object: Callable[[_Reduce[_T]], _T]) -> None: ...\ndef add_extension(module: Hashable, name: Hashable, code: SupportsInt) -> None: ...\ndef remove_extension(module: Hashable, name: Hashable, code: int) -> None: ...\ndef clear_extension_cache() -> None: ...\n\n_DispatchTableType: TypeAlias = dict[type, Callable[[Any], str | _Reduce[Any]]]  # imported by multiprocessing.reduction\ndispatch_table: _DispatchTableType  # undocumented\n",
  "/typeshed/stdlib/dataclasses.pyi": "import enum\nimport sys\nimport types\nfrom _typeshed import DataclassInstance\nfrom builtins import type as Type  # alias to avoid name clashes with fields named \"type\"\nfrom collections.abc import Callable, Iterable, Mapping\nfrom types import GenericAlias\nfrom typing import Any, Final, Generic, Literal, Protocol, TypeVar, overload, type_check_only\nfrom typing_extensions import Never, TypeIs\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n\n__all__ = [\n    \"dataclass\",\n    \"field\",\n    \"Field\",\n    \"FrozenInstanceError\",\n    \"InitVar\",\n    \"MISSING\",\n    \"fields\",\n    \"asdict\",\n    \"astuple\",\n    \"make_dataclass\",\n    \"replace\",\n    \"is_dataclass\",\n]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"KW_ONLY\"]\n\n_DataclassT = TypeVar(\"_DataclassT\", bound=DataclassInstance)\n\n@type_check_only\nclass _DataclassFactory(Protocol):\n    def __call__(\n        self,\n        cls: type[_T],\n        /,\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n        weakref_slot: bool = False,\n    ) -> type[_T]: ...\n\n# define _MISSING_TYPE as an enum within the type stubs,\n# even though that is not really its type at runtime\n# this allows us to use Literal[_MISSING_TYPE.MISSING]\n# for background, see:\n#   https://github.com/python/typeshed/pull/5900#issuecomment-895513797\nclass _MISSING_TYPE(enum.Enum):\n    MISSING = enum.auto()\n\nMISSING: Final = _MISSING_TYPE.MISSING\n\nif sys.version_info >= (3, 10):\n    class KW_ONLY: ...\n\n@overload\ndef asdict(obj: DataclassInstance) -> dict[str, Any]: ...\n@overload\ndef asdict(obj: DataclassInstance, *, dict_factory: Callable[[list[tuple[str, Any]]], _T]) -> _T: ...\n@overload\ndef astuple(obj: DataclassInstance) -> tuple[Any, ...]: ...\n@overload\ndef astuple(obj: DataclassInstance, *, tuple_factory: Callable[[list[Any]], _T]) -> _T: ...\n\nif sys.version_info >= (3, 11):\n    @overload\n    def dataclass(\n        cls: type[_T],\n        /,\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n        weakref_slot: bool = False,\n    ) -> type[_T]: ...\n    @overload\n    def dataclass(\n        cls: None = None,\n        /,\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n        weakref_slot: bool = False,\n    ) -> Callable[[type[_T]], type[_T]]: ...\n\nelif sys.version_info >= (3, 10):\n    @overload\n    def dataclass(\n        cls: type[_T],\n        /,\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n    ) -> type[_T]: ...\n    @overload\n    def dataclass(\n        cls: None = None,\n        /,\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n    ) -> Callable[[type[_T]], type[_T]]: ...\n\nelse:\n    @overload\n    def dataclass(\n        cls: type[_T],\n        /,\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n    ) -> type[_T]: ...\n    @overload\n    def dataclass(\n        cls: None = None,\n        /,\n        *,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n    ) -> Callable[[type[_T]], type[_T]]: ...\n\n# See https://github.com/python/mypy/issues/10750\n@type_check_only\nclass _DefaultFactory(Protocol[_T_co]):\n    def __call__(self) -> _T_co: ...\n\nclass Field(Generic[_T]):\n    if sys.version_info >= (3, 14):\n        __slots__ = (\n            \"name\",\n            \"type\",\n            \"default\",\n            \"default_factory\",\n            \"repr\",\n            \"hash\",\n            \"init\",\n            \"compare\",\n            \"metadata\",\n            \"kw_only\",\n            \"doc\",\n            \"_field_type\",\n        )\n    elif sys.version_info >= (3, 10):\n        __slots__ = (\n            \"name\",\n            \"type\",\n            \"default\",\n            \"default_factory\",\n            \"repr\",\n            \"hash\",\n            \"init\",\n            \"compare\",\n            \"metadata\",\n            \"kw_only\",\n            \"_field_type\",\n        )\n    else:\n        __slots__ = (\"name\", \"type\", \"default\", \"default_factory\", \"repr\", \"hash\", \"init\", \"compare\", \"metadata\", \"_field_type\")\n    name: str\n    type: Type[_T] | str | Any\n    default: _T | Literal[_MISSING_TYPE.MISSING]\n    default_factory: _DefaultFactory[_T] | Literal[_MISSING_TYPE.MISSING]\n    repr: bool\n    hash: bool | None\n    init: bool\n    compare: bool\n    metadata: types.MappingProxyType[Any, Any]\n\n    if sys.version_info >= (3, 14):\n        doc: str | None\n\n    if sys.version_info >= (3, 10):\n        kw_only: bool | Literal[_MISSING_TYPE.MISSING]\n\n    if sys.version_info >= (3, 14):\n        def __init__(\n            self,\n            default: _T,\n            default_factory: Callable[[], _T],\n            init: bool,\n            repr: bool,\n            hash: bool | None,\n            compare: bool,\n            metadata: Mapping[Any, Any],\n            kw_only: bool,\n            doc: str | None,\n        ) -> None: ...\n    elif sys.version_info >= (3, 10):\n        def __init__(\n            self,\n            default: _T,\n            default_factory: Callable[[], _T],\n            init: bool,\n            repr: bool,\n            hash: bool | None,\n            compare: bool,\n            metadata: Mapping[Any, Any],\n            kw_only: bool,\n        ) -> None: ...\n    else:\n        def __init__(\n            self,\n            default: _T,\n            default_factory: Callable[[], _T],\n            init: bool,\n            repr: bool,\n            hash: bool | None,\n            compare: bool,\n            metadata: Mapping[Any, Any],\n        ) -> None: ...\n\n    def __set_name__(self, owner: Type[Any], name: str) -> None: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n# NOTE: Actual return type is 'Field[_T]', but we want to help type checkers\n# to understand the magic that happens at runtime.\nif sys.version_info >= (3, 14):\n    @overload  # `default` and `default_factory` are optional and mutually exclusive.\n    def field(\n        *,\n        default: _T,\n        default_factory: Literal[_MISSING_TYPE.MISSING] = ...,\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n        kw_only: bool | Literal[_MISSING_TYPE.MISSING] = ...,\n        doc: str | None = None,\n    ) -> _T: ...\n    @overload\n    def field(\n        *,\n        default: Literal[_MISSING_TYPE.MISSING] = ...,\n        default_factory: Callable[[], _T],\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n        kw_only: bool | Literal[_MISSING_TYPE.MISSING] = ...,\n        doc: str | None = None,\n    ) -> _T: ...\n    @overload\n    def field(\n        *,\n        default: Literal[_MISSING_TYPE.MISSING] = ...,\n        default_factory: Literal[_MISSING_TYPE.MISSING] = ...,\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n        kw_only: bool | Literal[_MISSING_TYPE.MISSING] = ...,\n        doc: str | None = None,\n    ) -> Any: ...\n\nelif sys.version_info >= (3, 10):\n    @overload  # `default` and `default_factory` are optional and mutually exclusive.\n    def field(\n        *,\n        default: _T,\n        default_factory: Literal[_MISSING_TYPE.MISSING] = ...,\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n        kw_only: bool | Literal[_MISSING_TYPE.MISSING] = ...,\n    ) -> _T: ...\n    @overload\n    def field(\n        *,\n        default: Literal[_MISSING_TYPE.MISSING] = ...,\n        default_factory: Callable[[], _T],\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n        kw_only: bool | Literal[_MISSING_TYPE.MISSING] = ...,\n    ) -> _T: ...\n    @overload\n    def field(\n        *,\n        default: Literal[_MISSING_TYPE.MISSING] = ...,\n        default_factory: Literal[_MISSING_TYPE.MISSING] = ...,\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n        kw_only: bool | Literal[_MISSING_TYPE.MISSING] = ...,\n    ) -> Any: ...\n\nelse:\n    @overload  # `default` and `default_factory` are optional and mutually exclusive.\n    def field(\n        *,\n        default: _T,\n        default_factory: Literal[_MISSING_TYPE.MISSING] = ...,\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n    ) -> _T: ...\n    @overload\n    def field(\n        *,\n        default: Literal[_MISSING_TYPE.MISSING] = ...,\n        default_factory: Callable[[], _T],\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n    ) -> _T: ...\n    @overload\n    def field(\n        *,\n        default: Literal[_MISSING_TYPE.MISSING] = ...,\n        default_factory: Literal[_MISSING_TYPE.MISSING] = ...,\n        init: bool = True,\n        repr: bool = True,\n        hash: bool | None = None,\n        compare: bool = True,\n        metadata: Mapping[Any, Any] | None = None,\n    ) -> Any: ...\n\ndef fields(class_or_instance: DataclassInstance | type[DataclassInstance]) -> tuple[Field[Any], ...]: ...\n\n# HACK: `obj: Never` typing matches if object argument is using `Any` type.\n@overload\ndef is_dataclass(obj: Never) -> TypeIs[DataclassInstance | type[DataclassInstance]]: ...  # type: ignore[narrowed-type-not-subtype]  # pyright: ignore[reportGeneralTypeIssues]\n@overload\ndef is_dataclass(obj: type) -> TypeIs[type[DataclassInstance]]: ...\n@overload\ndef is_dataclass(obj: object) -> TypeIs[DataclassInstance | type[DataclassInstance]]: ...\n\nclass FrozenInstanceError(AttributeError): ...\n\nclass InitVar(Generic[_T]):\n    __slots__ = (\"type\",)\n    type: Type[_T]\n    def __init__(self, type: Type[_T]) -> None: ...\n    @overload\n    def __class_getitem__(cls, type: Type[_T]) -> InitVar[_T]: ...  # pyright: ignore[reportInvalidTypeForm]\n    @overload\n    def __class_getitem__(cls, type: Any) -> InitVar[Any]: ...  # pyright: ignore[reportInvalidTypeForm]\n\nif sys.version_info >= (3, 14):\n    def make_dataclass(\n        cls_name: str,\n        fields: Iterable[str | tuple[str, Any] | tuple[str, Any, Any]],\n        *,\n        bases: tuple[type, ...] = (),\n        namespace: dict[str, Any] | None = None,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n        weakref_slot: bool = False,\n        module: str | None = None,\n        decorator: _DataclassFactory = ...,\n    ) -> type: ...\n\nelif sys.version_info >= (3, 12):\n    def make_dataclass(\n        cls_name: str,\n        fields: Iterable[str | tuple[str, Any] | tuple[str, Any, Any]],\n        *,\n        bases: tuple[type, ...] = (),\n        namespace: dict[str, Any] | None = None,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n        weakref_slot: bool = False,\n        module: str | None = None,\n    ) -> type: ...\n\nelif sys.version_info >= (3, 11):\n    def make_dataclass(\n        cls_name: str,\n        fields: Iterable[str | tuple[str, Any] | tuple[str, Any, Any]],\n        *,\n        bases: tuple[type, ...] = (),\n        namespace: dict[str, Any] | None = None,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n        weakref_slot: bool = False,\n    ) -> type: ...\n\nelif sys.version_info >= (3, 10):\n    def make_dataclass(\n        cls_name: str,\n        fields: Iterable[str | tuple[str, Any] | tuple[str, Any, Any]],\n        *,\n        bases: tuple[type, ...] = (),\n        namespace: dict[str, Any] | None = None,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n        match_args: bool = True,\n        kw_only: bool = False,\n        slots: bool = False,\n    ) -> type: ...\n\nelse:\n    def make_dataclass(\n        cls_name: str,\n        fields: Iterable[str | tuple[str, Any] | tuple[str, Any, Any]],\n        *,\n        bases: tuple[type, ...] = (),\n        namespace: dict[str, Any] | None = None,\n        init: bool = True,\n        repr: bool = True,\n        eq: bool = True,\n        order: bool = False,\n        unsafe_hash: bool = False,\n        frozen: bool = False,\n    ) -> type: ...\n\ndef replace(obj: _DataclassT, /, **changes: Any) -> _DataclassT: ...\n",
  "/typeshed/stdlib/datetime.pyi": "import sys\nfrom abc import abstractmethod\nfrom time import struct_time\nfrom typing import ClassVar, Final, NoReturn, SupportsIndex, final, overload, type_check_only\nfrom typing_extensions import CapsuleType, Self, TypeAlias, deprecated, disjoint_base\n\nif sys.version_info >= (3, 11):\n    __all__ = (\"date\", \"datetime\", \"time\", \"timedelta\", \"timezone\", \"tzinfo\", \"MINYEAR\", \"MAXYEAR\", \"UTC\")\nelse:\n    __all__ = (\"date\", \"datetime\", \"time\", \"timedelta\", \"timezone\", \"tzinfo\", \"MINYEAR\", \"MAXYEAR\")\n\nMINYEAR: Final = 1\nMAXYEAR: Final = 9999\n\nclass tzinfo:\n    @abstractmethod\n    def tzname(self, dt: datetime | None, /) -> str | None: ...\n    @abstractmethod\n    def utcoffset(self, dt: datetime | None, /) -> timedelta | None: ...\n    @abstractmethod\n    def dst(self, dt: datetime | None, /) -> timedelta | None: ...\n    def fromutc(self, dt: datetime, /) -> datetime: ...\n\n# Alias required to avoid name conflicts with date(time).tzinfo.\n_TzInfo: TypeAlias = tzinfo\n\n@final\nclass timezone(tzinfo):\n    utc: ClassVar[timezone]\n    min: ClassVar[timezone]\n    max: ClassVar[timezone]\n    def __new__(cls, offset: timedelta, name: str = ...) -> Self: ...\n    def tzname(self, dt: datetime | None, /) -> str: ...\n    def utcoffset(self, dt: datetime | None, /) -> timedelta: ...\n    def dst(self, dt: datetime | None, /) -> None: ...\n    def __hash__(self) -> int: ...\n    def __eq__(self, value: object, /) -> bool: ...\n\nif sys.version_info >= (3, 11):\n    UTC: timezone\n\n# This class calls itself datetime.IsoCalendarDate. It's neither\n# NamedTuple nor structseq.\n@final\n@type_check_only\nclass _IsoCalendarDate(tuple[int, int, int]):\n    @property\n    def year(self) -> int: ...\n    @property\n    def week(self) -> int: ...\n    @property\n    def weekday(self) -> int: ...\n\n@disjoint_base\nclass date:\n    min: ClassVar[date]\n    max: ClassVar[date]\n    resolution: ClassVar[timedelta]\n    def __new__(cls, year: SupportsIndex, month: SupportsIndex, day: SupportsIndex) -> Self: ...\n    @classmethod\n    def fromtimestamp(cls, timestamp: float, /) -> Self: ...\n    @classmethod\n    def today(cls) -> Self: ...\n    @classmethod\n    def fromordinal(cls, n: int, /) -> Self: ...\n    @classmethod\n    def fromisoformat(cls, date_string: str, /) -> Self: ...\n    @classmethod\n    def fromisocalendar(cls, year: int, week: int, day: int) -> Self: ...\n    @property\n    def year(self) -> int: ...\n    @property\n    def month(self) -> int: ...\n    @property\n    def day(self) -> int: ...\n    def ctime(self) -> str: ...\n\n    if sys.version_info >= (3, 14):\n        @classmethod\n        def strptime(cls, date_string: str, format: str, /) -> Self: ...\n\n    # On <3.12, the name of the parameter in the pure-Python implementation\n    # didn't match the name in the C implementation,\n    # meaning it is only *safe* to pass it as a keyword argument on 3.12+\n    if sys.version_info >= (3, 12):\n        def strftime(self, format: str) -> str: ...\n    else:\n        def strftime(self, format: str, /) -> str: ...\n\n    def __format__(self, fmt: str, /) -> str: ...\n    def isoformat(self) -> str: ...\n    def timetuple(self) -> struct_time: ...\n    def toordinal(self) -> int: ...\n    if sys.version_info >= (3, 13):\n        def __replace__(self, /, *, year: SupportsIndex = ..., month: SupportsIndex = ..., day: SupportsIndex = ...) -> Self: ...\n\n    def replace(self, year: SupportsIndex = ..., month: SupportsIndex = ..., day: SupportsIndex = ...) -> Self: ...\n    def __le__(self, value: date, /) -> bool: ...\n    def __lt__(self, value: date, /) -> bool: ...\n    def __ge__(self, value: date, /) -> bool: ...\n    def __gt__(self, value: date, /) -> bool: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __add__(self, value: timedelta, /) -> Self: ...\n    def __radd__(self, value: timedelta, /) -> Self: ...\n    @overload\n    def __sub__(self, value: datetime, /) -> NoReturn: ...\n    @overload\n    def __sub__(self, value: Self, /) -> timedelta: ...\n    @overload\n    def __sub__(self, value: timedelta, /) -> Self: ...\n    def __hash__(self) -> int: ...\n    def weekday(self) -> int: ...\n    def isoweekday(self) -> int: ...\n    def isocalendar(self) -> _IsoCalendarDate: ...\n\n@disjoint_base\nclass time:\n    min: ClassVar[time]\n    max: ClassVar[time]\n    resolution: ClassVar[timedelta]\n    def __new__(\n        cls,\n        hour: SupportsIndex = 0,\n        minute: SupportsIndex = 0,\n        second: SupportsIndex = 0,\n        microsecond: SupportsIndex = 0,\n        tzinfo: _TzInfo | None = None,\n        *,\n        fold: int = 0,\n    ) -> Self: ...\n    @property\n    def hour(self) -> int: ...\n    @property\n    def minute(self) -> int: ...\n    @property\n    def second(self) -> int: ...\n    @property\n    def microsecond(self) -> int: ...\n    @property\n    def tzinfo(self) -> _TzInfo | None: ...\n    @property\n    def fold(self) -> int: ...\n    def __le__(self, value: time, /) -> bool: ...\n    def __lt__(self, value: time, /) -> bool: ...\n    def __ge__(self, value: time, /) -> bool: ...\n    def __gt__(self, value: time, /) -> bool: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n    def isoformat(self, timespec: str = \"auto\") -> str: ...\n    @classmethod\n    def fromisoformat(cls, time_string: str, /) -> Self: ...\n\n    if sys.version_info >= (3, 14):\n        @classmethod\n        def strptime(cls, date_string: str, format: str, /) -> Self: ...\n\n    # On <3.12, the name of the parameter in the pure-Python implementation\n    # didn't match the name in the C implementation,\n    # meaning it is only *safe* to pass it as a keyword argument on 3.12+\n    if sys.version_info >= (3, 12):\n        def strftime(self, format: str) -> str: ...\n    else:\n        def strftime(self, format: str, /) -> str: ...\n\n    def __format__(self, fmt: str, /) -> str: ...\n    def utcoffset(self) -> timedelta | None: ...\n    def tzname(self) -> str | None: ...\n    def dst(self) -> timedelta | None: ...\n    if sys.version_info >= (3, 13):\n        def __replace__(\n            self,\n            /,\n            *,\n            hour: SupportsIndex = ...,\n            minute: SupportsIndex = ...,\n            second: SupportsIndex = ...,\n            microsecond: SupportsIndex = ...,\n            tzinfo: _TzInfo | None = ...,\n            fold: int = ...,\n        ) -> Self: ...\n\n    def replace(\n        self,\n        hour: SupportsIndex = ...,\n        minute: SupportsIndex = ...,\n        second: SupportsIndex = ...,\n        microsecond: SupportsIndex = ...,\n        tzinfo: _TzInfo | None = ...,\n        *,\n        fold: int = ...,\n    ) -> Self: ...\n\n_Date: TypeAlias = date\n_Time: TypeAlias = time\n\n@disjoint_base\nclass timedelta:\n    min: ClassVar[timedelta]\n    max: ClassVar[timedelta]\n    resolution: ClassVar[timedelta]\n    def __new__(\n        cls,\n        days: float = 0,\n        seconds: float = 0,\n        microseconds: float = 0,\n        milliseconds: float = 0,\n        minutes: float = 0,\n        hours: float = 0,\n        weeks: float = 0,\n    ) -> Self: ...\n    @property\n    def days(self) -> int: ...\n    @property\n    def seconds(self) -> int: ...\n    @property\n    def microseconds(self) -> int: ...\n    def total_seconds(self) -> float: ...\n    def __add__(self, value: timedelta, /) -> timedelta: ...\n    def __radd__(self, value: timedelta, /) -> timedelta: ...\n    def __sub__(self, value: timedelta, /) -> timedelta: ...\n    def __rsub__(self, value: timedelta, /) -> timedelta: ...\n    def __neg__(self) -> timedelta: ...\n    def __pos__(self) -> timedelta: ...\n    def __abs__(self) -> timedelta: ...\n    def __mul__(self, value: float, /) -> timedelta: ...\n    def __rmul__(self, value: float, /) -> timedelta: ...\n    @overload\n    def __floordiv__(self, value: timedelta, /) -> int: ...\n    @overload\n    def __floordiv__(self, value: int, /) -> timedelta: ...\n    @overload\n    def __truediv__(self, value: timedelta, /) -> float: ...\n    @overload\n    def __truediv__(self, value: float, /) -> timedelta: ...\n    def __mod__(self, value: timedelta, /) -> timedelta: ...\n    def __divmod__(self, value: timedelta, /) -> tuple[int, timedelta]: ...\n    def __le__(self, value: timedelta, /) -> bool: ...\n    def __lt__(self, value: timedelta, /) -> bool: ...\n    def __ge__(self, value: timedelta, /) -> bool: ...\n    def __gt__(self, value: timedelta, /) -> bool: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __bool__(self) -> bool: ...\n    def __hash__(self) -> int: ...\n\n@disjoint_base\nclass datetime(date):\n    min: ClassVar[datetime]\n    max: ClassVar[datetime]\n    def __new__(\n        cls,\n        year: SupportsIndex,\n        month: SupportsIndex,\n        day: SupportsIndex,\n        hour: SupportsIndex = 0,\n        minute: SupportsIndex = 0,\n        second: SupportsIndex = 0,\n        microsecond: SupportsIndex = 0,\n        tzinfo: _TzInfo | None = None,\n        *,\n        fold: int = 0,\n    ) -> Self: ...\n    @property\n    def hour(self) -> int: ...\n    @property\n    def minute(self) -> int: ...\n    @property\n    def second(self) -> int: ...\n    @property\n    def microsecond(self) -> int: ...\n    @property\n    def tzinfo(self) -> _TzInfo | None: ...\n    @property\n    def fold(self) -> int: ...\n    # On <3.12, the name of the first parameter in the pure-Python implementation\n    # didn't match the name in the C implementation,\n    # meaning it is only *safe* to pass it as a keyword argument on 3.12+\n    if sys.version_info >= (3, 12):\n        @classmethod\n        def fromtimestamp(cls, timestamp: float, tz: _TzInfo | None = None) -> Self: ...\n    else:\n        @classmethod\n        def fromtimestamp(cls, timestamp: float, /, tz: _TzInfo | None = None) -> Self: ...\n\n    @classmethod\n    @deprecated(\"Use timezone-aware objects to represent datetimes in UTC; e.g. by calling .fromtimestamp(datetime.timezone.utc)\")\n    def utcfromtimestamp(cls, t: float, /) -> Self: ...\n    @classmethod\n    def now(cls, tz: _TzInfo | None = None) -> Self: ...\n    @classmethod\n    @deprecated(\"Use timezone-aware objects to represent datetimes in UTC; e.g. by calling .now(datetime.timezone.utc)\")\n    def utcnow(cls) -> Self: ...\n    @classmethod\n    def combine(cls, date: _Date, time: _Time, tzinfo: _TzInfo | None = ...) -> Self: ...\n    def timestamp(self) -> float: ...\n    def utctimetuple(self) -> struct_time: ...\n    def date(self) -> _Date: ...\n    def time(self) -> _Time: ...\n    def timetz(self) -> _Time: ...\n    if sys.version_info >= (3, 13):\n        def __replace__(\n            self,\n            /,\n            *,\n            year: SupportsIndex = ...,\n            month: SupportsIndex = ...,\n            day: SupportsIndex = ...,\n            hour: SupportsIndex = ...,\n            minute: SupportsIndex = ...,\n            second: SupportsIndex = ...,\n            microsecond: SupportsIndex = ...,\n            tzinfo: _TzInfo | None = ...,\n            fold: int = ...,\n        ) -> Self: ...\n\n    def replace(\n        self,\n        year: SupportsIndex = ...,\n        month: SupportsIndex = ...,\n        day: SupportsIndex = ...,\n        hour: SupportsIndex = ...,\n        minute: SupportsIndex = ...,\n        second: SupportsIndex = ...,\n        microsecond: SupportsIndex = ...,\n        tzinfo: _TzInfo | None = ...,\n        *,\n        fold: int = ...,\n    ) -> Self: ...\n    def astimezone(self, tz: _TzInfo | None = None) -> Self: ...\n    def isoformat(self, sep: str = \"T\", timespec: str = \"auto\") -> str: ...\n    @classmethod\n    def strptime(cls, date_string: str, format: str, /) -> Self: ...\n    def utcoffset(self) -> timedelta | None: ...\n    def tzname(self) -> str | None: ...\n    def dst(self) -> timedelta | None: ...\n    def __le__(self, value: datetime, /) -> bool: ...  # type: ignore[override]\n    def __lt__(self, value: datetime, /) -> bool: ...  # type: ignore[override]\n    def __ge__(self, value: datetime, /) -> bool: ...  # type: ignore[override]\n    def __gt__(self, value: datetime, /) -> bool: ...  # type: ignore[override]\n    def __eq__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n    @overload  # type: ignore[override]\n    def __sub__(self, value: Self, /) -> timedelta: ...\n    @overload\n    def __sub__(self, value: timedelta, /) -> Self: ...\n\ndatetime_CAPI: CapsuleType\n",
  "/typeshed/stdlib/enum.pyi": "import _typeshed\nimport sys\nimport types\nfrom _typeshed import SupportsKeysAndGetItem, Unused\nfrom builtins import property as _builtins_property\nfrom collections.abc import Callable, Iterable, Iterator, Mapping\nfrom typing import Any, Final, Generic, Literal, TypeVar, overload\nfrom typing_extensions import Self, TypeAlias, disjoint_base\n\n__all__ = [\"EnumMeta\", \"Enum\", \"IntEnum\", \"Flag\", \"IntFlag\", \"auto\", \"unique\"]\n\nif sys.version_info >= (3, 11):\n    __all__ += [\n        \"CONFORM\",\n        \"CONTINUOUS\",\n        \"EJECT\",\n        \"EnumCheck\",\n        \"EnumType\",\n        \"FlagBoundary\",\n        \"KEEP\",\n        \"NAMED_FLAGS\",\n        \"ReprEnum\",\n        \"STRICT\",\n        \"StrEnum\",\n        \"UNIQUE\",\n        \"global_enum\",\n        \"global_enum_repr\",\n        \"global_flag_repr\",\n        \"global_str\",\n        \"member\",\n        \"nonmember\",\n        \"property\",\n        \"verify\",\n        \"pickle_by_enum_name\",\n        \"pickle_by_global_name\",\n    ]\n\nif sys.version_info >= (3, 13):\n    __all__ += [\"EnumDict\"]\n\n_EnumMemberT = TypeVar(\"_EnumMemberT\")\n_EnumerationT = TypeVar(\"_EnumerationT\", bound=type[Enum])\n\n# The following all work:\n# >>> from enum import Enum\n# >>> from string import ascii_lowercase\n# >>> Enum('Foo', names='RED YELLOW GREEN')\n# <enum 'Foo'>\n# >>> Enum('Foo', names=[('RED', 1), ('YELLOW, 2)])\n# <enum 'Foo'>\n# >>> Enum('Foo', names=((x for x in (ascii_lowercase[i], i)) for i in range(5)))\n# <enum 'Foo'>\n# >>> Enum('Foo', names={'RED': 1, 'YELLOW': 2})\n# <enum 'Foo'>\n_EnumNames: TypeAlias = str | Iterable[str] | Iterable[Iterable[str | Any]] | Mapping[str, Any]\n_Signature: TypeAlias = Any  # TODO: Unable to import Signature from inspect module\n\nif sys.version_info >= (3, 11):\n    class nonmember(Generic[_EnumMemberT]):\n        value: _EnumMemberT\n        def __init__(self, value: _EnumMemberT) -> None: ...\n\n    class member(Generic[_EnumMemberT]):\n        value: _EnumMemberT\n        def __init__(self, value: _EnumMemberT) -> None: ...\n\nclass _EnumDict(dict[str, Any]):\n    if sys.version_info >= (3, 13):\n        def __init__(self, cls_name: str | None = None) -> None: ...\n    else:\n        def __init__(self) -> None: ...\n\n    def __setitem__(self, key: str, value: Any) -> None: ...\n    if sys.version_info >= (3, 11):\n        # See comment above `typing.MutableMapping.update`\n        # for why overloads are preferable to a Union here\n        #\n        # Unlike with MutableMapping.update(), the first argument is required,\n        # hence the type: ignore\n        @overload  # type: ignore[override]\n        def update(self, members: SupportsKeysAndGetItem[str, Any], **more_members: Any) -> None: ...\n        @overload\n        def update(self, members: Iterable[tuple[str, Any]], **more_members: Any) -> None: ...\n    if sys.version_info >= (3, 13):\n        @property\n        def member_names(self) -> list[str]: ...\n\nif sys.version_info >= (3, 13):\n    EnumDict = _EnumDict\n\n# Structurally: Iterable[T], Reversible[T], Container[T] where T is the enum itself\nclass EnumMeta(type):\n    if sys.version_info >= (3, 11):\n        def __new__(\n            metacls: type[_typeshed.Self],\n            cls: str,\n            bases: tuple[type, ...],\n            classdict: _EnumDict,\n            *,\n            boundary: FlagBoundary | None = None,\n            _simple: bool = False,\n            **kwds: Any,\n        ) -> _typeshed.Self: ...\n    else:\n        def __new__(\n            metacls: type[_typeshed.Self], cls: str, bases: tuple[type, ...], classdict: _EnumDict, **kwds: Any\n        ) -> _typeshed.Self: ...\n\n    @classmethod\n    def __prepare__(metacls, cls: str, bases: tuple[type, ...], **kwds: Any) -> _EnumDict: ...  # type: ignore[override]\n    def __iter__(self: type[_EnumMemberT]) -> Iterator[_EnumMemberT]: ...\n    def __reversed__(self: type[_EnumMemberT]) -> Iterator[_EnumMemberT]: ...\n    if sys.version_info >= (3, 12):\n        def __contains__(self: type[Any], value: object) -> bool: ...\n    elif sys.version_info >= (3, 11):\n        def __contains__(self: type[Any], member: object) -> bool: ...\n    elif sys.version_info >= (3, 10):\n        def __contains__(self: type[Any], obj: object) -> bool: ...\n    else:\n        def __contains__(self: type[Any], member: object) -> bool: ...\n\n    def __getitem__(self: type[_EnumMemberT], name: str) -> _EnumMemberT: ...\n    @_builtins_property\n    def __members__(self: type[_EnumMemberT]) -> types.MappingProxyType[str, _EnumMemberT]: ...\n    def __len__(self) -> int: ...\n    def __bool__(self) -> Literal[True]: ...\n    def __dir__(self) -> list[str]: ...\n\n    # Overload 1: Value lookup on an already existing enum class (simple case)\n    @overload\n    def __call__(cls: type[_EnumMemberT], value: Any, names: None = None) -> _EnumMemberT: ...\n\n    # Overload 2: Functional API for constructing new enum classes.\n    if sys.version_info >= (3, 11):\n        @overload\n        def __call__(\n            cls,\n            value: str,\n            names: _EnumNames,\n            *,\n            module: str | None = None,\n            qualname: str | None = None,\n            type: type | None = None,\n            start: int = 1,\n            boundary: FlagBoundary | None = None,\n        ) -> type[Enum]: ...\n    else:\n        @overload\n        def __call__(\n            cls,\n            value: str,\n            names: _EnumNames,\n            *,\n            module: str | None = None,\n            qualname: str | None = None,\n            type: type | None = None,\n            start: int = 1,\n        ) -> type[Enum]: ...\n\n    # Overload 3 (py312+ only): Value lookup on an already existing enum class (complex case)\n    #\n    # >>> class Foo(enum.Enum):\n    # ...     X = 1, 2, 3\n    # >>> Foo(1, 2, 3)\n    # <Foo.X: (1, 2, 3)>\n    #\n    if sys.version_info >= (3, 12):\n        @overload\n        def __call__(cls: type[_EnumMemberT], value: Any, *values: Any) -> _EnumMemberT: ...\n    if sys.version_info >= (3, 14):\n        @property\n        def __signature__(cls) -> _Signature: ...\n\n    _member_names_: list[str]  # undocumented\n    _member_map_: dict[str, Enum]  # undocumented\n    _value2member_map_: dict[Any, Enum]  # undocumented\n\nif sys.version_info >= (3, 11):\n    # In 3.11 `EnumMeta` metaclass is renamed to `EnumType`, but old name also exists.\n    EnumType = EnumMeta\n\n    class property(types.DynamicClassAttribute):\n        def __set_name__(self, ownerclass: type[Enum], name: str) -> None: ...\n        name: str\n        clsname: str\n        member: Enum | None\n\n    _magic_enum_attr = property\nelse:\n    _magic_enum_attr = types.DynamicClassAttribute\n\nclass Enum(metaclass=EnumMeta):\n    @_magic_enum_attr\n    def name(self) -> str: ...\n    @_magic_enum_attr\n    def value(self) -> Any: ...\n    _name_: str\n    _value_: Any\n    _ignore_: str | list[str]\n    _order_: str\n    __order__: str\n    @classmethod\n    def _missing_(cls, value: object) -> Any: ...\n    @staticmethod\n    def _generate_next_value_(name: str, start: int, count: int, last_values: list[Any]) -> Any: ...\n    # It's not true that `__new__` will accept any argument type,\n    # so ideally we'd use `Any` to indicate that the argument type is inexpressible.\n    # However, using `Any` causes too many false-positives for those using mypy's `--disallow-any-expr`\n    # (see #7752, #2539, mypy/#5788),\n    # and in practice using `object` here has the same effect as using `Any`.\n    def __new__(cls, value: object) -> Self: ...\n    def __dir__(self) -> list[str]: ...\n    def __hash__(self) -> int: ...\n    def __format__(self, format_spec: str) -> str: ...\n    def __reduce_ex__(self, proto: Unused) -> tuple[Any, ...]: ...\n    if sys.version_info >= (3, 11):\n        def __copy__(self) -> Self: ...\n        def __deepcopy__(self, memo: Any) -> Self: ...\n    if sys.version_info >= (3, 12) and sys.version_info < (3, 14):\n        @classmethod\n        def __signature__(cls) -> str: ...\n    if sys.version_info >= (3, 13):\n        # Value may be any type, even in special enums. Enabling Enum parsing from\n        # multiple value types\n        def _add_value_alias_(self, value: Any) -> None: ...\n        def _add_alias_(self, name: str) -> None: ...\n\nif sys.version_info >= (3, 11):\n    class ReprEnum(Enum): ...\n\nif sys.version_info >= (3, 12):\n    class IntEnum(int, ReprEnum):\n        _value_: int\n        @_magic_enum_attr\n        def value(self) -> int: ...\n        def __new__(cls, value: int) -> Self: ...\n\nelse:\n    if sys.version_info >= (3, 11):\n        _IntEnumBase = ReprEnum\n    else:\n        _IntEnumBase = Enum\n\n    @disjoint_base\n    class IntEnum(int, _IntEnumBase):\n        _value_: int\n        @_magic_enum_attr\n        def value(self) -> int: ...\n        def __new__(cls, value: int) -> Self: ...\n\ndef unique(enumeration: _EnumerationT) -> _EnumerationT: ...\n\n_auto_null: Any\n\nclass Flag(Enum):\n    _name_: str | None  # type: ignore[assignment]\n    _value_: int\n    _numeric_repr_: Callable[[int], str]\n    @_magic_enum_attr\n    def name(self) -> str | None: ...  # type: ignore[override]\n    @_magic_enum_attr\n    def value(self) -> int: ...\n    def __contains__(self, other: Self) -> bool: ...\n    def __bool__(self) -> bool: ...\n    def __or__(self, other: Self) -> Self: ...\n    def __and__(self, other: Self) -> Self: ...\n    def __xor__(self, other: Self) -> Self: ...\n    def __invert__(self) -> Self: ...\n    if sys.version_info >= (3, 11):\n        def __iter__(self) -> Iterator[Self]: ...\n        def __len__(self) -> int: ...\n        __ror__ = __or__\n        __rand__ = __and__\n        __rxor__ = __xor__\n\nif sys.version_info >= (3, 11):\n    class StrEnum(str, ReprEnum):\n        def __new__(cls, value: str) -> Self: ...\n        _value_: str\n        @_magic_enum_attr\n        def value(self) -> str: ...\n        @staticmethod\n        def _generate_next_value_(name: str, start: int, count: int, last_values: list[str]) -> str: ...\n\n    class EnumCheck(StrEnum):\n        CONTINUOUS = \"no skipped integer values\"\n        NAMED_FLAGS = \"multi-flag aliases may not contain unnamed flags\"\n        UNIQUE = \"one name per value\"\n\n    CONTINUOUS: Final = EnumCheck.CONTINUOUS\n    NAMED_FLAGS: Final = EnumCheck.NAMED_FLAGS\n    UNIQUE: Final = EnumCheck.UNIQUE\n\n    class verify:\n        def __init__(self, *checks: EnumCheck) -> None: ...\n        def __call__(self, enumeration: _EnumerationT) -> _EnumerationT: ...\n\n    class FlagBoundary(StrEnum):\n        STRICT = \"strict\"\n        CONFORM = \"conform\"\n        EJECT = \"eject\"\n        KEEP = \"keep\"\n\n    STRICT: Final = FlagBoundary.STRICT\n    CONFORM: Final = FlagBoundary.CONFORM\n    EJECT: Final = FlagBoundary.EJECT\n    KEEP: Final = FlagBoundary.KEEP\n\n    def global_str(self: Enum) -> str: ...\n    def global_enum(cls: _EnumerationT, update_str: bool = False) -> _EnumerationT: ...\n    def global_enum_repr(self: Enum) -> str: ...\n    def global_flag_repr(self: Flag) -> str: ...\n    def show_flag_values(value: int) -> list[int]: ...\n\nif sys.version_info >= (3, 12):\n    # The body of the class is the same, but the base classes are different.\n    class IntFlag(int, ReprEnum, Flag, boundary=KEEP):  # type: ignore[misc]  # complaints about incompatible bases\n        def __new__(cls, value: int) -> Self: ...\n        def __or__(self, other: int) -> Self: ...\n        def __and__(self, other: int) -> Self: ...\n        def __xor__(self, other: int) -> Self: ...\n        def __invert__(self) -> Self: ...\n        __ror__ = __or__\n        __rand__ = __and__\n        __rxor__ = __xor__\n\nelif sys.version_info >= (3, 11):\n    # The body of the class is the same, but the base classes are different.\n    @disjoint_base\n    class IntFlag(int, ReprEnum, Flag, boundary=KEEP):  # type: ignore[misc]  # complaints about incompatible bases\n        def __new__(cls, value: int) -> Self: ...\n        def __or__(self, other: int) -> Self: ...\n        def __and__(self, other: int) -> Self: ...\n        def __xor__(self, other: int) -> Self: ...\n        def __invert__(self) -> Self: ...\n        __ror__ = __or__\n        __rand__ = __and__\n        __rxor__ = __xor__\n\nelse:\n    @disjoint_base\n    class IntFlag(int, Flag):  # type: ignore[misc]  # complaints about incompatible bases\n        def __new__(cls, value: int) -> Self: ...\n        def __or__(self, other: int) -> Self: ...\n        def __and__(self, other: int) -> Self: ...\n        def __xor__(self, other: int) -> Self: ...\n        def __invert__(self) -> Self: ...\n        __ror__ = __or__\n        __rand__ = __and__\n        __rxor__ = __xor__\n\nclass auto:\n    _value_: Any\n    @_magic_enum_attr\n    def value(self) -> Any: ...\n    def __new__(cls) -> Self: ...\n\n    # These don't exist, but auto is basically immediately replaced with\n    # either an int or a str depending on the type of the enum. StrEnum's auto\n    # shouldn't have these, but they're needed for int versions of auto (mostly the __or__).\n    # Ideally type checkers would special case auto enough to handle this,\n    # but until then this is a slightly inaccurate helping hand.\n    def __or__(self, other: int | Self) -> Self: ...\n    def __and__(self, other: int | Self) -> Self: ...\n    def __xor__(self, other: int | Self) -> Self: ...\n    __ror__ = __or__\n    __rand__ = __and__\n    __rxor__ = __xor__\n\nif sys.version_info >= (3, 11):\n    def pickle_by_global_name(self: Enum, proto: int) -> str: ...\n    def pickle_by_enum_name(self: _EnumMemberT, proto: int) -> tuple[Callable[..., Any], tuple[type[_EnumMemberT], str]]: ...\n",
  "/typeshed/stdlib/functools.pyi": "import sys\nimport types\nfrom _typeshed import SupportsAllComparisons, SupportsItems\nfrom collections.abc import Callable, Hashable, Iterable, Sized\nfrom types import GenericAlias\nfrom typing import Any, Final, Generic, Literal, NamedTuple, TypedDict, TypeVar, final, overload, type_check_only\nfrom typing_extensions import ParamSpec, Self, TypeAlias, disjoint_base\n\n__all__ = [\n    \"update_wrapper\",\n    \"wraps\",\n    \"WRAPPER_ASSIGNMENTS\",\n    \"WRAPPER_UPDATES\",\n    \"total_ordering\",\n    \"cmp_to_key\",\n    \"lru_cache\",\n    \"reduce\",\n    \"partial\",\n    \"partialmethod\",\n    \"singledispatch\",\n    \"cached_property\",\n    \"singledispatchmethod\",\n    \"cache\",\n]\n\n_T = TypeVar(\"_T\")\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_S = TypeVar(\"_S\")\n_PWrapped = ParamSpec(\"_PWrapped\")\n_RWrapped = TypeVar(\"_RWrapped\")\n_PWrapper = ParamSpec(\"_PWrapper\")\n_RWrapper = TypeVar(\"_RWrapper\")\n\nif sys.version_info >= (3, 14):\n    @overload\n    def reduce(function: Callable[[_T, _S], _T], iterable: Iterable[_S], /, initial: _T) -> _T: ...\n\nelse:\n    @overload\n    def reduce(function: Callable[[_T, _S], _T], iterable: Iterable[_S], initial: _T, /) -> _T: ...\n\n@overload\ndef reduce(function: Callable[[_T, _T], _T], iterable: Iterable[_T], /) -> _T: ...\n\nclass _CacheInfo(NamedTuple):\n    hits: int\n    misses: int\n    maxsize: int | None\n    currsize: int\n\n@type_check_only\nclass _CacheParameters(TypedDict):\n    maxsize: int\n    typed: bool\n\n@final\nclass _lru_cache_wrapper(Generic[_T]):\n    __wrapped__: Callable[..., _T]\n    def __call__(self, *args: Hashable, **kwargs: Hashable) -> _T: ...\n    def cache_info(self) -> _CacheInfo: ...\n    def cache_clear(self) -> None: ...\n    def cache_parameters(self) -> _CacheParameters: ...\n    def __copy__(self) -> _lru_cache_wrapper[_T]: ...\n    def __deepcopy__(self, memo: Any, /) -> _lru_cache_wrapper[_T]: ...\n\n@overload\ndef lru_cache(maxsize: int | None = 128, typed: bool = False) -> Callable[[Callable[..., _T]], _lru_cache_wrapper[_T]]: ...\n@overload\ndef lru_cache(maxsize: Callable[..., _T], typed: bool = False) -> _lru_cache_wrapper[_T]: ...\n\nif sys.version_info >= (3, 14):\n    WRAPPER_ASSIGNMENTS: Final[\n        tuple[\n            Literal[\"__module__\"],\n            Literal[\"__name__\"],\n            Literal[\"__qualname__\"],\n            Literal[\"__doc__\"],\n            Literal[\"__annotate__\"],\n            Literal[\"__type_params__\"],\n        ]\n    ]\nelif sys.version_info >= (3, 12):\n    WRAPPER_ASSIGNMENTS: Final[\n        tuple[\n            Literal[\"__module__\"],\n            Literal[\"__name__\"],\n            Literal[\"__qualname__\"],\n            Literal[\"__doc__\"],\n            Literal[\"__annotations__\"],\n            Literal[\"__type_params__\"],\n        ]\n    ]\nelse:\n    WRAPPER_ASSIGNMENTS: Final[\n        tuple[Literal[\"__module__\"], Literal[\"__name__\"], Literal[\"__qualname__\"], Literal[\"__doc__\"], Literal[\"__annotations__\"]]\n    ]\n\nWRAPPER_UPDATES: Final[tuple[Literal[\"__dict__\"]]]\n\n@type_check_only\nclass _Wrapped(Generic[_PWrapped, _RWrapped, _PWrapper, _RWrapper]):\n    __wrapped__: Callable[_PWrapped, _RWrapped]\n    def __call__(self, *args: _PWrapper.args, **kwargs: _PWrapper.kwargs) -> _RWrapper: ...\n    # as with ``Callable``, we'll assume that these attributes exist\n    __name__: str\n    __qualname__: str\n\n@type_check_only\nclass _Wrapper(Generic[_PWrapped, _RWrapped]):\n    def __call__(self, f: Callable[_PWrapper, _RWrapper]) -> _Wrapped[_PWrapped, _RWrapped, _PWrapper, _RWrapper]: ...\n\nif sys.version_info >= (3, 14):\n    def update_wrapper(\n        wrapper: Callable[_PWrapper, _RWrapper],\n        wrapped: Callable[_PWrapped, _RWrapped],\n        assigned: Iterable[str] = (\"__module__\", \"__name__\", \"__qualname__\", \"__doc__\", \"__annotate__\", \"__type_params__\"),\n        updated: Iterable[str] = (\"__dict__\",),\n    ) -> _Wrapped[_PWrapped, _RWrapped, _PWrapper, _RWrapper]: ...\n    def wraps(\n        wrapped: Callable[_PWrapped, _RWrapped],\n        assigned: Iterable[str] = (\"__module__\", \"__name__\", \"__qualname__\", \"__doc__\", \"__annotate__\", \"__type_params__\"),\n        updated: Iterable[str] = (\"__dict__\",),\n    ) -> _Wrapper[_PWrapped, _RWrapped]: ...\n\nelif sys.version_info >= (3, 12):\n    def update_wrapper(\n        wrapper: Callable[_PWrapper, _RWrapper],\n        wrapped: Callable[_PWrapped, _RWrapped],\n        assigned: Iterable[str] = (\"__module__\", \"__name__\", \"__qualname__\", \"__doc__\", \"__annotations__\", \"__type_params__\"),\n        updated: Iterable[str] = (\"__dict__\",),\n    ) -> _Wrapped[_PWrapped, _RWrapped, _PWrapper, _RWrapper]: ...\n    def wraps(\n        wrapped: Callable[_PWrapped, _RWrapped],\n        assigned: Iterable[str] = (\"__module__\", \"__name__\", \"__qualname__\", \"__doc__\", \"__annotations__\", \"__type_params__\"),\n        updated: Iterable[str] = (\"__dict__\",),\n    ) -> _Wrapper[_PWrapped, _RWrapped]: ...\n\nelse:\n    def update_wrapper(\n        wrapper: Callable[_PWrapper, _RWrapper],\n        wrapped: Callable[_PWrapped, _RWrapped],\n        assigned: Iterable[str] = (\"__module__\", \"__name__\", \"__qualname__\", \"__doc__\", \"__annotations__\"),\n        updated: Iterable[str] = (\"__dict__\",),\n    ) -> _Wrapped[_PWrapped, _RWrapped, _PWrapper, _RWrapper]: ...\n    def wraps(\n        wrapped: Callable[_PWrapped, _RWrapped],\n        assigned: Iterable[str] = (\"__module__\", \"__name__\", \"__qualname__\", \"__doc__\", \"__annotations__\"),\n        updated: Iterable[str] = (\"__dict__\",),\n    ) -> _Wrapper[_PWrapped, _RWrapped]: ...\n\ndef total_ordering(cls: type[_T]) -> type[_T]: ...\ndef cmp_to_key(mycmp: Callable[[_T, _T], int]) -> Callable[[_T], SupportsAllComparisons]: ...\n@disjoint_base\nclass partial(Generic[_T]):\n    @property\n    def func(self) -> Callable[..., _T]: ...\n    @property\n    def args(self) -> tuple[Any, ...]: ...\n    @property\n    def keywords(self) -> dict[str, Any]: ...\n    def __new__(cls, func: Callable[..., _T], /, *args: Any, **kwargs: Any) -> Self: ...\n    def __call__(self, /, *args: Any, **kwargs: Any) -> _T: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n# With protocols, this could change into a generic protocol that defines __get__ and returns _T\n_Descriptor: TypeAlias = Any\n\nclass partialmethod(Generic[_T]):\n    func: Callable[..., _T] | _Descriptor\n    args: tuple[Any, ...]\n    keywords: dict[str, Any]\n    if sys.version_info >= (3, 14):\n        @overload\n        def __new__(self, func: Callable[..., _T], /, *args: Any, **keywords: Any) -> Self: ...\n        @overload\n        def __new__(self, func: _Descriptor, /, *args: Any, **keywords: Any) -> Self: ...\n    else:\n        @overload\n        def __init__(self, func: Callable[..., _T], /, *args: Any, **keywords: Any) -> None: ...\n        @overload\n        def __init__(self, func: _Descriptor, /, *args: Any, **keywords: Any) -> None: ...\n\n    def __get__(self, obj: Any, cls: type[Any] | None = None) -> Callable[..., _T]: ...\n    @property\n    def __isabstractmethod__(self) -> bool: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\nif sys.version_info >= (3, 11):\n    _RegType: TypeAlias = type[Any] | types.UnionType\nelse:\n    _RegType: TypeAlias = type[Any]\n\n@type_check_only\nclass _SingleDispatchCallable(Generic[_T]):\n    registry: types.MappingProxyType[Any, Callable[..., _T]]\n    def dispatch(self, cls: Any) -> Callable[..., _T]: ...\n    # @fun.register(complex)\n    # def _(arg, verbose=False): ...\n    @overload\n    def register(self, cls: _RegType, func: None = None) -> Callable[[Callable[..., _T]], Callable[..., _T]]: ...\n    # @fun.register\n    # def _(arg: int, verbose=False):\n    @overload\n    def register(self, cls: Callable[..., _T], func: None = None) -> Callable[..., _T]: ...\n    # fun.register(int, lambda x: x)\n    @overload\n    def register(self, cls: _RegType, func: Callable[..., _T]) -> Callable[..., _T]: ...\n    def _clear_cache(self) -> None: ...\n    def __call__(self, /, *args: Any, **kwargs: Any) -> _T: ...\n\ndef singledispatch(func: Callable[..., _T]) -> _SingleDispatchCallable[_T]: ...\n\nclass singledispatchmethod(Generic[_T]):\n    dispatcher: _SingleDispatchCallable[_T]\n    func: Callable[..., _T]\n    def __init__(self, func: Callable[..., _T]) -> None: ...\n    @property\n    def __isabstractmethod__(self) -> bool: ...\n    @overload\n    def register(self, cls: _RegType, method: None = None) -> Callable[[Callable[..., _T]], Callable[..., _T]]: ...\n    @overload\n    def register(self, cls: Callable[..., _T], method: None = None) -> Callable[..., _T]: ...\n    @overload\n    def register(self, cls: _RegType, method: Callable[..., _T]) -> Callable[..., _T]: ...\n    def __get__(self, obj: _S, cls: type[_S] | None = None) -> Callable[..., _T]: ...\n\nclass cached_property(Generic[_T_co]):\n    func: Callable[[Any], _T_co]\n    attrname: str | None\n    def __init__(self, func: Callable[[Any], _T_co]) -> None: ...\n    @overload\n    def __get__(self, instance: None, owner: type[Any] | None = None) -> Self: ...\n    @overload\n    def __get__(self, instance: object, owner: type[Any] | None = None) -> _T_co: ...\n    def __set_name__(self, owner: type[Any], name: str) -> None: ...\n    # __set__ is not defined at runtime, but @cached_property is designed to be settable\n    def __set__(self, instance: object, value: _T_co) -> None: ...  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues]\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\ndef cache(user_function: Callable[..., _T], /) -> _lru_cache_wrapper[_T]: ...\ndef _make_key(\n    args: tuple[Hashable, ...],\n    kwds: SupportsItems[Any, Any],\n    typed: bool,\n    kwd_mark: tuple[object, ...] = ...,\n    fasttypes: set[type] = ...,\n    tuple: type = ...,\n    type: Any = ...,\n    len: Callable[[Sized], int] = ...,\n) -> Hashable: ...\n\nif sys.version_info >= (3, 14):\n    @final\n    class _PlaceholderType: ...\n\n    Placeholder: Final[_PlaceholderType]\n\n    __all__ += [\"Placeholder\"]\n",
  "/typeshed/stdlib/io.pyi": "import abc\nimport sys\nfrom _io import (\n    DEFAULT_BUFFER_SIZE as DEFAULT_BUFFER_SIZE,\n    BlockingIOError as BlockingIOError,\n    BufferedRandom as BufferedRandom,\n    BufferedReader as BufferedReader,\n    BufferedRWPair as BufferedRWPair,\n    BufferedWriter as BufferedWriter,\n    BytesIO as BytesIO,\n    FileIO as FileIO,\n    IncrementalNewlineDecoder as IncrementalNewlineDecoder,\n    StringIO as StringIO,\n    TextIOWrapper as TextIOWrapper,\n    _BufferedIOBase,\n    _IOBase,\n    _RawIOBase,\n    _TextIOBase,\n    _WrappedBuffer as _WrappedBuffer,  # used elsewhere in typeshed\n    open as open,\n    open_code as open_code,\n)\nfrom typing import Final, Protocol, TypeVar\n\n__all__ = [\n    \"BlockingIOError\",\n    \"open\",\n    \"open_code\",\n    \"IOBase\",\n    \"RawIOBase\",\n    \"FileIO\",\n    \"BytesIO\",\n    \"StringIO\",\n    \"BufferedIOBase\",\n    \"BufferedReader\",\n    \"BufferedWriter\",\n    \"BufferedRWPair\",\n    \"BufferedRandom\",\n    \"TextIOBase\",\n    \"TextIOWrapper\",\n    \"UnsupportedOperation\",\n    \"SEEK_SET\",\n    \"SEEK_CUR\",\n    \"SEEK_END\",\n]\n\nif sys.version_info >= (3, 14):\n    __all__ += [\"Reader\", \"Writer\"]\n\nif sys.version_info >= (3, 11):\n    from _io import text_encoding as text_encoding\n\n    __all__ += [\"DEFAULT_BUFFER_SIZE\", \"IncrementalNewlineDecoder\", \"text_encoding\"]\n\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_T_contra = TypeVar(\"_T_contra\", contravariant=True)\n\nSEEK_SET: Final = 0\nSEEK_CUR: Final = 1\nSEEK_END: Final = 2\n\nclass UnsupportedOperation(OSError, ValueError): ...\nclass IOBase(_IOBase, metaclass=abc.ABCMeta): ...\nclass RawIOBase(_RawIOBase, IOBase): ...\nclass BufferedIOBase(_BufferedIOBase, IOBase): ...\nclass TextIOBase(_TextIOBase, IOBase): ...\n\nif sys.version_info >= (3, 14):\n    class Reader(Protocol[_T_co]):\n        __slots__ = ()\n        def read(self, size: int = ..., /) -> _T_co: ...\n\n    class Writer(Protocol[_T_contra]):\n        __slots__ = ()\n        def write(self, data: _T_contra, /) -> int: ...\n",
  "/typeshed/stdlib/itertools.pyi": "import sys\nfrom _typeshed import MaybeNone\nfrom collections.abc import Callable, Iterable, Iterator\nfrom types import GenericAlias\nfrom typing import Any, Generic, Literal, SupportsComplex, SupportsFloat, SupportsIndex, SupportsInt, TypeVar, overload\nfrom typing_extensions import Self, TypeAlias, disjoint_base\n\n_T = TypeVar(\"_T\")\n_S = TypeVar(\"_S\")\n_N = TypeVar(\"_N\", int, float, SupportsFloat, SupportsInt, SupportsIndex, SupportsComplex)\n_T_co = TypeVar(\"_T_co\", covariant=True)\n_S_co = TypeVar(\"_S_co\", covariant=True)\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_T3 = TypeVar(\"_T3\")\n_T4 = TypeVar(\"_T4\")\n_T5 = TypeVar(\"_T5\")\n_T6 = TypeVar(\"_T6\")\n_T7 = TypeVar(\"_T7\")\n_T8 = TypeVar(\"_T8\")\n_T9 = TypeVar(\"_T9\")\n_T10 = TypeVar(\"_T10\")\n\n_Step: TypeAlias = SupportsFloat | SupportsInt | SupportsIndex | SupportsComplex\n\n_Predicate: TypeAlias = Callable[[_T], object]\n\n# Technically count can take anything that implements a number protocol and has an add method\n# but we can't enforce the add method\n@disjoint_base\nclass count(Generic[_N]):\n    @overload\n    def __new__(cls) -> count[int]: ...\n    @overload\n    def __new__(cls, start: _N, step: _Step = ...) -> count[_N]: ...\n    @overload\n    def __new__(cls, *, step: _N) -> count[_N]: ...\n    def __next__(self) -> _N: ...\n    def __iter__(self) -> Self: ...\n\n@disjoint_base\nclass cycle(Generic[_T]):\n    def __new__(cls, iterable: Iterable[_T], /) -> Self: ...\n    def __next__(self) -> _T: ...\n    def __iter__(self) -> Self: ...\n\n@disjoint_base\nclass repeat(Generic[_T]):\n    @overload\n    def __new__(cls, object: _T) -> Self: ...\n    @overload\n    def __new__(cls, object: _T, times: int) -> Self: ...\n    def __next__(self) -> _T: ...\n    def __iter__(self) -> Self: ...\n    def __length_hint__(self) -> int: ...\n\n@disjoint_base\nclass accumulate(Generic[_T]):\n    @overload\n    def __new__(cls, iterable: Iterable[_T], func: None = None, *, initial: _T | None = ...) -> Self: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_S], func: Callable[[_T, _S], _T], *, initial: _T | None = ...) -> Self: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\n@disjoint_base\nclass chain(Generic[_T]):\n    def __new__(cls, *iterables: Iterable[_T]) -> Self: ...\n    def __next__(self) -> _T: ...\n    def __iter__(self) -> Self: ...\n    @classmethod\n    # We use type[Any] and not type[_S] to not lose the type inference from __iterable\n    def from_iterable(cls: type[Any], iterable: Iterable[Iterable[_S]], /) -> chain[_S]: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n@disjoint_base\nclass compress(Generic[_T]):\n    def __new__(cls, data: Iterable[_T], selectors: Iterable[Any]) -> Self: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\n@disjoint_base\nclass dropwhile(Generic[_T]):\n    def __new__(cls, predicate: _Predicate[_T], iterable: Iterable[_T], /) -> Self: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\n@disjoint_base\nclass filterfalse(Generic[_T]):\n    def __new__(cls, function: _Predicate[_T] | None, iterable: Iterable[_T], /) -> Self: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\n@disjoint_base\nclass groupby(Generic[_T_co, _S_co]):\n    @overload\n    def __new__(cls, iterable: Iterable[_T1], key: None = None) -> groupby[_T1, _T1]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T1], key: Callable[[_T1], _T2]) -> groupby[_T2, _T1]: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> tuple[_T_co, Iterator[_S_co]]: ...\n\n@disjoint_base\nclass islice(Generic[_T]):\n    @overload\n    def __new__(cls, iterable: Iterable[_T], stop: int | None, /) -> Self: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], start: int | None, stop: int | None, step: int | None = ..., /) -> Self: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\n@disjoint_base\nclass starmap(Generic[_T_co]):\n    def __new__(cls, function: Callable[..., _T], iterable: Iterable[Iterable[Any]], /) -> starmap[_T]: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T_co: ...\n\n@disjoint_base\nclass takewhile(Generic[_T]):\n    def __new__(cls, predicate: _Predicate[_T], iterable: Iterable[_T], /) -> Self: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T: ...\n\ndef tee(iterable: Iterable[_T], n: int = 2, /) -> tuple[Iterator[_T], ...]: ...\n@disjoint_base\nclass zip_longest(Generic[_T_co]):\n    # one iterable (fillvalue doesn't matter)\n    @overload\n    def __new__(cls, iter1: Iterable[_T1], /, *, fillvalue: object = ...) -> zip_longest[tuple[_T1]]: ...\n    # two iterables\n    @overload\n    # In the overloads without fillvalue, all of the tuple members could theoretically be None,\n    # but we return Any instead to avoid false positives for code where we know one of the iterables\n    # is longer.\n    def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> zip_longest[tuple[_T1 | MaybeNone, _T2 | MaybeNone]]: ...\n    @overload\n    def __new__(\n        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /, *, fillvalue: _T\n    ) -> zip_longest[tuple[_T1 | _T, _T2 | _T]]: ...\n    # three iterables\n    @overload\n    def __new__(\n        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /\n    ) -> zip_longest[tuple[_T1 | MaybeNone, _T2 | MaybeNone, _T3 | MaybeNone]]: ...\n    @overload\n    def __new__(\n        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /, *, fillvalue: _T\n    ) -> zip_longest[tuple[_T1 | _T, _T2 | _T, _T3 | _T]]: ...\n    # four iterables\n    @overload\n    def __new__(\n        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /\n    ) -> zip_longest[tuple[_T1 | MaybeNone, _T2 | MaybeNone, _T3 | MaybeNone, _T4 | MaybeNone]]: ...\n    @overload\n    def __new__(\n        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /, *, fillvalue: _T\n    ) -> zip_longest[tuple[_T1 | _T, _T2 | _T, _T3 | _T, _T4 | _T]]: ...\n    # five iterables\n    @overload\n    def __new__(\n        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], iter5: Iterable[_T5], /\n    ) -> zip_longest[tuple[_T1 | MaybeNone, _T2 | MaybeNone, _T3 | MaybeNone, _T4 | MaybeNone, _T5 | MaybeNone]]: ...\n    @overload\n    def __new__(\n        cls,\n        iter1: Iterable[_T1],\n        iter2: Iterable[_T2],\n        iter3: Iterable[_T3],\n        iter4: Iterable[_T4],\n        iter5: Iterable[_T5],\n        /,\n        *,\n        fillvalue: _T,\n    ) -> zip_longest[tuple[_T1 | _T, _T2 | _T, _T3 | _T, _T4 | _T, _T5 | _T]]: ...\n    # six or more iterables\n    @overload\n    def __new__(\n        cls,\n        iter1: Iterable[_T],\n        iter2: Iterable[_T],\n        iter3: Iterable[_T],\n        iter4: Iterable[_T],\n        iter5: Iterable[_T],\n        iter6: Iterable[_T],\n        /,\n        *iterables: Iterable[_T],\n    ) -> zip_longest[tuple[_T | MaybeNone, ...]]: ...\n    @overload\n    def __new__(\n        cls,\n        iter1: Iterable[_T],\n        iter2: Iterable[_T],\n        iter3: Iterable[_T],\n        iter4: Iterable[_T],\n        iter5: Iterable[_T],\n        iter6: Iterable[_T],\n        /,\n        *iterables: Iterable[_T],\n        fillvalue: _T,\n    ) -> zip_longest[tuple[_T, ...]]: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T_co: ...\n\n@disjoint_base\nclass product(Generic[_T_co]):\n    @overload\n    def __new__(cls, iter1: Iterable[_T1], /) -> product[tuple[_T1]]: ...\n    @overload\n    def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], /) -> product[tuple[_T1, _T2]]: ...\n    @overload\n    def __new__(cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], /) -> product[tuple[_T1, _T2, _T3]]: ...\n    @overload\n    def __new__(\n        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], /\n    ) -> product[tuple[_T1, _T2, _T3, _T4]]: ...\n    @overload\n    def __new__(\n        cls, iter1: Iterable[_T1], iter2: Iterable[_T2], iter3: Iterable[_T3], iter4: Iterable[_T4], iter5: Iterable[_T5], /\n    ) -> product[tuple[_T1, _T2, _T3, _T4, _T5]]: ...\n    @overload\n    def __new__(\n        cls,\n        iter1: Iterable[_T1],\n        iter2: Iterable[_T2],\n        iter3: Iterable[_T3],\n        iter4: Iterable[_T4],\n        iter5: Iterable[_T5],\n        iter6: Iterable[_T6],\n        /,\n    ) -> product[tuple[_T1, _T2, _T3, _T4, _T5, _T6]]: ...\n    @overload\n    def __new__(\n        cls,\n        iter1: Iterable[_T1],\n        iter2: Iterable[_T2],\n        iter3: Iterable[_T3],\n        iter4: Iterable[_T4],\n        iter5: Iterable[_T5],\n        iter6: Iterable[_T6],\n        iter7: Iterable[_T7],\n        /,\n    ) -> product[tuple[_T1, _T2, _T3, _T4, _T5, _T6, _T7]]: ...\n    @overload\n    def __new__(\n        cls,\n        iter1: Iterable[_T1],\n        iter2: Iterable[_T2],\n        iter3: Iterable[_T3],\n        iter4: Iterable[_T4],\n        iter5: Iterable[_T5],\n        iter6: Iterable[_T6],\n        iter7: Iterable[_T7],\n        iter8: Iterable[_T8],\n        /,\n    ) -> product[tuple[_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8]]: ...\n    @overload\n    def __new__(\n        cls,\n        iter1: Iterable[_T1],\n        iter2: Iterable[_T2],\n        iter3: Iterable[_T3],\n        iter4: Iterable[_T4],\n        iter5: Iterable[_T5],\n        iter6: Iterable[_T6],\n        iter7: Iterable[_T7],\n        iter8: Iterable[_T8],\n        iter9: Iterable[_T9],\n        /,\n    ) -> product[tuple[_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9]]: ...\n    @overload\n    def __new__(\n        cls,\n        iter1: Iterable[_T1],\n        iter2: Iterable[_T2],\n        iter3: Iterable[_T3],\n        iter4: Iterable[_T4],\n        iter5: Iterable[_T5],\n        iter6: Iterable[_T6],\n        iter7: Iterable[_T7],\n        iter8: Iterable[_T8],\n        iter9: Iterable[_T9],\n        iter10: Iterable[_T10],\n        /,\n    ) -> product[tuple[_T1, _T2, _T3, _T4, _T5, _T6, _T7, _T8, _T9, _T10]]: ...\n    @overload\n    def __new__(cls, *iterables: Iterable[_T1], repeat: int = 1) -> product[tuple[_T1, ...]]: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T_co: ...\n\n@disjoint_base\nclass permutations(Generic[_T_co]):\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[2]) -> permutations[tuple[_T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[3]) -> permutations[tuple[_T, _T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[4]) -> permutations[tuple[_T, _T, _T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[5]) -> permutations[tuple[_T, _T, _T, _T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: int | None = ...) -> permutations[tuple[_T, ...]]: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T_co: ...\n\n@disjoint_base\nclass combinations(Generic[_T_co]):\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[2]) -> combinations[tuple[_T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[3]) -> combinations[tuple[_T, _T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[4]) -> combinations[tuple[_T, _T, _T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[5]) -> combinations[tuple[_T, _T, _T, _T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: int) -> combinations[tuple[_T, ...]]: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T_co: ...\n\n@disjoint_base\nclass combinations_with_replacement(Generic[_T_co]):\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[2]) -> combinations_with_replacement[tuple[_T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[3]) -> combinations_with_replacement[tuple[_T, _T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[4]) -> combinations_with_replacement[tuple[_T, _T, _T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: Literal[5]) -> combinations_with_replacement[tuple[_T, _T, _T, _T, _T]]: ...\n    @overload\n    def __new__(cls, iterable: Iterable[_T], r: int) -> combinations_with_replacement[tuple[_T, ...]]: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _T_co: ...\n\nif sys.version_info >= (3, 10):\n    @disjoint_base\n    class pairwise(Generic[_T_co]):\n        def __new__(cls, iterable: Iterable[_T], /) -> pairwise[tuple[_T, _T]]: ...\n        def __iter__(self) -> Self: ...\n        def __next__(self) -> _T_co: ...\n\nif sys.version_info >= (3, 12):\n    @disjoint_base\n    class batched(Generic[_T_co]):\n        if sys.version_info >= (3, 13):\n            def __new__(cls, iterable: Iterable[_T_co], n: int, *, strict: bool = False) -> Self: ...\n        else:\n            def __new__(cls, iterable: Iterable[_T_co], n: int) -> Self: ...\n\n        def __iter__(self) -> Self: ...\n        def __next__(self) -> tuple[_T_co, ...]: ...\n",
  "/typeshed/stdlib/json/__init__.pyi": "from _typeshed import SupportsRead, SupportsWrite\nfrom collections.abc import Callable\nfrom typing import Any\n\nfrom .decoder import JSONDecodeError as JSONDecodeError, JSONDecoder as JSONDecoder\nfrom .encoder import JSONEncoder as JSONEncoder\n\n__all__ = [\"dump\", \"dumps\", \"load\", \"loads\", \"JSONDecoder\", \"JSONDecodeError\", \"JSONEncoder\"]\n\ndef dumps(\n    obj: Any,\n    *,\n    skipkeys: bool = False,\n    ensure_ascii: bool = True,\n    check_circular: bool = True,\n    allow_nan: bool = True,\n    cls: type[JSONEncoder] | None = None,\n    indent: None | int | str = None,\n    separators: tuple[str, str] | None = None,\n    default: Callable[[Any], Any] | None = None,\n    sort_keys: bool = False,\n    **kwds: Any,\n) -> str: ...\ndef dump(\n    obj: Any,\n    fp: SupportsWrite[str],\n    *,\n    skipkeys: bool = False,\n    ensure_ascii: bool = True,\n    check_circular: bool = True,\n    allow_nan: bool = True,\n    cls: type[JSONEncoder] | None = None,\n    indent: None | int | str = None,\n    separators: tuple[str, str] | None = None,\n    default: Callable[[Any], Any] | None = None,\n    sort_keys: bool = False,\n    **kwds: Any,\n) -> None: ...\ndef loads(\n    s: str | bytes | bytearray,\n    *,\n    cls: type[JSONDecoder] | None = None,\n    object_hook: Callable[[dict[Any, Any]], Any] | None = None,\n    parse_float: Callable[[str], Any] | None = None,\n    parse_int: Callable[[str], Any] | None = None,\n    parse_constant: Callable[[str], Any] | None = None,\n    object_pairs_hook: Callable[[list[tuple[Any, Any]]], Any] | None = None,\n    **kwds: Any,\n) -> Any: ...\ndef load(\n    fp: SupportsRead[str | bytes],\n    *,\n    cls: type[JSONDecoder] | None = None,\n    object_hook: Callable[[dict[Any, Any]], Any] | None = None,\n    parse_float: Callable[[str], Any] | None = None,\n    parse_int: Callable[[str], Any] | None = None,\n    parse_constant: Callable[[str], Any] | None = None,\n    object_pairs_hook: Callable[[list[tuple[Any, Any]]], Any] | None = None,\n    **kwds: Any,\n) -> Any: ...\ndef detect_encoding(b: bytes | bytearray) -> str: ...  # undocumented\n",
  "/typeshed/stdlib/json/decoder.pyi": "from collections.abc import Callable\nfrom typing import Any\n\n__all__ = [\"JSONDecoder\", \"JSONDecodeError\"]\n\nclass JSONDecodeError(ValueError):\n    msg: str\n    doc: str\n    pos: int\n    lineno: int\n    colno: int\n    def __init__(self, msg: str, doc: str, pos: int) -> None: ...\n\nclass JSONDecoder:\n    object_hook: Callable[[dict[str, Any]], Any]\n    parse_float: Callable[[str], Any]\n    parse_int: Callable[[str], Any]\n    parse_constant: Callable[[str], Any]\n    strict: bool\n    object_pairs_hook: Callable[[list[tuple[str, Any]]], Any]\n    def __init__(\n        self,\n        *,\n        object_hook: Callable[[dict[str, Any]], Any] | None = None,\n        parse_float: Callable[[str], Any] | None = None,\n        parse_int: Callable[[str], Any] | None = None,\n        parse_constant: Callable[[str], Any] | None = None,\n        strict: bool = True,\n        object_pairs_hook: Callable[[list[tuple[str, Any]]], Any] | None = None,\n    ) -> None: ...\n    def decode(self, s: str, _w: Callable[..., Any] = ...) -> Any: ...  # _w is undocumented\n    def raw_decode(self, s: str, idx: int = 0) -> tuple[Any, int]: ...\n",
  "/typeshed/stdlib/json/encoder.pyi": "from collections.abc import Callable, Iterator\nfrom re import Pattern\nfrom typing import Any, Final\n\nESCAPE: Final[Pattern[str]]  # undocumented\nESCAPE_ASCII: Final[Pattern[str]]  # undocumented\nHAS_UTF8: Final[Pattern[bytes]]  # undocumented\nESCAPE_DCT: Final[dict[str, str]]  # undocumented\nINFINITY: Final[float]  # undocumented\n\ndef py_encode_basestring(s: str) -> str: ...  # undocumented\ndef py_encode_basestring_ascii(s: str) -> str: ...  # undocumented\ndef encode_basestring(s: str, /) -> str: ...  # undocumented\ndef encode_basestring_ascii(s: str, /) -> str: ...  # undocumented\n\nclass JSONEncoder:\n    item_separator: str\n    key_separator: str\n\n    skipkeys: bool\n    ensure_ascii: bool\n    check_circular: bool\n    allow_nan: bool\n    sort_keys: bool\n    indent: int | str\n    def __init__(\n        self,\n        *,\n        skipkeys: bool = False,\n        ensure_ascii: bool = True,\n        check_circular: bool = True,\n        allow_nan: bool = True,\n        sort_keys: bool = False,\n        indent: int | str | None = None,\n        separators: tuple[str, str] | None = None,\n        default: Callable[..., Any] | None = None,\n    ) -> None: ...\n    def default(self, o: Any) -> Any: ...\n    def encode(self, o: Any) -> str: ...\n    def iterencode(self, o: Any, _one_shot: bool = False) -> Iterator[str]: ...\n",
  "/typeshed/stdlib/json/scanner.pyi": "from _json import make_scanner as make_scanner\nfrom re import Pattern\nfrom typing import Final\n\n__all__ = [\"make_scanner\"]\n\nNUMBER_RE: Final[Pattern[str]]  # undocumented\n",
  "/typeshed/stdlib/json/tool.pyi": "def main() -> None: ...\n",
  "/typeshed/stdlib/os/__init__.pyi": "import sys\nfrom _typeshed import (\n    AnyStr_co,\n    BytesPath,\n    FileDescriptor,\n    FileDescriptorLike,\n    FileDescriptorOrPath,\n    GenericPath,\n    OpenBinaryMode,\n    OpenBinaryModeReading,\n    OpenBinaryModeUpdating,\n    OpenBinaryModeWriting,\n    OpenTextMode,\n    ReadableBuffer,\n    StrOrBytesPath,\n    StrPath,\n    SupportsLenAndGetItem,\n    Unused,\n    WriteableBuffer,\n    structseq,\n)\nfrom abc import ABC, abstractmethod\nfrom builtins import OSError\nfrom collections.abc import Callable, Iterable, Iterator, Mapping, MutableMapping, Sequence\nfrom io import BufferedRandom, BufferedReader, BufferedWriter, FileIO, TextIOWrapper\nfrom subprocess import Popen\nfrom types import GenericAlias, TracebackType\nfrom typing import (\n    IO,\n    Any,\n    AnyStr,\n    BinaryIO,\n    Final,\n    Generic,\n    Literal,\n    NoReturn,\n    Protocol,\n    TypeVar,\n    final,\n    overload,\n    runtime_checkable,\n    type_check_only,\n)\nfrom typing_extensions import LiteralString, Self, TypeAlias, Unpack, deprecated\n\nfrom . import path as _path\n\n# Re-export common definitions from os.path to reduce duplication\nfrom .path import (\n    altsep as altsep,\n    curdir as curdir,\n    defpath as defpath,\n    devnull as devnull,\n    extsep as extsep,\n    pardir as pardir,\n    pathsep as pathsep,\n    sep as sep,\n)\n\n__all__ = [\n    \"F_OK\",\n    \"O_APPEND\",\n    \"O_CREAT\",\n    \"O_EXCL\",\n    \"O_RDONLY\",\n    \"O_RDWR\",\n    \"O_TRUNC\",\n    \"O_WRONLY\",\n    \"P_NOWAIT\",\n    \"P_NOWAITO\",\n    \"P_WAIT\",\n    \"R_OK\",\n    \"SEEK_CUR\",\n    \"SEEK_END\",\n    \"SEEK_SET\",\n    \"TMP_MAX\",\n    \"W_OK\",\n    \"X_OK\",\n    \"DirEntry\",\n    \"_exit\",\n    \"abort\",\n    \"access\",\n    \"altsep\",\n    \"chdir\",\n    \"chmod\",\n    \"close\",\n    \"closerange\",\n    \"cpu_count\",\n    \"curdir\",\n    \"defpath\",\n    \"device_encoding\",\n    \"devnull\",\n    \"dup\",\n    \"dup2\",\n    \"environ\",\n    \"error\",\n    \"execl\",\n    \"execle\",\n    \"execlp\",\n    \"execlpe\",\n    \"execv\",\n    \"execve\",\n    \"execvp\",\n    \"execvpe\",\n    \"extsep\",\n    \"fdopen\",\n    \"fsdecode\",\n    \"fsencode\",\n    \"fspath\",\n    \"fstat\",\n    \"fsync\",\n    \"ftruncate\",\n    \"get_exec_path\",\n    \"get_inheritable\",\n    \"get_terminal_size\",\n    \"getcwd\",\n    \"getcwdb\",\n    \"getenv\",\n    \"getlogin\",\n    \"getpid\",\n    \"getppid\",\n    \"isatty\",\n    \"kill\",\n    \"linesep\",\n    \"link\",\n    \"listdir\",\n    \"lseek\",\n    \"lstat\",\n    \"makedirs\",\n    \"mkdir\",\n    \"name\",\n    \"open\",\n    \"pardir\",\n    \"path\",\n    \"pathsep\",\n    \"pipe\",\n    \"popen\",\n    \"putenv\",\n    \"read\",\n    \"readlink\",\n    \"remove\",\n    \"removedirs\",\n    \"rename\",\n    \"renames\",\n    \"replace\",\n    \"rmdir\",\n    \"scandir\",\n    \"sep\",\n    \"set_inheritable\",\n    \"spawnl\",\n    \"spawnle\",\n    \"spawnv\",\n    \"spawnve\",\n    \"stat\",\n    \"stat_result\",\n    \"statvfs_result\",\n    \"strerror\",\n    \"supports_bytes_environ\",\n    \"symlink\",\n    \"system\",\n    \"terminal_size\",\n    \"times\",\n    \"times_result\",\n    \"truncate\",\n    \"umask\",\n    \"uname_result\",\n    \"unlink\",\n    \"unsetenv\",\n    \"urandom\",\n    \"utime\",\n    \"waitpid\",\n    \"waitstatus_to_exitcode\",\n    \"walk\",\n    \"write\",\n]\nif sys.version_info >= (3, 14):\n    # reload_environ was added to __all__ in Python 3.14.1\n    __all__ += [\"readinto\", \"reload_environ\"]\nif sys.platform == \"darwin\" and sys.version_info >= (3, 12):\n    __all__ += [\"PRIO_DARWIN_BG\", \"PRIO_DARWIN_NONUI\", \"PRIO_DARWIN_PROCESS\", \"PRIO_DARWIN_THREAD\"]\nif sys.platform == \"darwin\" and sys.version_info >= (3, 10):\n    __all__ += [\"O_EVTONLY\", \"O_NOFOLLOW_ANY\", \"O_SYMLINK\"]\nif sys.platform == \"linux\":\n    __all__ += [\n        \"GRND_NONBLOCK\",\n        \"GRND_RANDOM\",\n        \"MFD_ALLOW_SEALING\",\n        \"MFD_CLOEXEC\",\n        \"MFD_HUGETLB\",\n        \"MFD_HUGE_16GB\",\n        \"MFD_HUGE_16MB\",\n        \"MFD_HUGE_1GB\",\n        \"MFD_HUGE_1MB\",\n        \"MFD_HUGE_256MB\",\n        \"MFD_HUGE_2GB\",\n        \"MFD_HUGE_2MB\",\n        \"MFD_HUGE_32MB\",\n        \"MFD_HUGE_512KB\",\n        \"MFD_HUGE_512MB\",\n        \"MFD_HUGE_64KB\",\n        \"MFD_HUGE_8MB\",\n        \"MFD_HUGE_MASK\",\n        \"MFD_HUGE_SHIFT\",\n        \"O_DIRECT\",\n        \"O_LARGEFILE\",\n        \"O_NOATIME\",\n        \"O_PATH\",\n        \"O_RSYNC\",\n        \"O_TMPFILE\",\n        \"P_PIDFD\",\n        \"RTLD_DEEPBIND\",\n        \"SCHED_BATCH\",\n        \"SCHED_IDLE\",\n        \"SCHED_RESET_ON_FORK\",\n        \"XATTR_CREATE\",\n        \"XATTR_REPLACE\",\n        \"XATTR_SIZE_MAX\",\n        \"copy_file_range\",\n        \"getrandom\",\n        \"getxattr\",\n        \"listxattr\",\n        \"memfd_create\",\n        \"pidfd_open\",\n        \"removexattr\",\n        \"setxattr\",\n    ]\nif sys.platform == \"linux\" and sys.version_info >= (3, 14):\n    __all__ += [\"SCHED_DEADLINE\", \"SCHED_NORMAL\"]\nif sys.platform == \"linux\" and sys.version_info >= (3, 13):\n    __all__ += [\n        \"POSIX_SPAWN_CLOSEFROM\",\n        \"TFD_CLOEXEC\",\n        \"TFD_NONBLOCK\",\n        \"TFD_TIMER_ABSTIME\",\n        \"TFD_TIMER_CANCEL_ON_SET\",\n        \"timerfd_create\",\n        \"timerfd_gettime\",\n        \"timerfd_gettime_ns\",\n        \"timerfd_settime\",\n        \"timerfd_settime_ns\",\n    ]\nif sys.platform == \"linux\" and sys.version_info >= (3, 12):\n    __all__ += [\n        \"CLONE_FILES\",\n        \"CLONE_FS\",\n        \"CLONE_NEWCGROUP\",\n        \"CLONE_NEWIPC\",\n        \"CLONE_NEWNET\",\n        \"CLONE_NEWNS\",\n        \"CLONE_NEWPID\",\n        \"CLONE_NEWTIME\",\n        \"CLONE_NEWUSER\",\n        \"CLONE_NEWUTS\",\n        \"CLONE_SIGHAND\",\n        \"CLONE_SYSVSEM\",\n        \"CLONE_THREAD\",\n        \"CLONE_VM\",\n        \"setns\",\n        \"unshare\",\n        \"PIDFD_NONBLOCK\",\n    ]\nif sys.platform == \"linux\" and sys.version_info >= (3, 10):\n    __all__ += [\n        \"EFD_CLOEXEC\",\n        \"EFD_NONBLOCK\",\n        \"EFD_SEMAPHORE\",\n        \"RWF_APPEND\",\n        \"SPLICE_F_MORE\",\n        \"SPLICE_F_MOVE\",\n        \"SPLICE_F_NONBLOCK\",\n        \"eventfd\",\n        \"eventfd_read\",\n        \"eventfd_write\",\n        \"splice\",\n    ]\nif sys.platform == \"win32\":\n    __all__ += [\n        \"O_BINARY\",\n        \"O_NOINHERIT\",\n        \"O_RANDOM\",\n        \"O_SEQUENTIAL\",\n        \"O_SHORT_LIVED\",\n        \"O_TEMPORARY\",\n        \"O_TEXT\",\n        \"P_DETACH\",\n        \"P_OVERLAY\",\n        \"get_handle_inheritable\",\n        \"set_handle_inheritable\",\n        \"startfile\",\n    ]\nif sys.platform == \"win32\" and sys.version_info >= (3, 12):\n    __all__ += [\"listdrives\", \"listmounts\", \"listvolumes\"]\nif sys.platform != \"win32\":\n    __all__ += [\n        \"CLD_CONTINUED\",\n        \"CLD_DUMPED\",\n        \"CLD_EXITED\",\n        \"CLD_KILLED\",\n        \"CLD_STOPPED\",\n        \"CLD_TRAPPED\",\n        \"EX_CANTCREAT\",\n        \"EX_CONFIG\",\n        \"EX_DATAERR\",\n        \"EX_IOERR\",\n        \"EX_NOHOST\",\n        \"EX_NOINPUT\",\n        \"EX_NOPERM\",\n        \"EX_NOUSER\",\n        \"EX_OSERR\",\n        \"EX_OSFILE\",\n        \"EX_PROTOCOL\",\n        \"EX_SOFTWARE\",\n        \"EX_TEMPFAIL\",\n        \"EX_UNAVAILABLE\",\n        \"EX_USAGE\",\n        \"F_LOCK\",\n        \"F_TEST\",\n        \"F_TLOCK\",\n        \"F_ULOCK\",\n        \"NGROUPS_MAX\",\n        \"O_ACCMODE\",\n        \"O_ASYNC\",\n        \"O_CLOEXEC\",\n        \"O_DIRECTORY\",\n        \"O_DSYNC\",\n        \"O_NDELAY\",\n        \"O_NOCTTY\",\n        \"O_NOFOLLOW\",\n        \"O_NONBLOCK\",\n        \"O_SYNC\",\n        \"POSIX_SPAWN_CLOSE\",\n        \"POSIX_SPAWN_DUP2\",\n        \"POSIX_SPAWN_OPEN\",\n        \"PRIO_PGRP\",\n        \"PRIO_PROCESS\",\n        \"PRIO_USER\",\n        \"P_ALL\",\n        \"P_PGID\",\n        \"P_PID\",\n        \"RTLD_GLOBAL\",\n        \"RTLD_LAZY\",\n        \"RTLD_LOCAL\",\n        \"RTLD_NODELETE\",\n        \"RTLD_NOLOAD\",\n        \"RTLD_NOW\",\n        \"SCHED_FIFO\",\n        \"SCHED_OTHER\",\n        \"SCHED_RR\",\n        \"SEEK_DATA\",\n        \"SEEK_HOLE\",\n        \"ST_NOSUID\",\n        \"ST_RDONLY\",\n        \"WCONTINUED\",\n        \"WCOREDUMP\",\n        \"WEXITED\",\n        \"WEXITSTATUS\",\n        \"WIFCONTINUED\",\n        \"WIFEXITED\",\n        \"WIFSIGNALED\",\n        \"WIFSTOPPED\",\n        \"WNOHANG\",\n        \"WNOWAIT\",\n        \"WSTOPPED\",\n        \"WSTOPSIG\",\n        \"WTERMSIG\",\n        \"WUNTRACED\",\n        \"chown\",\n        \"chroot\",\n        \"confstr\",\n        \"confstr_names\",\n        \"ctermid\",\n        \"environb\",\n        \"fchdir\",\n        \"fchown\",\n        \"fork\",\n        \"forkpty\",\n        \"fpathconf\",\n        \"fstatvfs\",\n        \"fwalk\",\n        \"getegid\",\n        \"getenvb\",\n        \"geteuid\",\n        \"getgid\",\n        \"getgrouplist\",\n        \"getgroups\",\n        \"getloadavg\",\n        \"getpgid\",\n        \"getpgrp\",\n        \"getpriority\",\n        \"getsid\",\n        \"getuid\",\n        \"initgroups\",\n        \"killpg\",\n        \"lchown\",\n        \"lockf\",\n        \"major\",\n        \"makedev\",\n        \"minor\",\n        \"mkfifo\",\n        \"mknod\",\n        \"nice\",\n        \"openpty\",\n        \"pathconf\",\n        \"pathconf_names\",\n        \"posix_spawn\",\n        \"posix_spawnp\",\n        \"pread\",\n        \"preadv\",\n        \"pwrite\",\n        \"pwritev\",\n        \"readv\",\n        \"register_at_fork\",\n        \"sched_get_priority_max\",\n        \"sched_get_priority_min\",\n        \"sched_yield\",\n        \"sendfile\",\n        \"setegid\",\n        \"seteuid\",\n        \"setgid\",\n        \"setgroups\",\n        \"setpgid\",\n        \"setpgrp\",\n        \"setpriority\",\n        \"setregid\",\n        \"setreuid\",\n        \"setsid\",\n        \"setuid\",\n        \"spawnlp\",\n        \"spawnlpe\",\n        \"spawnvp\",\n        \"spawnvpe\",\n        \"statvfs\",\n        \"sync\",\n        \"sysconf\",\n        \"sysconf_names\",\n        \"tcgetpgrp\",\n        \"tcsetpgrp\",\n        \"ttyname\",\n        \"uname\",\n        \"wait\",\n        \"wait3\",\n        \"wait4\",\n        \"writev\",\n    ]\nif sys.platform != \"win32\" and sys.version_info >= (3, 13):\n    __all__ += [\"grantpt\", \"posix_openpt\", \"ptsname\", \"unlockpt\"]\nif sys.platform != \"win32\" and sys.version_info >= (3, 11):\n    __all__ += [\"login_tty\"]\nif sys.platform != \"win32\" and sys.version_info >= (3, 10):\n    __all__ += [\"O_FSYNC\"]\nif sys.platform != \"darwin\" and sys.platform != \"win32\":\n    __all__ += [\n        \"POSIX_FADV_DONTNEED\",\n        \"POSIX_FADV_NOREUSE\",\n        \"POSIX_FADV_NORMAL\",\n        \"POSIX_FADV_RANDOM\",\n        \"POSIX_FADV_SEQUENTIAL\",\n        \"POSIX_FADV_WILLNEED\",\n        \"RWF_DSYNC\",\n        \"RWF_HIPRI\",\n        \"RWF_NOWAIT\",\n        \"RWF_SYNC\",\n        \"ST_APPEND\",\n        \"ST_MANDLOCK\",\n        \"ST_NOATIME\",\n        \"ST_NODEV\",\n        \"ST_NODIRATIME\",\n        \"ST_NOEXEC\",\n        \"ST_RELATIME\",\n        \"ST_SYNCHRONOUS\",\n        \"ST_WRITE\",\n        \"fdatasync\",\n        \"getresgid\",\n        \"getresuid\",\n        \"pipe2\",\n        \"posix_fadvise\",\n        \"posix_fallocate\",\n        \"sched_getaffinity\",\n        \"sched_getparam\",\n        \"sched_getscheduler\",\n        \"sched_param\",\n        \"sched_rr_get_interval\",\n        \"sched_setaffinity\",\n        \"sched_setparam\",\n        \"sched_setscheduler\",\n        \"setresgid\",\n        \"setresuid\",\n    ]\nif sys.platform != \"linux\" and sys.platform != \"win32\":\n    __all__ += [\"O_EXLOCK\", \"O_SHLOCK\", \"chflags\", \"lchflags\"]\nif sys.platform != \"linux\" and sys.platform != \"win32\" and sys.version_info >= (3, 13):\n    __all__ += [\"O_EXEC\", \"O_SEARCH\"]\nif sys.platform != \"darwin\" or sys.version_info >= (3, 13):\n    if sys.platform != \"win32\":\n        __all__ += [\"waitid\", \"waitid_result\"]\nif sys.platform != \"win32\" or sys.version_info >= (3, 13):\n    __all__ += [\"fchmod\"]\n    if sys.platform != \"linux\":\n        __all__ += [\"lchmod\"]\nif sys.platform != \"win32\" or sys.version_info >= (3, 12):\n    __all__ += [\"get_blocking\", \"set_blocking\"]\nif sys.platform != \"win32\" or sys.version_info >= (3, 11):\n    __all__ += [\"EX_OK\"]\n\n# This unnecessary alias is to work around various errors\npath = _path\n\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n\n# ----- os variables -----\n\nerror = OSError\n\nsupports_bytes_environ: bool\n\nsupports_dir_fd: set[Callable[..., Any]]\nsupports_fd: set[Callable[..., Any]]\nsupports_effective_ids: set[Callable[..., Any]]\nsupports_follow_symlinks: set[Callable[..., Any]]\n\nif sys.platform != \"win32\":\n    # Unix only\n    PRIO_PROCESS: Final[int]\n    PRIO_PGRP: Final[int]\n    PRIO_USER: Final[int]\n\n    F_LOCK: Final[int]\n    F_TLOCK: Final[int]\n    F_ULOCK: Final[int]\n    F_TEST: Final[int]\n\n    if sys.platform != \"darwin\":\n        POSIX_FADV_NORMAL: Final[int]\n        POSIX_FADV_SEQUENTIAL: Final[int]\n        POSIX_FADV_RANDOM: Final[int]\n        POSIX_FADV_NOREUSE: Final[int]\n        POSIX_FADV_WILLNEED: Final[int]\n        POSIX_FADV_DONTNEED: Final[int]\n\n    if sys.platform != \"linux\" and sys.platform != \"darwin\":\n        # In the os-module docs, these are marked as being available\n        # on \"Unix, not Emscripten, not WASI.\"\n        # However, in the source code, a comment indicates they're \"FreeBSD constants\".\n        # sys.platform could have one of many values on a FreeBSD Python build,\n        # so the sys-module docs recommend doing `if sys.platform.startswith('freebsd')`\n        # to detect FreeBSD builds. Unfortunately that would be too dynamic\n        # for type checkers, however.\n        SF_NODISKIO: Final[int]\n        SF_MNOWAIT: Final[int]\n        SF_SYNC: Final[int]\n\n        if sys.version_info >= (3, 11):\n            SF_NOCACHE: Final[int]\n\n    if sys.platform == \"linux\":\n        XATTR_SIZE_MAX: Final[int]\n        XATTR_CREATE: Final[int]\n        XATTR_REPLACE: Final[int]\n\n    P_PID: Final[int]\n    P_PGID: Final[int]\n    P_ALL: Final[int]\n\n    if sys.platform == \"linux\":\n        P_PIDFD: Final[int]\n\n    WEXITED: Final[int]\n    WSTOPPED: Final[int]\n    WNOWAIT: Final[int]\n\n    CLD_EXITED: Final[int]\n    CLD_DUMPED: Final[int]\n    CLD_TRAPPED: Final[int]\n    CLD_CONTINUED: Final[int]\n    CLD_KILLED: Final[int]\n    CLD_STOPPED: Final[int]\n\n    SCHED_OTHER: Final[int]\n    SCHED_FIFO: Final[int]\n    SCHED_RR: Final[int]\n    if sys.platform != \"darwin\" and sys.platform != \"linux\":\n        SCHED_SPORADIC: Final[int]\n\nif sys.platform == \"linux\":\n    SCHED_BATCH: Final[int]\n    SCHED_IDLE: Final[int]\n    SCHED_RESET_ON_FORK: Final[int]\n\nif sys.version_info >= (3, 14) and sys.platform == \"linux\":\n    SCHED_DEADLINE: Final[int]\n    SCHED_NORMAL: Final[int]\n\nif sys.platform != \"win32\":\n    RTLD_LAZY: Final[int]\n    RTLD_NOW: Final[int]\n    RTLD_GLOBAL: Final[int]\n    RTLD_LOCAL: Final[int]\n    RTLD_NODELETE: Final[int]\n    RTLD_NOLOAD: Final[int]\n\nif sys.platform == \"linux\":\n    RTLD_DEEPBIND: Final[int]\n    GRND_NONBLOCK: Final[int]\n    GRND_RANDOM: Final[int]\n\nif sys.platform == \"darwin\" and sys.version_info >= (3, 12):\n    PRIO_DARWIN_BG: Final[int]\n    PRIO_DARWIN_NONUI: Final[int]\n    PRIO_DARWIN_PROCESS: Final[int]\n    PRIO_DARWIN_THREAD: Final[int]\n\nSEEK_SET: Final = 0\nSEEK_CUR: Final = 1\nSEEK_END: Final = 2\nif sys.platform != \"win32\":\n    SEEK_DATA: Final = 3\n    SEEK_HOLE: Final = 4\n\nO_RDONLY: Final[int]\nO_WRONLY: Final[int]\nO_RDWR: Final[int]\nO_APPEND: Final[int]\nO_CREAT: Final[int]\nO_EXCL: Final[int]\nO_TRUNC: Final[int]\nif sys.platform == \"win32\":\n    O_BINARY: Final[int]\n    O_NOINHERIT: Final[int]\n    O_SHORT_LIVED: Final[int]\n    O_TEMPORARY: Final[int]\n    O_RANDOM: Final[int]\n    O_SEQUENTIAL: Final[int]\n    O_TEXT: Final[int]\n\nif sys.platform != \"win32\":\n    O_DSYNC: Final[int]\n    O_SYNC: Final[int]\n    O_NDELAY: Final[int]\n    O_NONBLOCK: Final[int]\n    O_NOCTTY: Final[int]\n    O_CLOEXEC: Final[int]\n    O_ASYNC: Final[int]  # Gnu extension if in C library\n    O_DIRECTORY: Final[int]  # Gnu extension if in C library\n    O_NOFOLLOW: Final[int]  # Gnu extension if in C library\n    O_ACCMODE: Final[int]  # TODO: when does this exist?\n\nif sys.platform == \"linux\":\n    O_RSYNC: Final[int]\n    O_DIRECT: Final[int]  # Gnu extension if in C library\n    O_NOATIME: Final[int]  # Gnu extension if in C library\n    O_PATH: Final[int]  # Gnu extension if in C library\n    O_TMPFILE: Final[int]  # Gnu extension if in C library\n    O_LARGEFILE: Final[int]  # Gnu extension if in C library\n\nif sys.platform != \"linux\" and sys.platform != \"win32\":\n    O_SHLOCK: Final[int]\n    O_EXLOCK: Final[int]\n\nif sys.platform == \"darwin\" and sys.version_info >= (3, 10):\n    O_EVTONLY: Final[int]\n    O_NOFOLLOW_ANY: Final[int]\n    O_SYMLINK: Final[int]\n\nif sys.platform != \"win32\" and sys.version_info >= (3, 10):\n    O_FSYNC: Final[int]\n\nif sys.platform != \"linux\" and sys.platform != \"win32\" and sys.version_info >= (3, 13):\n    O_EXEC: Final[int]\n    O_SEARCH: Final[int]\n\nif sys.platform != \"win32\" and sys.platform != \"darwin\":\n    # posix, but apparently missing on macos\n    ST_APPEND: Final[int]\n    ST_MANDLOCK: Final[int]\n    ST_NOATIME: Final[int]\n    ST_NODEV: Final[int]\n    ST_NODIRATIME: Final[int]\n    ST_NOEXEC: Final[int]\n    ST_RELATIME: Final[int]\n    ST_SYNCHRONOUS: Final[int]\n    ST_WRITE: Final[int]\n\nif sys.platform != \"win32\":\n    NGROUPS_MAX: Final[int]\n    ST_NOSUID: Final[int]\n    ST_RDONLY: Final[int]\n\nlinesep: Literal[\"\\n\", \"\\r\\n\"]\nname: LiteralString\n\nF_OK: Final = 0\nR_OK: Final = 4\nW_OK: Final = 2\nX_OK: Final = 1\n\n_EnvironCodeFunc: TypeAlias = Callable[[AnyStr], AnyStr]\n\nclass _Environ(MutableMapping[AnyStr, AnyStr], Generic[AnyStr]):\n    encodekey: _EnvironCodeFunc[AnyStr]\n    decodekey: _EnvironCodeFunc[AnyStr]\n    encodevalue: _EnvironCodeFunc[AnyStr]\n    decodevalue: _EnvironCodeFunc[AnyStr]\n    def __init__(\n        self,\n        data: MutableMapping[AnyStr, AnyStr],\n        encodekey: _EnvironCodeFunc[AnyStr],\n        decodekey: _EnvironCodeFunc[AnyStr],\n        encodevalue: _EnvironCodeFunc[AnyStr],\n        decodevalue: _EnvironCodeFunc[AnyStr],\n    ) -> None: ...\n    @overload\n    def get(self, key: AnyStr, default: None = None) -> AnyStr | None: ...\n    @overload\n    def get(self, key: AnyStr, default: AnyStr) -> AnyStr: ...\n    @overload\n    def get(self, key: AnyStr, default: _T) -> AnyStr | _T: ...\n    @overload\n    def pop(self, key: AnyStr) -> AnyStr: ...\n    @overload\n    def pop(self, key: AnyStr, default: AnyStr) -> AnyStr: ...\n    @overload\n    def pop(self, key: AnyStr, default: _T) -> AnyStr | _T: ...\n    def setdefault(self, key: AnyStr, value: AnyStr) -> AnyStr: ...\n    def copy(self) -> dict[AnyStr, AnyStr]: ...\n    def __delitem__(self, key: AnyStr) -> None: ...\n    def __getitem__(self, key: AnyStr) -> AnyStr: ...\n    def __setitem__(self, key: AnyStr, value: AnyStr) -> None: ...\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    def __len__(self) -> int: ...\n    def __or__(self, other: Mapping[_T1, _T2]) -> dict[AnyStr | _T1, AnyStr | _T2]: ...\n    def __ror__(self, other: Mapping[_T1, _T2]) -> dict[AnyStr | _T1, AnyStr | _T2]: ...\n    # We use @overload instead of a Union for reasons similar to those given for\n    # overloading MutableMapping.update in stdlib/typing.pyi\n    # The type: ignore is needed due to incompatible __or__/__ior__ signatures\n    @overload  # type: ignore[misc]\n    def __ior__(self, other: Mapping[AnyStr, AnyStr]) -> Self: ...\n    @overload\n    def __ior__(self, other: Iterable[tuple[AnyStr, AnyStr]]) -> Self: ...\n\nenviron: _Environ[str]\nif sys.platform != \"win32\":\n    environb: _Environ[bytes]\n\nif sys.version_info >= (3, 14):\n    def reload_environ() -> None: ...\n\nif sys.version_info >= (3, 11) or sys.platform != \"win32\":\n    EX_OK: Final[int]\n\nif sys.platform != \"win32\":\n    confstr_names: dict[str, int]\n    pathconf_names: dict[str, int]\n    sysconf_names: dict[str, int]\n\n    EX_USAGE: Final[int]\n    EX_DATAERR: Final[int]\n    EX_NOINPUT: Final[int]\n    EX_NOUSER: Final[int]\n    EX_NOHOST: Final[int]\n    EX_UNAVAILABLE: Final[int]\n    EX_SOFTWARE: Final[int]\n    EX_OSERR: Final[int]\n    EX_OSFILE: Final[int]\n    EX_CANTCREAT: Final[int]\n    EX_IOERR: Final[int]\n    EX_TEMPFAIL: Final[int]\n    EX_PROTOCOL: Final[int]\n    EX_NOPERM: Final[int]\n    EX_CONFIG: Final[int]\n\n# Exists on some Unix platforms, e.g. Solaris.\nif sys.platform != \"win32\" and sys.platform != \"darwin\" and sys.platform != \"linux\":\n    EX_NOTFOUND: Final[int]\n\nP_NOWAIT: Final[int]\nP_NOWAITO: Final[int]\nP_WAIT: Final[int]\nif sys.platform == \"win32\":\n    P_DETACH: Final[int]\n    P_OVERLAY: Final[int]\n\n# wait()/waitpid() options\nif sys.platform != \"win32\":\n    WNOHANG: Final[int]  # Unix only\n    WCONTINUED: Final[int]  # some Unix systems\n    WUNTRACED: Final[int]  # Unix only\n\nTMP_MAX: Final[int]  # Undocumented, but used by tempfile\n\n# ----- os classes (structures) -----\n@final\nclass stat_result(structseq[float], tuple[int, int, int, int, int, int, int, float, float, float]):\n    # The constructor of this class takes an iterable of variable length (though it must be at least 10).\n    #\n    # However, this class behaves like a tuple of 10 elements,\n    # no matter how long the iterable supplied to the constructor is.\n    # https://github.com/python/typeshed/pull/6560#discussion_r767162532\n    #\n    # The 10 elements always present are st_mode, st_ino, st_dev, st_nlink,\n    # st_uid, st_gid, st_size, st_atime, st_mtime, st_ctime.\n    #\n    # More items may be added at the end by some implementations.\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"st_mode\", \"st_ino\", \"st_dev\", \"st_nlink\", \"st_uid\", \"st_gid\", \"st_size\")\n\n    @property\n    def st_mode(self) -> int: ...  # protection bits,\n    @property\n    def st_ino(self) -> int: ...  # inode number,\n    @property\n    def st_dev(self) -> int: ...  # device,\n    @property\n    def st_nlink(self) -> int: ...  # number of hard links,\n    @property\n    def st_uid(self) -> int: ...  # user id of owner,\n    @property\n    def st_gid(self) -> int: ...  # group id of owner,\n    @property\n    def st_size(self) -> int: ...  # size of file, in bytes,\n    @property\n    def st_atime(self) -> float: ...  # time of most recent access,\n    @property\n    def st_mtime(self) -> float: ...  # time of most recent content modification,\n    # platform dependent (time of most recent metadata change on Unix, or the time of creation on Windows)\n    if sys.version_info >= (3, 12) and sys.platform == \"win32\":\n        @property\n        @deprecated(\n            \"\"\"\\\nUse st_birthtime instead to retrieve the file creation time. \\\nIn the future, this property will contain the last metadata change time.\"\"\"\n        )\n        def st_ctime(self) -> float: ...\n    else:\n        @property\n        def st_ctime(self) -> float: ...\n\n    @property\n    def st_atime_ns(self) -> int: ...  # time of most recent access, in nanoseconds\n    @property\n    def st_mtime_ns(self) -> int: ...  # time of most recent content modification in nanoseconds\n    # platform dependent (time of most recent metadata change on Unix, or the time of creation on Windows) in nanoseconds\n    @property\n    def st_ctime_ns(self) -> int: ...\n    if sys.platform == \"win32\":\n        @property\n        def st_file_attributes(self) -> int: ...\n        @property\n        def st_reparse_tag(self) -> int: ...\n        if sys.version_info >= (3, 12):\n            @property\n            def st_birthtime(self) -> float: ...  # time of file creation in seconds\n            @property\n            def st_birthtime_ns(self) -> int: ...  # time of file creation in nanoseconds\n    else:\n        @property\n        def st_blocks(self) -> int: ...  # number of blocks allocated for file\n        @property\n        def st_blksize(self) -> int: ...  # filesystem blocksize\n        @property\n        def st_rdev(self) -> int: ...  # type of device if an inode device\n        if sys.platform != \"linux\":\n            # These properties are available on MacOS, but not Ubuntu.\n            # On other Unix systems (such as FreeBSD), the following attributes may be\n            # available (but may be only filled out if root tries to use them):\n            @property\n            def st_gen(self) -> int: ...  # file generation number\n            @property\n            def st_birthtime(self) -> float: ...  # time of file creation in seconds\n    if sys.platform == \"darwin\":\n        @property\n        def st_flags(self) -> int: ...  # user defined flags for file\n    # Attributes documented as sometimes appearing, but deliberately omitted from the stub: `st_creator`, `st_rsize`, `st_type`.\n    # See https://github.com/python/typeshed/pull/6560#issuecomment-991253327\n\n# mypy and pyright object to this being both ABC and Protocol.\n# At runtime it inherits from ABC and is not a Protocol, but it will be\n# on the allowlist for use as a Protocol starting in 3.14.\n@runtime_checkable\nclass PathLike(ABC, Protocol[AnyStr_co]):  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues]\n    __slots__ = ()\n    @abstractmethod\n    def __fspath__(self) -> AnyStr_co: ...\n\n@overload\ndef listdir(path: StrPath | None = None) -> list[str]: ...\n@overload\ndef listdir(path: BytesPath) -> list[bytes]: ...\n@overload\ndef listdir(path: int) -> list[str]: ...\n@final\nclass DirEntry(Generic[AnyStr]):\n    # This is what the scandir iterator yields\n    # The constructor is hidden\n\n    @property\n    def name(self) -> AnyStr: ...\n    @property\n    def path(self) -> AnyStr: ...\n    def inode(self) -> int: ...\n    def is_dir(self, *, follow_symlinks: bool = True) -> bool: ...\n    def is_file(self, *, follow_symlinks: bool = True) -> bool: ...\n    def is_symlink(self) -> bool: ...\n    def stat(self, *, follow_symlinks: bool = True) -> stat_result: ...\n    def __fspath__(self) -> AnyStr: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n    if sys.version_info >= (3, 12):\n        def is_junction(self) -> bool: ...\n\n@final\nclass statvfs_result(structseq[int], tuple[int, int, int, int, int, int, int, int, int, int, int]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\n            \"f_bsize\",\n            \"f_frsize\",\n            \"f_blocks\",\n            \"f_bfree\",\n            \"f_bavail\",\n            \"f_files\",\n            \"f_ffree\",\n            \"f_favail\",\n            \"f_flag\",\n            \"f_namemax\",\n        )\n\n    @property\n    def f_bsize(self) -> int: ...\n    @property\n    def f_frsize(self) -> int: ...\n    @property\n    def f_blocks(self) -> int: ...\n    @property\n    def f_bfree(self) -> int: ...\n    @property\n    def f_bavail(self) -> int: ...\n    @property\n    def f_files(self) -> int: ...\n    @property\n    def f_ffree(self) -> int: ...\n    @property\n    def f_favail(self) -> int: ...\n    @property\n    def f_flag(self) -> int: ...\n    @property\n    def f_namemax(self) -> int: ...\n    @property\n    def f_fsid(self) -> int: ...\n\n# ----- os function stubs -----\ndef fsencode(filename: StrOrBytesPath) -> bytes: ...\ndef fsdecode(filename: StrOrBytesPath) -> str: ...\n@overload\ndef fspath(path: str) -> str: ...\n@overload\ndef fspath(path: bytes) -> bytes: ...\n@overload\ndef fspath(path: PathLike[AnyStr]) -> AnyStr: ...\ndef get_exec_path(env: Mapping[str, str] | None = None) -> list[str]: ...\ndef getlogin() -> str: ...\ndef getpid() -> int: ...\ndef getppid() -> int: ...\ndef strerror(code: int, /) -> str: ...\ndef umask(mask: int, /) -> int: ...\n@final\nclass uname_result(structseq[str], tuple[str, str, str, str, str]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"sysname\", \"nodename\", \"release\", \"version\", \"machine\")\n\n    @property\n    def sysname(self) -> str: ...\n    @property\n    def nodename(self) -> str: ...\n    @property\n    def release(self) -> str: ...\n    @property\n    def version(self) -> str: ...\n    @property\n    def machine(self) -> str: ...\n\nif sys.platform != \"win32\":\n    def ctermid() -> str: ...\n    def getegid() -> int: ...\n    def geteuid() -> int: ...\n    def getgid() -> int: ...\n    def getgrouplist(user: str, group: int, /) -> list[int]: ...\n    def getgroups() -> list[int]: ...  # Unix only, behaves differently on Mac\n    def initgroups(username: str, gid: int, /) -> None: ...\n    def getpgid(pid: int) -> int: ...\n    def getpgrp() -> int: ...\n    def getpriority(which: int, who: int) -> int: ...\n    def setpriority(which: int, who: int, priority: int) -> None: ...\n    if sys.platform != \"darwin\":\n        def getresuid() -> tuple[int, int, int]: ...\n        def getresgid() -> tuple[int, int, int]: ...\n\n    def getuid() -> int: ...\n    def setegid(egid: int, /) -> None: ...\n    def seteuid(euid: int, /) -> None: ...\n    def setgid(gid: int, /) -> None: ...\n    def setgroups(groups: Sequence[int], /) -> None: ...\n    def setpgrp() -> None: ...\n    def setpgid(pid: int, pgrp: int, /) -> None: ...\n    def setregid(rgid: int, egid: int, /) -> None: ...\n    if sys.platform != \"darwin\":\n        def setresgid(rgid: int, egid: int, sgid: int, /) -> None: ...\n        def setresuid(ruid: int, euid: int, suid: int, /) -> None: ...\n\n    def setreuid(ruid: int, euid: int, /) -> None: ...\n    def getsid(pid: int, /) -> int: ...\n    def setsid() -> None: ...\n    def setuid(uid: int, /) -> None: ...\n    def uname() -> uname_result: ...\n\n@overload\ndef getenv(key: str) -> str | None: ...\n@overload\ndef getenv(key: str, default: _T) -> str | _T: ...\n\nif sys.platform != \"win32\":\n    @overload\n    def getenvb(key: bytes) -> bytes | None: ...\n    @overload\n    def getenvb(key: bytes, default: _T) -> bytes | _T: ...\n    def putenv(name: StrOrBytesPath, value: StrOrBytesPath, /) -> None: ...\n    def unsetenv(name: StrOrBytesPath, /) -> None: ...\n\nelse:\n    def putenv(name: str, value: str, /) -> None: ...\n    def unsetenv(name: str, /) -> None: ...\n\n_Opener: TypeAlias = Callable[[str, int], int]\n\n@overload\ndef fdopen(\n    fd: int,\n    mode: OpenTextMode = \"r\",\n    buffering: int = -1,\n    encoding: str | None = None,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> TextIOWrapper: ...\n@overload\ndef fdopen(\n    fd: int,\n    mode: OpenBinaryMode,\n    buffering: Literal[0],\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> FileIO: ...\n@overload\ndef fdopen(\n    fd: int,\n    mode: OpenBinaryModeUpdating,\n    buffering: Literal[-1, 1] = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BufferedRandom: ...\n@overload\ndef fdopen(\n    fd: int,\n    mode: OpenBinaryModeWriting,\n    buffering: Literal[-1, 1] = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BufferedWriter: ...\n@overload\ndef fdopen(\n    fd: int,\n    mode: OpenBinaryModeReading,\n    buffering: Literal[-1, 1] = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BufferedReader: ...\n@overload\ndef fdopen(\n    fd: int,\n    mode: OpenBinaryMode,\n    buffering: int = -1,\n    encoding: None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> BinaryIO: ...\n@overload\ndef fdopen(\n    fd: int,\n    mode: str,\n    buffering: int = -1,\n    encoding: str | None = None,\n    errors: str | None = ...,\n    newline: str | None = ...,\n    closefd: bool = ...,\n    opener: _Opener | None = ...,\n) -> IO[Any]: ...\ndef close(fd: int) -> None: ...\ndef closerange(fd_low: int, fd_high: int, /) -> None: ...\ndef device_encoding(fd: int) -> str | None: ...\ndef dup(fd: int, /) -> int: ...\ndef dup2(fd: int, fd2: int, inheritable: bool = True) -> int: ...\ndef fstat(fd: int) -> stat_result: ...\ndef ftruncate(fd: int, length: int, /) -> None: ...\ndef fsync(fd: FileDescriptorLike) -> None: ...\ndef isatty(fd: int, /) -> bool: ...\n\nif sys.platform != \"win32\" and sys.version_info >= (3, 11):\n    def login_tty(fd: int, /) -> None: ...\n\nif sys.version_info >= (3, 11):\n    def lseek(fd: int, position: int, whence: int, /) -> int: ...\n\nelse:\n    def lseek(fd: int, position: int, how: int, /) -> int: ...\n\ndef open(path: StrOrBytesPath, flags: int, mode: int = 0o777, *, dir_fd: int | None = None) -> int: ...\ndef pipe() -> tuple[int, int]: ...\ndef read(fd: int, length: int, /) -> bytes: ...\n\nif sys.version_info >= (3, 12) or sys.platform != \"win32\":\n    def get_blocking(fd: int, /) -> bool: ...\n    def set_blocking(fd: int, blocking: bool, /) -> None: ...\n\nif sys.platform != \"win32\":\n    def fchown(fd: int, uid: int, gid: int) -> None: ...\n    def fpathconf(fd: int, name: str | int, /) -> int: ...\n    def fstatvfs(fd: int, /) -> statvfs_result: ...\n    def lockf(fd: int, command: int, length: int, /) -> None: ...\n    def openpty() -> tuple[int, int]: ...  # some flavors of Unix\n    if sys.platform != \"darwin\":\n        def fdatasync(fd: FileDescriptorLike) -> None: ...\n        def pipe2(flags: int, /) -> tuple[int, int]: ...  # some flavors of Unix\n        def posix_fallocate(fd: int, offset: int, length: int, /) -> None: ...\n        def posix_fadvise(fd: int, offset: int, length: int, advice: int, /) -> None: ...\n\n    def pread(fd: int, length: int, offset: int, /) -> bytes: ...\n    def pwrite(fd: int, buffer: ReadableBuffer, offset: int, /) -> int: ...\n    # In CI, stubtest sometimes reports that these are available on MacOS, sometimes not\n    def preadv(fd: int, buffers: SupportsLenAndGetItem[WriteableBuffer], offset: int, flags: int = 0, /) -> int: ...\n    def pwritev(fd: int, buffers: SupportsLenAndGetItem[ReadableBuffer], offset: int, flags: int = 0, /) -> int: ...\n    if sys.platform != \"darwin\":\n        if sys.version_info >= (3, 10):\n            RWF_APPEND: Final[int]  # docs say available on 3.7+, stubtest says otherwise\n        RWF_DSYNC: Final[int]\n        RWF_SYNC: Final[int]\n        RWF_HIPRI: Final[int]\n        RWF_NOWAIT: Final[int]\n\n    if sys.platform == \"linux\":\n        def sendfile(out_fd: FileDescriptor, in_fd: FileDescriptor, offset: int | None, count: int) -> int: ...\n    else:\n        def sendfile(\n            out_fd: FileDescriptor,\n            in_fd: FileDescriptor,\n            offset: int,\n            count: int,\n            headers: Sequence[ReadableBuffer] = (),\n            trailers: Sequence[ReadableBuffer] = (),\n            flags: int = 0,\n        ) -> int: ...  # FreeBSD and Mac OS X only\n\n    def readv(fd: int, buffers: SupportsLenAndGetItem[WriteableBuffer], /) -> int: ...\n    def writev(fd: int, buffers: SupportsLenAndGetItem[ReadableBuffer], /) -> int: ...\n\nif sys.version_info >= (3, 14):\n    def readinto(fd: int, buffer: ReadableBuffer, /) -> int: ...\n\n@final\nclass terminal_size(structseq[int], tuple[int, int]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"columns\", \"lines\")\n\n    @property\n    def columns(self) -> int: ...\n    @property\n    def lines(self) -> int: ...\n\ndef get_terminal_size(fd: int = ..., /) -> terminal_size: ...\ndef get_inheritable(fd: int, /) -> bool: ...\ndef set_inheritable(fd: int, inheritable: bool, /) -> None: ...\n\nif sys.platform == \"win32\":\n    def get_handle_inheritable(handle: int, /) -> bool: ...\n    def set_handle_inheritable(handle: int, inheritable: bool, /) -> None: ...\n\nif sys.platform != \"win32\":\n    # Unix only\n    def tcgetpgrp(fd: int, /) -> int: ...\n    def tcsetpgrp(fd: int, pgid: int, /) -> None: ...\n    def ttyname(fd: int, /) -> str: ...\n\ndef write(fd: int, data: ReadableBuffer, /) -> int: ...\ndef access(\n    path: FileDescriptorOrPath, mode: int, *, dir_fd: int | None = None, effective_ids: bool = False, follow_symlinks: bool = True\n) -> bool: ...\ndef chdir(path: FileDescriptorOrPath) -> None: ...\n\nif sys.platform != \"win32\":\n    def fchdir(fd: FileDescriptorLike) -> None: ...\n\ndef getcwd() -> str: ...\ndef getcwdb() -> bytes: ...\ndef chmod(path: FileDescriptorOrPath, mode: int, *, dir_fd: int | None = None, follow_symlinks: bool = True) -> None: ...\n\nif sys.platform != \"win32\" and sys.platform != \"linux\":\n    def chflags(path: StrOrBytesPath, flags: int, follow_symlinks: bool = True) -> None: ...  # some flavors of Unix\n    def lchflags(path: StrOrBytesPath, flags: int) -> None: ...\n\nif sys.platform != \"win32\":\n    def chroot(path: StrOrBytesPath) -> None: ...\n    def chown(\n        path: FileDescriptorOrPath, uid: int, gid: int, *, dir_fd: int | None = None, follow_symlinks: bool = True\n    ) -> None: ...\n    def lchown(path: StrOrBytesPath, uid: int, gid: int) -> None: ...\n\ndef link(\n    src: StrOrBytesPath,\n    dst: StrOrBytesPath,\n    *,\n    src_dir_fd: int | None = None,\n    dst_dir_fd: int | None = None,\n    follow_symlinks: bool = True,\n) -> None: ...\ndef lstat(path: StrOrBytesPath, *, dir_fd: int | None = None) -> stat_result: ...\ndef mkdir(path: StrOrBytesPath, mode: int = 0o777, *, dir_fd: int | None = None) -> None: ...\n\nif sys.platform != \"win32\":\n    def mkfifo(path: StrOrBytesPath, mode: int = 0o666, *, dir_fd: int | None = None) -> None: ...  # Unix only\n\ndef makedirs(name: StrOrBytesPath, mode: int = 0o777, exist_ok: bool = False) -> None: ...\n\nif sys.platform != \"win32\":\n    def mknod(path: StrOrBytesPath, mode: int = 0o600, device: int = 0, *, dir_fd: int | None = None) -> None: ...\n    def major(device: int, /) -> int: ...\n    def minor(device: int, /) -> int: ...\n    def makedev(major: int, minor: int, /) -> int: ...\n    def pathconf(path: FileDescriptorOrPath, name: str | int) -> int: ...  # Unix only\n\ndef readlink(path: GenericPath[AnyStr], *, dir_fd: int | None = None) -> AnyStr: ...\ndef remove(path: StrOrBytesPath, *, dir_fd: int | None = None) -> None: ...\ndef removedirs(name: StrOrBytesPath) -> None: ...\ndef rename(src: StrOrBytesPath, dst: StrOrBytesPath, *, src_dir_fd: int | None = None, dst_dir_fd: int | None = None) -> None: ...\ndef renames(old: StrOrBytesPath, new: StrOrBytesPath) -> None: ...\ndef replace(\n    src: StrOrBytesPath, dst: StrOrBytesPath, *, src_dir_fd: int | None = None, dst_dir_fd: int | None = None\n) -> None: ...\ndef rmdir(path: StrOrBytesPath, *, dir_fd: int | None = None) -> None: ...\n@final\n@type_check_only\nclass _ScandirIterator(Generic[AnyStr]):\n    def __del__(self) -> None: ...\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> DirEntry[AnyStr]: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(self, *args: Unused) -> None: ...\n    def close(self) -> None: ...\n\n@overload\ndef scandir(path: None = None) -> _ScandirIterator[str]: ...\n@overload\ndef scandir(path: int) -> _ScandirIterator[str]: ...\n@overload\ndef scandir(path: GenericPath[AnyStr]) -> _ScandirIterator[AnyStr]: ...\ndef stat(path: FileDescriptorOrPath, *, dir_fd: int | None = None, follow_symlinks: bool = True) -> stat_result: ...\n\nif sys.platform != \"win32\":\n    def statvfs(path: FileDescriptorOrPath) -> statvfs_result: ...  # Unix only\n\ndef symlink(\n    src: StrOrBytesPath, dst: StrOrBytesPath, target_is_directory: bool = False, *, dir_fd: int | None = None\n) -> None: ...\n\nif sys.platform != \"win32\":\n    def sync() -> None: ...  # Unix only\n\ndef truncate(path: FileDescriptorOrPath, length: int) -> None: ...  # Unix only up to version 3.4\ndef unlink(path: StrOrBytesPath, *, dir_fd: int | None = None) -> None: ...\ndef utime(\n    path: FileDescriptorOrPath,\n    times: tuple[int, int] | tuple[float, float] | None = None,\n    *,\n    ns: tuple[int, int] = ...,\n    dir_fd: int | None = None,\n    follow_symlinks: bool = True,\n) -> None: ...\n\n_OnError: TypeAlias = Callable[[OSError], object]\n\ndef walk(\n    top: GenericPath[AnyStr], topdown: bool = True, onerror: _OnError | None = None, followlinks: bool = False\n) -> Iterator[tuple[AnyStr, list[AnyStr], list[AnyStr]]]: ...\n\nif sys.platform != \"win32\":\n    @overload\n    def fwalk(\n        top: StrPath = \".\",\n        topdown: bool = True,\n        onerror: _OnError | None = None,\n        *,\n        follow_symlinks: bool = False,\n        dir_fd: int | None = None,\n    ) -> Iterator[tuple[str, list[str], list[str], int]]: ...\n    @overload\n    def fwalk(\n        top: BytesPath,\n        topdown: bool = True,\n        onerror: _OnError | None = None,\n        *,\n        follow_symlinks: bool = False,\n        dir_fd: int | None = None,\n    ) -> Iterator[tuple[bytes, list[bytes], list[bytes], int]]: ...\n    if sys.platform == \"linux\":\n        def getxattr(path: FileDescriptorOrPath, attribute: StrOrBytesPath, *, follow_symlinks: bool = True) -> bytes: ...\n        def listxattr(path: FileDescriptorOrPath | None = None, *, follow_symlinks: bool = True) -> list[str]: ...\n        def removexattr(path: FileDescriptorOrPath, attribute: StrOrBytesPath, *, follow_symlinks: bool = True) -> None: ...\n        def setxattr(\n            path: FileDescriptorOrPath,\n            attribute: StrOrBytesPath,\n            value: ReadableBuffer,\n            flags: int = 0,\n            *,\n            follow_symlinks: bool = True,\n        ) -> None: ...\n\ndef abort() -> NoReturn: ...\n\n# These are defined as execl(file, *args) but the first *arg is mandatory.\ndef execl(file: StrOrBytesPath, *args: Unpack[tuple[StrOrBytesPath, Unpack[tuple[StrOrBytesPath, ...]]]]) -> NoReturn: ...\ndef execlp(file: StrOrBytesPath, *args: Unpack[tuple[StrOrBytesPath, Unpack[tuple[StrOrBytesPath, ...]]]]) -> NoReturn: ...\n\n# These are: execle(file, *args, env) but env is pulled from the last element of the args.\ndef execle(\n    file: StrOrBytesPath, *args: Unpack[tuple[StrOrBytesPath, Unpack[tuple[StrOrBytesPath, ...]], _ExecEnv]]\n) -> NoReturn: ...\ndef execlpe(\n    file: StrOrBytesPath, *args: Unpack[tuple[StrOrBytesPath, Unpack[tuple[StrOrBytesPath, ...]], _ExecEnv]]\n) -> NoReturn: ...\n\n# The docs say `args: tuple or list of strings`\n# The implementation enforces tuple or list so we can't use Sequence.\n# Not separating out PathLike[str] and PathLike[bytes] here because it doesn't make much difference\n# in practice, and doing so would explode the number of combinations in this already long union.\n# All these combinations are necessary due to list being invariant.\n_ExecVArgs: TypeAlias = (\n    tuple[StrOrBytesPath, ...]\n    | list[bytes]\n    | list[str]\n    | list[PathLike[Any]]\n    | list[bytes | str]\n    | list[bytes | PathLike[Any]]\n    | list[str | PathLike[Any]]\n    | list[bytes | str | PathLike[Any]]\n)\n# Depending on the OS, the keys and values are passed either to\n# PyUnicode_FSDecoder (which accepts str | ReadableBuffer) or to\n# PyUnicode_FSConverter (which accepts StrOrBytesPath). For simplicity,\n# we limit to str | bytes.\n_ExecEnv: TypeAlias = Mapping[bytes, bytes | str] | Mapping[str, bytes | str]\n\ndef execv(path: StrOrBytesPath, argv: _ExecVArgs, /) -> NoReturn: ...\ndef execve(path: FileDescriptorOrPath, argv: _ExecVArgs, env: _ExecEnv) -> NoReturn: ...\ndef execvp(file: StrOrBytesPath, args: _ExecVArgs) -> NoReturn: ...\ndef execvpe(file: StrOrBytesPath, args: _ExecVArgs, env: _ExecEnv) -> NoReturn: ...\ndef _exit(status: int) -> NoReturn: ...\ndef kill(pid: int, signal: int, /) -> None: ...\n\nif sys.platform != \"win32\":\n    # Unix only\n    def fork() -> int: ...\n    def forkpty() -> tuple[int, int]: ...  # some flavors of Unix\n    def killpg(pgid: int, signal: int, /) -> None: ...\n    def nice(increment: int, /) -> int: ...\n    if sys.platform != \"darwin\" and sys.platform != \"linux\":\n        def plock(op: int, /) -> None: ...\n\nclass _wrap_close:\n    def __init__(self, stream: TextIOWrapper, proc: Popen[str]) -> None: ...\n    def close(self) -> int | None: ...\n    def __enter__(self) -> Self: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> None: ...\n    def __iter__(self) -> Iterator[str]: ...\n    # Methods below here don't exist directly on the _wrap_close object, but\n    # are copied from the wrapped TextIOWrapper object via __getattr__.\n    # The full set of TextIOWrapper methods are technically available this way,\n    # but undocumented. Only a subset are currently included here.\n    def read(self, size: int | None = -1, /) -> str: ...\n    def readable(self) -> bool: ...\n    def readline(self, size: int = -1, /) -> str: ...\n    def readlines(self, hint: int = -1, /) -> list[str]: ...\n    def writable(self) -> bool: ...\n    def write(self, s: str, /) -> int: ...\n    def writelines(self, lines: Iterable[str], /) -> None: ...\n\nif sys.version_info >= (3, 14):\n    @deprecated(\"Soft deprecated. Use the subprocess module instead.\")\n    def popen(cmd: str, mode: str = \"r\", buffering: int = -1) -> _wrap_close: ...\n    @deprecated(\"Soft deprecated. Use the subprocess module instead.\")\n    def spawnl(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: StrOrBytesPath) -> int: ...\n    @deprecated(\"Soft deprecated. Use the subprocess module instead.\")\n    def spawnle(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: Any) -> int: ...  # Imprecise sig\n\nelse:\n    def popen(cmd: str, mode: str = \"r\", buffering: int = -1) -> _wrap_close: ...\n    def spawnl(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: StrOrBytesPath) -> int: ...\n    def spawnle(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: Any) -> int: ...  # Imprecise sig\n\nif sys.platform != \"win32\":\n    if sys.version_info >= (3, 14):\n        @deprecated(\"Soft deprecated. Use the subprocess module instead.\")\n        def spawnv(mode: int, file: StrOrBytesPath, args: _ExecVArgs) -> int: ...\n        @deprecated(\"Soft deprecated. Use the subprocess module instead.\")\n        def spawnve(mode: int, file: StrOrBytesPath, args: _ExecVArgs, env: _ExecEnv) -> int: ...\n\n    else:\n        def spawnv(mode: int, file: StrOrBytesPath, args: _ExecVArgs) -> int: ...\n        def spawnve(mode: int, file: StrOrBytesPath, args: _ExecVArgs, env: _ExecEnv) -> int: ...\n\nelse:\n    if sys.version_info >= (3, 14):\n        @deprecated(\"Soft deprecated. Use the subprocess module instead.\")\n        def spawnv(mode: int, path: StrOrBytesPath, argv: _ExecVArgs, /) -> int: ...\n        @deprecated(\"Soft deprecated. Use the subprocess module instead.\")\n        def spawnve(mode: int, path: StrOrBytesPath, argv: _ExecVArgs, env: _ExecEnv, /) -> int: ...\n\n    else:\n        def spawnv(mode: int, path: StrOrBytesPath, argv: _ExecVArgs, /) -> int: ...\n        def spawnve(mode: int, path: StrOrBytesPath, argv: _ExecVArgs, env: _ExecEnv, /) -> int: ...\n\nif sys.version_info >= (3, 14):\n    @deprecated(\"Soft deprecated. Use the subprocess module instead.\")\n    def system(command: StrOrBytesPath) -> int: ...\n\nelse:\n    def system(command: StrOrBytesPath) -> int: ...\n\n@final\nclass times_result(structseq[float], tuple[float, float, float, float, float]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"user\", \"system\", \"children_user\", \"children_system\", \"elapsed\")\n\n    @property\n    def user(self) -> float: ...\n    @property\n    def system(self) -> float: ...\n    @property\n    def children_user(self) -> float: ...\n    @property\n    def children_system(self) -> float: ...\n    @property\n    def elapsed(self) -> float: ...\n\ndef times() -> times_result: ...\ndef waitpid(pid: int, options: int, /) -> tuple[int, int]: ...\n\nif sys.platform == \"win32\":\n    if sys.version_info >= (3, 10):\n        def startfile(\n            filepath: StrOrBytesPath,\n            operation: str = ...,\n            arguments: str = \"\",\n            cwd: StrOrBytesPath | None = None,\n            show_cmd: int = 1,\n        ) -> None: ...\n    else:\n        def startfile(filepath: StrOrBytesPath, operation: str = ...) -> None: ...\n\nelse:\n    if sys.version_info >= (3, 14):\n        @deprecated(\"Soft deprecated. Use the subprocess module instead.\")\n        def spawnlp(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: StrOrBytesPath) -> int: ...\n        @deprecated(\"Soft deprecated. Use the subprocess module instead.\")\n        def spawnlpe(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: Any) -> int: ...  # Imprecise signature\n        @deprecated(\"Soft deprecated. Use the subprocess module instead.\")\n        def spawnvp(mode: int, file: StrOrBytesPath, args: _ExecVArgs) -> int: ...\n        @deprecated(\"Soft deprecated. Use the subprocess module instead.\")\n        def spawnvpe(mode: int, file: StrOrBytesPath, args: _ExecVArgs, env: _ExecEnv) -> int: ...\n\n    else:\n        def spawnlp(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: StrOrBytesPath) -> int: ...\n        def spawnlpe(mode: int, file: StrOrBytesPath, arg0: StrOrBytesPath, *args: Any) -> int: ...  # Imprecise signature\n        def spawnvp(mode: int, file: StrOrBytesPath, args: _ExecVArgs) -> int: ...\n        def spawnvpe(mode: int, file: StrOrBytesPath, args: _ExecVArgs, env: _ExecEnv) -> int: ...\n\n    def wait() -> tuple[int, int]: ...  # Unix only\n    # Added to MacOS in 3.13\n    if sys.platform != \"darwin\" or sys.version_info >= (3, 13):\n        @final\n        class waitid_result(structseq[int], tuple[int, int, int, int, int]):\n            if sys.version_info >= (3, 10):\n                __match_args__: Final = (\"si_pid\", \"si_uid\", \"si_signo\", \"si_status\", \"si_code\")\n\n            @property\n            def si_pid(self) -> int: ...\n            @property\n            def si_uid(self) -> int: ...\n            @property\n            def si_signo(self) -> int: ...\n            @property\n            def si_status(self) -> int: ...\n            @property\n            def si_code(self) -> int: ...\n\n        def waitid(idtype: int, ident: int, options: int, /) -> waitid_result | None: ...\n\n    from resource import struct_rusage\n\n    def wait3(options: int) -> tuple[int, int, struct_rusage]: ...\n    def wait4(pid: int, options: int) -> tuple[int, int, struct_rusage]: ...\n    def WCOREDUMP(status: int, /) -> bool: ...\n    def WIFCONTINUED(status: int) -> bool: ...\n    def WIFSTOPPED(status: int) -> bool: ...\n    def WIFSIGNALED(status: int) -> bool: ...\n    def WIFEXITED(status: int) -> bool: ...\n    def WEXITSTATUS(status: int) -> int: ...\n    def WSTOPSIG(status: int) -> int: ...\n    def WTERMSIG(status: int) -> int: ...\n\n    if sys.version_info >= (3, 13):\n        def posix_spawn(\n            path: StrOrBytesPath,\n            argv: _ExecVArgs,\n            env: _ExecEnv | None,  # None allowed starting in 3.13\n            /,\n            *,\n            file_actions: Sequence[tuple[Any, ...]] | None = ...,\n            setpgroup: int | None = ...,\n            resetids: bool = ...,\n            setsid: bool = ...,\n            setsigmask: Iterable[int] = ...,\n            setsigdef: Iterable[int] = ...,\n            scheduler: tuple[Any, sched_param] | None = ...,\n        ) -> int: ...\n        def posix_spawnp(\n            path: StrOrBytesPath,\n            argv: _ExecVArgs,\n            env: _ExecEnv | None,  # None allowed starting in 3.13\n            /,\n            *,\n            file_actions: Sequence[tuple[Any, ...]] | None = ...,\n            setpgroup: int | None = ...,\n            resetids: bool = ...,\n            setsid: bool = ...,\n            setsigmask: Iterable[int] = ...,\n            setsigdef: Iterable[int] = ...,\n            scheduler: tuple[Any, sched_param] | None = ...,\n        ) -> int: ...\n    else:\n        def posix_spawn(\n            path: StrOrBytesPath,\n            argv: _ExecVArgs,\n            env: _ExecEnv,\n            /,\n            *,\n            file_actions: Sequence[tuple[Any, ...]] | None = ...,\n            setpgroup: int | None = ...,\n            resetids: bool = ...,\n            setsid: bool = ...,\n            setsigmask: Iterable[int] = ...,\n            setsigdef: Iterable[int] = ...,\n            scheduler: tuple[Any, sched_param] | None = ...,\n        ) -> int: ...\n        def posix_spawnp(\n            path: StrOrBytesPath,\n            argv: _ExecVArgs,\n            env: _ExecEnv,\n            /,\n            *,\n            file_actions: Sequence[tuple[Any, ...]] | None = ...,\n            setpgroup: int | None = ...,\n            resetids: bool = ...,\n            setsid: bool = ...,\n            setsigmask: Iterable[int] = ...,\n            setsigdef: Iterable[int] = ...,\n            scheduler: tuple[Any, sched_param] | None = ...,\n        ) -> int: ...\n\n    POSIX_SPAWN_OPEN: Final = 0\n    POSIX_SPAWN_CLOSE: Final = 1\n    POSIX_SPAWN_DUP2: Final = 2\n\nif sys.platform != \"win32\":\n    @final\n    class sched_param(structseq[int], tuple[int]):\n        if sys.version_info >= (3, 10):\n            __match_args__: Final = (\"sched_priority\",)\n\n        def __new__(cls, sched_priority: int) -> Self: ...\n        @property\n        def sched_priority(self) -> int: ...\n\n    def sched_get_priority_min(policy: int) -> int: ...  # some flavors of Unix\n    def sched_get_priority_max(policy: int) -> int: ...  # some flavors of Unix\n    def sched_yield() -> None: ...  # some flavors of Unix\n    if sys.platform != \"darwin\":\n        def sched_setscheduler(pid: int, policy: int, param: sched_param, /) -> None: ...  # some flavors of Unix\n        def sched_getscheduler(pid: int, /) -> int: ...  # some flavors of Unix\n        def sched_rr_get_interval(pid: int, /) -> float: ...  # some flavors of Unix\n        def sched_setparam(pid: int, param: sched_param, /) -> None: ...  # some flavors of Unix\n        def sched_getparam(pid: int, /) -> sched_param: ...  # some flavors of Unix\n        def sched_setaffinity(pid: int, mask: Iterable[int], /) -> None: ...  # some flavors of Unix\n        def sched_getaffinity(pid: int, /) -> set[int]: ...  # some flavors of Unix\n\ndef cpu_count() -> int | None: ...\n\nif sys.version_info >= (3, 13):\n    # Documented to return `int | None`, but falls back to `len(sched_getaffinity(0))` when\n    # available. See https://github.com/python/cpython/blob/417c130/Lib/os.py#L1175-L1186.\n    if sys.platform != \"win32\" and sys.platform != \"darwin\":\n        def process_cpu_count() -> int: ...\n    else:\n        def process_cpu_count() -> int | None: ...\n\nif sys.platform != \"win32\":\n    # Unix only\n    def confstr(name: str | int, /) -> str | None: ...\n    def getloadavg() -> tuple[float, float, float]: ...\n    def sysconf(name: str | int, /) -> int: ...\n\nif sys.platform == \"linux\":\n    def getrandom(size: int, flags: int = 0) -> bytes: ...\n\ndef urandom(size: int, /) -> bytes: ...\n\nif sys.platform != \"win32\":\n    def register_at_fork(\n        *,\n        before: Callable[..., Any] | None = ...,\n        after_in_parent: Callable[..., Any] | None = ...,\n        after_in_child: Callable[..., Any] | None = ...,\n    ) -> None: ...\n\nif sys.platform == \"win32\":\n    class _AddedDllDirectory:\n        path: str | None\n        def __init__(self, path: str | None, cookie: _T, remove_dll_directory: Callable[[_T], object]) -> None: ...\n        def close(self) -> None: ...\n        def __enter__(self) -> Self: ...\n        def __exit__(self, *args: Unused) -> None: ...\n\n    def add_dll_directory(path: str) -> _AddedDllDirectory: ...\n\nif sys.platform == \"linux\":\n    MFD_CLOEXEC: Final[int]\n    MFD_ALLOW_SEALING: Final[int]\n    MFD_HUGETLB: Final[int]\n    MFD_HUGE_SHIFT: Final[int]\n    MFD_HUGE_MASK: Final[int]\n    MFD_HUGE_64KB: Final[int]\n    MFD_HUGE_512KB: Final[int]\n    MFD_HUGE_1MB: Final[int]\n    MFD_HUGE_2MB: Final[int]\n    MFD_HUGE_8MB: Final[int]\n    MFD_HUGE_16MB: Final[int]\n    MFD_HUGE_32MB: Final[int]\n    MFD_HUGE_256MB: Final[int]\n    MFD_HUGE_512MB: Final[int]\n    MFD_HUGE_1GB: Final[int]\n    MFD_HUGE_2GB: Final[int]\n    MFD_HUGE_16GB: Final[int]\n    def memfd_create(name: str, flags: int = ...) -> int: ...\n    def copy_file_range(src: int, dst: int, count: int, offset_src: int | None = ..., offset_dst: int | None = ...) -> int: ...\n\ndef waitstatus_to_exitcode(status: int) -> int: ...\n\nif sys.platform == \"linux\":\n    def pidfd_open(pid: int, flags: int = ...) -> int: ...\n\nif sys.version_info >= (3, 12) and sys.platform == \"linux\":\n    PIDFD_NONBLOCK: Final = 2048\n\nif sys.version_info >= (3, 12) and sys.platform == \"win32\":\n    def listdrives() -> list[str]: ...\n    def listmounts(volume: str) -> list[str]: ...\n    def listvolumes() -> list[str]: ...\n\nif sys.version_info >= (3, 10) and sys.platform == \"linux\":\n    EFD_CLOEXEC: Final[int]\n    EFD_NONBLOCK: Final[int]\n    EFD_SEMAPHORE: Final[int]\n    SPLICE_F_MORE: Final[int]\n    SPLICE_F_MOVE: Final[int]\n    SPLICE_F_NONBLOCK: Final[int]\n    def eventfd(initval: int, flags: int = 524288) -> FileDescriptor: ...\n    def eventfd_read(fd: FileDescriptor) -> int: ...\n    def eventfd_write(fd: FileDescriptor, value: int) -> None: ...\n    def splice(\n        src: FileDescriptor,\n        dst: FileDescriptor,\n        count: int,\n        offset_src: int | None = ...,\n        offset_dst: int | None = ...,\n        flags: int = 0,\n    ) -> int: ...\n\nif sys.version_info >= (3, 12) and sys.platform == \"linux\":\n    CLONE_FILES: Final[int]\n    CLONE_FS: Final[int]\n    CLONE_NEWCGROUP: Final[int]  # Linux 4.6+\n    CLONE_NEWIPC: Final[int]  # Linux 2.6.19+\n    CLONE_NEWNET: Final[int]  # Linux 2.6.24+\n    CLONE_NEWNS: Final[int]\n    CLONE_NEWPID: Final[int]  # Linux 3.8+\n    CLONE_NEWTIME: Final[int]  # Linux 5.6+\n    CLONE_NEWUSER: Final[int]  # Linux 3.8+\n    CLONE_NEWUTS: Final[int]  # Linux 2.6.19+\n    CLONE_SIGHAND: Final[int]\n    CLONE_SYSVSEM: Final[int]  # Linux 2.6.26+\n    CLONE_THREAD: Final[int]\n    CLONE_VM: Final[int]\n    def unshare(flags: int) -> None: ...\n    def setns(fd: FileDescriptorLike, nstype: int = 0) -> None: ...\n\nif sys.version_info >= (3, 13) and sys.platform != \"win32\":\n    def posix_openpt(oflag: int, /) -> int: ...\n    def grantpt(fd: FileDescriptorLike, /) -> None: ...\n    def unlockpt(fd: FileDescriptorLike, /) -> None: ...\n    def ptsname(fd: FileDescriptorLike, /) -> str: ...\n\nif sys.version_info >= (3, 13) and sys.platform == \"linux\":\n    TFD_TIMER_ABSTIME: Final = 1\n    TFD_TIMER_CANCEL_ON_SET: Final = 2\n    TFD_NONBLOCK: Final[int]\n    TFD_CLOEXEC: Final[int]\n    POSIX_SPAWN_CLOSEFROM: Final[int]\n\n    def timerfd_create(clockid: int, /, *, flags: int = 0) -> int: ...\n    def timerfd_settime(\n        fd: FileDescriptor, /, *, flags: int = 0, initial: float = 0.0, interval: float = 0.0\n    ) -> tuple[float, float]: ...\n    def timerfd_settime_ns(fd: FileDescriptor, /, *, flags: int = 0, initial: int = 0, interval: int = 0) -> tuple[int, int]: ...\n    def timerfd_gettime(fd: FileDescriptor, /) -> tuple[float, float]: ...\n    def timerfd_gettime_ns(fd: FileDescriptor, /) -> tuple[int, int]: ...\n\nif sys.version_info >= (3, 13) or sys.platform != \"win32\":\n    # Added to Windows in 3.13.\n    def fchmod(fd: int, mode: int) -> None: ...\n\nif sys.platform != \"linux\":\n    if sys.version_info >= (3, 13) or sys.platform != \"win32\":\n        # Added to Windows in 3.13.\n        def lchmod(path: StrOrBytesPath, mode: int) -> None: ...\n",
  "/typeshed/stdlib/os/path.pyi": "import sys\n\nif sys.platform == \"win32\":\n    from ntpath import *\n    from ntpath import __all__ as __all__\nelse:\n    from posixpath import *\n    from posixpath import __all__ as __all__\n",
  "/typeshed/stdlib/ossaudiodev.pyi": "import sys\nfrom typing import Any, Final, Literal, overload\n\nif sys.platform != \"win32\" and sys.platform != \"darwin\":\n    # Depends on soundcard.h\n    AFMT_AC3: Final[int]\n    AFMT_A_LAW: Final[int]\n    AFMT_IMA_ADPCM: Final[int]\n    AFMT_MPEG: Final[int]\n    AFMT_MU_LAW: Final[int]\n    AFMT_QUERY: Final[int]\n    AFMT_S16_BE: Final[int]\n    AFMT_S16_LE: Final[int]\n    AFMT_S16_NE: Final[int]\n    AFMT_S8: Final[int]\n    AFMT_U16_BE: Final[int]\n    AFMT_U16_LE: Final[int]\n    AFMT_U8: Final[int]\n    SNDCTL_COPR_HALT: Final[int]\n    SNDCTL_COPR_LOAD: Final[int]\n    SNDCTL_COPR_RCODE: Final[int]\n    SNDCTL_COPR_RCVMSG: Final[int]\n    SNDCTL_COPR_RDATA: Final[int]\n    SNDCTL_COPR_RESET: Final[int]\n    SNDCTL_COPR_RUN: Final[int]\n    SNDCTL_COPR_SENDMSG: Final[int]\n    SNDCTL_COPR_WCODE: Final[int]\n    SNDCTL_COPR_WDATA: Final[int]\n    SNDCTL_DSP_BIND_CHANNEL: Final[int]\n    SNDCTL_DSP_CHANNELS: Final[int]\n    SNDCTL_DSP_GETBLKSIZE: Final[int]\n    SNDCTL_DSP_GETCAPS: Final[int]\n    SNDCTL_DSP_GETCHANNELMASK: Final[int]\n    SNDCTL_DSP_GETFMTS: Final[int]\n    SNDCTL_DSP_GETIPTR: Final[int]\n    SNDCTL_DSP_GETISPACE: Final[int]\n    SNDCTL_DSP_GETODELAY: Final[int]\n    SNDCTL_DSP_GETOPTR: Final[int]\n    SNDCTL_DSP_GETOSPACE: Final[int]\n    SNDCTL_DSP_GETSPDIF: Final[int]\n    SNDCTL_DSP_GETTRIGGER: Final[int]\n    SNDCTL_DSP_MAPINBUF: Final[int]\n    SNDCTL_DSP_MAPOUTBUF: Final[int]\n    SNDCTL_DSP_NONBLOCK: Final[int]\n    SNDCTL_DSP_POST: Final[int]\n    SNDCTL_DSP_PROFILE: Final[int]\n    SNDCTL_DSP_RESET: Final[int]\n    SNDCTL_DSP_SAMPLESIZE: Final[int]\n    SNDCTL_DSP_SETDUPLEX: Final[int]\n    SNDCTL_DSP_SETFMT: Final[int]\n    SNDCTL_DSP_SETFRAGMENT: Final[int]\n    SNDCTL_DSP_SETSPDIF: Final[int]\n    SNDCTL_DSP_SETSYNCRO: Final[int]\n    SNDCTL_DSP_SETTRIGGER: Final[int]\n    SNDCTL_DSP_SPEED: Final[int]\n    SNDCTL_DSP_STEREO: Final[int]\n    SNDCTL_DSP_SUBDIVIDE: Final[int]\n    SNDCTL_DSP_SYNC: Final[int]\n    SNDCTL_FM_4OP_ENABLE: Final[int]\n    SNDCTL_FM_LOAD_INSTR: Final[int]\n    SNDCTL_MIDI_INFO: Final[int]\n    SNDCTL_MIDI_MPUCMD: Final[int]\n    SNDCTL_MIDI_MPUMODE: Final[int]\n    SNDCTL_MIDI_PRETIME: Final[int]\n    SNDCTL_SEQ_CTRLRATE: Final[int]\n    SNDCTL_SEQ_GETINCOUNT: Final[int]\n    SNDCTL_SEQ_GETOUTCOUNT: Final[int]\n    SNDCTL_SEQ_GETTIME: Final[int]\n    SNDCTL_SEQ_NRMIDIS: Final[int]\n    SNDCTL_SEQ_NRSYNTHS: Final[int]\n    SNDCTL_SEQ_OUTOFBAND: Final[int]\n    SNDCTL_SEQ_PANIC: Final[int]\n    SNDCTL_SEQ_PERCMODE: Final[int]\n    SNDCTL_SEQ_RESET: Final[int]\n    SNDCTL_SEQ_RESETSAMPLES: Final[int]\n    SNDCTL_SEQ_SYNC: Final[int]\n    SNDCTL_SEQ_TESTMIDI: Final[int]\n    SNDCTL_SEQ_THRESHOLD: Final[int]\n    SNDCTL_SYNTH_CONTROL: Final[int]\n    SNDCTL_SYNTH_ID: Final[int]\n    SNDCTL_SYNTH_INFO: Final[int]\n    SNDCTL_SYNTH_MEMAVL: Final[int]\n    SNDCTL_SYNTH_REMOVESAMPLE: Final[int]\n    SNDCTL_TMR_CONTINUE: Final[int]\n    SNDCTL_TMR_METRONOME: Final[int]\n    SNDCTL_TMR_SELECT: Final[int]\n    SNDCTL_TMR_SOURCE: Final[int]\n    SNDCTL_TMR_START: Final[int]\n    SNDCTL_TMR_STOP: Final[int]\n    SNDCTL_TMR_TEMPO: Final[int]\n    SNDCTL_TMR_TIMEBASE: Final[int]\n    SOUND_MIXER_ALTPCM: Final[int]\n    SOUND_MIXER_BASS: Final[int]\n    SOUND_MIXER_CD: Final[int]\n    SOUND_MIXER_DIGITAL1: Final[int]\n    SOUND_MIXER_DIGITAL2: Final[int]\n    SOUND_MIXER_DIGITAL3: Final[int]\n    SOUND_MIXER_IGAIN: Final[int]\n    SOUND_MIXER_IMIX: Final[int]\n    SOUND_MIXER_LINE: Final[int]\n    SOUND_MIXER_LINE1: Final[int]\n    SOUND_MIXER_LINE2: Final[int]\n    SOUND_MIXER_LINE3: Final[int]\n    SOUND_MIXER_MIC: Final[int]\n    SOUND_MIXER_MONITOR: Final[int]\n    SOUND_MIXER_NRDEVICES: Final[int]\n    SOUND_MIXER_OGAIN: Final[int]\n    SOUND_MIXER_PCM: Final[int]\n    SOUND_MIXER_PHONEIN: Final[int]\n    SOUND_MIXER_PHONEOUT: Final[int]\n    SOUND_MIXER_RADIO: Final[int]\n    SOUND_MIXER_RECLEV: Final[int]\n    SOUND_MIXER_SPEAKER: Final[int]\n    SOUND_MIXER_SYNTH: Final[int]\n    SOUND_MIXER_TREBLE: Final[int]\n    SOUND_MIXER_VIDEO: Final[int]\n    SOUND_MIXER_VOLUME: Final[int]\n\n    control_labels: list[str]\n    control_names: list[str]\n\n    # TODO: oss_audio_device return type\n    @overload\n    def open(mode: Literal[\"r\", \"w\", \"rw\"]) -> Any: ...\n    @overload\n    def open(device: str, mode: Literal[\"r\", \"w\", \"rw\"]) -> Any: ...\n\n    # TODO: oss_mixer_device return type\n    def openmixer(device: str = ...) -> Any: ...\n\n    class OSSAudioError(Exception): ...\n    error = OSSAudioError\n",
  "/typeshed/stdlib/pathlib/__init__.pyi": "import sys\nimport types\nfrom _typeshed import (\n    OpenBinaryMode,\n    OpenBinaryModeReading,\n    OpenBinaryModeUpdating,\n    OpenBinaryModeWriting,\n    OpenTextMode,\n    ReadableBuffer,\n    StrOrBytesPath,\n    StrPath,\n    Unused,\n)\nfrom collections.abc import Callable, Generator, Iterator, Sequence\nfrom io import BufferedRandom, BufferedReader, BufferedWriter, FileIO, TextIOWrapper\nfrom os import PathLike, stat_result\nfrom types import GenericAlias, TracebackType\nfrom typing import IO, Any, BinaryIO, ClassVar, Literal, TypeVar, overload\nfrom typing_extensions import Never, Self, deprecated\n\n_PathT = TypeVar(\"_PathT\", bound=PurePath)\n\n__all__ = [\"PurePath\", \"PurePosixPath\", \"PureWindowsPath\", \"Path\", \"PosixPath\", \"WindowsPath\"]\n\nif sys.version_info >= (3, 14):\n    from pathlib.types import PathInfo\n\nif sys.version_info >= (3, 13):\n    __all__ += [\"UnsupportedOperation\"]\n\nclass PurePath(PathLike[str]):\n    if sys.version_info >= (3, 13):\n        __slots__ = (\n            \"_raw_paths\",\n            \"_drv\",\n            \"_root\",\n            \"_tail_cached\",\n            \"_str\",\n            \"_str_normcase_cached\",\n            \"_parts_normcase_cached\",\n            \"_hash\",\n        )\n    elif sys.version_info >= (3, 12):\n        __slots__ = (\n            \"_raw_paths\",\n            \"_drv\",\n            \"_root\",\n            \"_tail_cached\",\n            \"_str\",\n            \"_str_normcase_cached\",\n            \"_parts_normcase_cached\",\n            \"_lines_cached\",\n            \"_hash\",\n        )\n    else:\n        __slots__ = (\"_drv\", \"_root\", \"_parts\", \"_str\", \"_hash\", \"_pparts\", \"_cached_cparts\")\n    if sys.version_info >= (3, 13):\n        parser: ClassVar[types.ModuleType]\n        def full_match(self, pattern: StrPath, *, case_sensitive: bool | None = None) -> bool: ...\n\n    @property\n    def parts(self) -> tuple[str, ...]: ...\n    @property\n    def drive(self) -> str: ...\n    @property\n    def root(self) -> str: ...\n    @property\n    def anchor(self) -> str: ...\n    @property\n    def name(self) -> str: ...\n    @property\n    def suffix(self) -> str: ...\n    @property\n    def suffixes(self) -> list[str]: ...\n    @property\n    def stem(self) -> str: ...\n    if sys.version_info >= (3, 12):\n        def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...\n        def __init__(self, *args: StrPath) -> None: ...  # pyright: ignore[reportInconsistentConstructor]\n    else:\n        def __new__(cls, *args: StrPath) -> Self: ...\n\n    def __hash__(self) -> int: ...\n    def __fspath__(self) -> str: ...\n    def __lt__(self, other: PurePath) -> bool: ...\n    def __le__(self, other: PurePath) -> bool: ...\n    def __gt__(self, other: PurePath) -> bool: ...\n    def __ge__(self, other: PurePath) -> bool: ...\n    def __truediv__(self, key: StrPath) -> Self: ...\n    def __rtruediv__(self, key: StrPath) -> Self: ...\n    def __bytes__(self) -> bytes: ...\n    def as_posix(self) -> str: ...\n    @deprecated(\"Deprecated since Python 3.14; will be removed in Python 3.19. Use `Path.as_uri()` instead.\")\n    def as_uri(self) -> str: ...\n    def is_absolute(self) -> bool: ...\n    if sys.version_info >= (3, 13):\n        @deprecated(\n            \"Deprecated since Python 3.13; will be removed in Python 3.15. \"\n            \"Use `os.path.isreserved()` to detect reserved paths on Windows.\"\n        )\n        def is_reserved(self) -> bool: ...\n    else:\n        def is_reserved(self) -> bool: ...\n    if sys.version_info >= (3, 14):\n        def is_relative_to(self, other: StrPath) -> bool: ...\n    elif sys.version_info >= (3, 12):\n        def is_relative_to(self, other: StrPath, /, *_deprecated: StrPath) -> bool: ...\n    else:\n        def is_relative_to(self, *other: StrPath) -> bool: ...\n\n    if sys.version_info >= (3, 12):\n        def match(self, path_pattern: str, *, case_sensitive: bool | None = None) -> bool: ...\n    else:\n        def match(self, path_pattern: str) -> bool: ...\n\n    if sys.version_info >= (3, 14):\n        def relative_to(self, other: StrPath, *, walk_up: bool = False) -> Self: ...\n    elif sys.version_info >= (3, 12):\n        def relative_to(self, other: StrPath, /, *_deprecated: StrPath, walk_up: bool = False) -> Self: ...\n    else:\n        def relative_to(self, *other: StrPath) -> Self: ...\n\n    def with_name(self, name: str) -> Self: ...\n    def with_stem(self, stem: str) -> Self: ...\n    def with_suffix(self, suffix: str) -> Self: ...\n    def joinpath(self, *other: StrPath) -> Self: ...\n    @property\n    def parents(self) -> Sequence[Self]: ...\n    @property\n    def parent(self) -> Self: ...\n    if sys.version_info < (3, 11):\n        def __class_getitem__(cls, type: Any) -> GenericAlias: ...\n\n    if sys.version_info >= (3, 12):\n        def with_segments(self, *args: StrPath) -> Self: ...\n\nclass PurePosixPath(PurePath):\n    __slots__ = ()\n\nclass PureWindowsPath(PurePath):\n    __slots__ = ()\n\nclass Path(PurePath):\n    if sys.version_info >= (3, 14):\n        __slots__ = (\"_info\",)\n    elif sys.version_info >= (3, 10):\n        __slots__ = ()\n    else:\n        __slots__ = (\"_accessor\",)\n\n    if sys.version_info >= (3, 12):\n        def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...  # pyright: ignore[reportInconsistentConstructor]\n    else:\n        def __new__(cls, *args: StrPath, **kwargs: Unused) -> Self: ...\n\n    @classmethod\n    def cwd(cls) -> Self: ...\n    if sys.version_info >= (3, 10):\n        def stat(self, *, follow_symlinks: bool = True) -> stat_result: ...\n        def chmod(self, mode: int, *, follow_symlinks: bool = True) -> None: ...\n    else:\n        def stat(self) -> stat_result: ...\n        def chmod(self, mode: int) -> None: ...\n\n    if sys.version_info >= (3, 13):\n        @classmethod\n        def from_uri(cls, uri: str) -> Self: ...\n        def is_dir(self, *, follow_symlinks: bool = True) -> bool: ...\n        def is_file(self, *, follow_symlinks: bool = True) -> bool: ...\n        def read_text(self, encoding: str | None = None, errors: str | None = None, newline: str | None = None) -> str: ...\n    else:\n        def __enter__(self) -> Self: ...\n        def __exit__(self, t: type[BaseException] | None, v: BaseException | None, tb: TracebackType | None) -> None: ...\n        def is_dir(self) -> bool: ...\n        def is_file(self) -> bool: ...\n        def read_text(self, encoding: str | None = None, errors: str | None = None) -> str: ...\n\n    if sys.version_info >= (3, 13):\n        def glob(self, pattern: str, *, case_sensitive: bool | None = None, recurse_symlinks: bool = False) -> Iterator[Self]: ...\n        def rglob(\n            self, pattern: str, *, case_sensitive: bool | None = None, recurse_symlinks: bool = False\n        ) -> Iterator[Self]: ...\n    elif sys.version_info >= (3, 12):\n        def glob(self, pattern: str, *, case_sensitive: bool | None = None) -> Generator[Self, None, None]: ...\n        def rglob(self, pattern: str, *, case_sensitive: bool | None = None) -> Generator[Self, None, None]: ...\n    else:\n        def glob(self, pattern: str) -> Generator[Self, None, None]: ...\n        def rglob(self, pattern: str) -> Generator[Self, None, None]: ...\n\n    if sys.version_info >= (3, 12):\n        def exists(self, *, follow_symlinks: bool = True) -> bool: ...\n    else:\n        def exists(self) -> bool: ...\n\n    def is_symlink(self) -> bool: ...\n    def is_socket(self) -> bool: ...\n    def is_fifo(self) -> bool: ...\n    def is_block_device(self) -> bool: ...\n    def is_char_device(self) -> bool: ...\n    if sys.version_info >= (3, 12):\n        def is_junction(self) -> bool: ...\n\n    def iterdir(self) -> Generator[Self, None, None]: ...\n    def lchmod(self, mode: int) -> None: ...\n    def lstat(self) -> stat_result: ...\n    def mkdir(self, mode: int = 0o777, parents: bool = False, exist_ok: bool = False) -> None: ...\n\n    if sys.version_info >= (3, 14):\n        @property\n        def info(self) -> PathInfo: ...\n        @overload\n        def move_into(self, target_dir: _PathT) -> _PathT: ...  # type: ignore[overload-overlap]\n        @overload\n        def move_into(self, target_dir: StrPath) -> Self: ...  # type: ignore[overload-overlap]\n        @overload\n        def move(self, target: _PathT) -> _PathT: ...  # type: ignore[overload-overlap]\n        @overload\n        def move(self, target: StrPath) -> Self: ...  # type: ignore[overload-overlap]\n        @overload\n        def copy_into(self, target_dir: _PathT, *, follow_symlinks: bool = True, preserve_metadata: bool = False) -> _PathT: ...  # type: ignore[overload-overlap]\n        @overload\n        def copy_into(self, target_dir: StrPath, *, follow_symlinks: bool = True, preserve_metadata: bool = False) -> Self: ...  # type: ignore[overload-overlap]\n        @overload\n        def copy(self, target: _PathT, *, follow_symlinks: bool = True, preserve_metadata: bool = False) -> _PathT: ...  # type: ignore[overload-overlap]\n        @overload\n        def copy(self, target: StrPath, *, follow_symlinks: bool = True, preserve_metadata: bool = False) -> Self: ...  # type: ignore[overload-overlap]\n\n    # Adapted from builtins.open\n    # Text mode: always returns a TextIOWrapper\n    # The Traversable .open in stdlib/importlib/abc.pyi should be kept in sync with this.\n    @overload\n    def open(\n        self,\n        mode: OpenTextMode = \"r\",\n        buffering: int = -1,\n        encoding: str | None = None,\n        errors: str | None = None,\n        newline: str | None = None,\n    ) -> TextIOWrapper: ...\n    # Unbuffered binary mode: returns a FileIO\n    @overload\n    def open(\n        self, mode: OpenBinaryMode, buffering: Literal[0], encoding: None = None, errors: None = None, newline: None = None\n    ) -> FileIO: ...\n    # Buffering is on: return BufferedRandom, BufferedReader, or BufferedWriter\n    @overload\n    def open(\n        self,\n        mode: OpenBinaryModeUpdating,\n        buffering: Literal[-1, 1] = -1,\n        encoding: None = None,\n        errors: None = None,\n        newline: None = None,\n    ) -> BufferedRandom: ...\n    @overload\n    def open(\n        self,\n        mode: OpenBinaryModeWriting,\n        buffering: Literal[-1, 1] = -1,\n        encoding: None = None,\n        errors: None = None,\n        newline: None = None,\n    ) -> BufferedWriter: ...\n    @overload\n    def open(\n        self,\n        mode: OpenBinaryModeReading,\n        buffering: Literal[-1, 1] = -1,\n        encoding: None = None,\n        errors: None = None,\n        newline: None = None,\n    ) -> BufferedReader: ...\n    # Buffering cannot be determined: fall back to BinaryIO\n    @overload\n    def open(\n        self, mode: OpenBinaryMode, buffering: int = -1, encoding: None = None, errors: None = None, newline: None = None\n    ) -> BinaryIO: ...\n    # Fallback if mode is not specified\n    @overload\n    def open(\n        self, mode: str, buffering: int = -1, encoding: str | None = None, errors: str | None = None, newline: str | None = None\n    ) -> IO[Any]: ...\n\n    # These methods do \"exist\" on Windows, but they always raise NotImplementedError.\n    if sys.platform == \"win32\":\n        if sys.version_info >= (3, 13):\n            # raises UnsupportedOperation:\n            def owner(self: Never, *, follow_symlinks: bool = True) -> str: ...  # type: ignore[misc]\n            def group(self: Never, *, follow_symlinks: bool = True) -> str: ...  # type: ignore[misc]\n        else:\n            def owner(self: Never) -> str: ...  # type: ignore[misc]\n            def group(self: Never) -> str: ...  # type: ignore[misc]\n    else:\n        if sys.version_info >= (3, 13):\n            def owner(self, *, follow_symlinks: bool = True) -> str: ...\n            def group(self, *, follow_symlinks: bool = True) -> str: ...\n        else:\n            def owner(self) -> str: ...\n            def group(self) -> str: ...\n\n    # This method does \"exist\" on Windows on <3.12, but always raises NotImplementedError\n    # On py312+, it works properly on Windows, as with all other platforms\n    if sys.platform == \"win32\" and sys.version_info < (3, 12):\n        def is_mount(self: Never) -> bool: ...  # type: ignore[misc]\n    else:\n        def is_mount(self) -> bool: ...\n\n    def readlink(self) -> Self: ...\n\n    if sys.version_info >= (3, 10):\n        def rename(self, target: StrPath) -> Self: ...\n        def replace(self, target: StrPath) -> Self: ...\n    else:\n        def rename(self, target: str | PurePath) -> Self: ...\n        def replace(self, target: str | PurePath) -> Self: ...\n\n    def resolve(self, strict: bool = False) -> Self: ...\n    def rmdir(self) -> None: ...\n    def symlink_to(self, target: StrOrBytesPath, target_is_directory: bool = False) -> None: ...\n    if sys.version_info >= (3, 10):\n        def hardlink_to(self, target: StrOrBytesPath) -> None: ...\n\n    def touch(self, mode: int = 0o666, exist_ok: bool = True) -> None: ...\n    def unlink(self, missing_ok: bool = False) -> None: ...\n    @classmethod\n    def home(cls) -> Self: ...\n    def absolute(self) -> Self: ...\n    def expanduser(self) -> Self: ...\n    def read_bytes(self) -> bytes: ...\n    def samefile(self, other_path: StrPath) -> bool: ...\n    def write_bytes(self, data: ReadableBuffer) -> int: ...\n    if sys.version_info >= (3, 10):\n        def write_text(\n            self, data: str, encoding: str | None = None, errors: str | None = None, newline: str | None = None\n        ) -> int: ...\n    else:\n        def write_text(self, data: str, encoding: str | None = None, errors: str | None = None) -> int: ...\n    if sys.version_info < (3, 12):\n        if sys.version_info >= (3, 10):\n            @deprecated(\"Deprecated since Python 3.10; removed in Python 3.12. Use `hardlink_to()` instead.\")\n            def link_to(self, target: StrOrBytesPath) -> None: ...\n        else:\n            def link_to(self, target: StrOrBytesPath) -> None: ...\n    if sys.version_info >= (3, 12):\n        def walk(\n            self, top_down: bool = True, on_error: Callable[[OSError], object] | None = None, follow_symlinks: bool = False\n        ) -> Iterator[tuple[Self, list[str], list[str]]]: ...\n\n    def as_uri(self) -> str: ...\n\nclass PosixPath(Path, PurePosixPath):\n    __slots__ = ()\n\nclass WindowsPath(Path, PureWindowsPath):\n    __slots__ = ()\n\nif sys.version_info >= (3, 13):\n    class UnsupportedOperation(NotImplementedError): ...\n",
  "/typeshed/stdlib/pathlib/types.pyi": "from typing import Protocol, runtime_checkable\n\n@runtime_checkable\nclass PathInfo(Protocol):\n    def exists(self, *, follow_symlinks: bool = True) -> bool: ...\n    def is_dir(self, *, follow_symlinks: bool = True) -> bool: ...\n    def is_file(self, *, follow_symlinks: bool = True) -> bool: ...\n    def is_symlink(self) -> bool: ...\n",
  "/typeshed/stdlib/re.pyi": "import enum\nimport sre_compile\nimport sre_constants\nimport sys\nfrom _typeshed import MaybeNone, ReadableBuffer\nfrom collections.abc import Callable, Iterator, Mapping\nfrom types import GenericAlias\nfrom typing import Any, AnyStr, Final, Generic, Literal, TypeVar, final, overload\nfrom typing_extensions import TypeAlias, deprecated\n\n__all__ = [\n    \"match\",\n    \"fullmatch\",\n    \"search\",\n    \"sub\",\n    \"subn\",\n    \"split\",\n    \"findall\",\n    \"finditer\",\n    \"compile\",\n    \"purge\",\n    \"escape\",\n    \"error\",\n    \"A\",\n    \"I\",\n    \"L\",\n    \"M\",\n    \"S\",\n    \"X\",\n    \"U\",\n    \"ASCII\",\n    \"IGNORECASE\",\n    \"LOCALE\",\n    \"MULTILINE\",\n    \"DOTALL\",\n    \"VERBOSE\",\n    \"UNICODE\",\n    \"Match\",\n    \"Pattern\",\n]\nif sys.version_info < (3, 13):\n    __all__ += [\"template\"]\n\nif sys.version_info >= (3, 11):\n    __all__ += [\"NOFLAG\", \"RegexFlag\"]\n\nif sys.version_info >= (3, 13):\n    __all__ += [\"PatternError\"]\n\n    PatternError = sre_constants.error\n\n_T = TypeVar(\"_T\")\n\n# The implementation defines this in re._constants (version_info >= 3, 11) or\n# sre_constants. Typeshed has it here because its __module__ attribute is set to \"re\".\nclass error(Exception):\n    msg: str\n    pattern: str | bytes | None\n    pos: int | None\n    lineno: int\n    colno: int\n    def __init__(self, msg: str, pattern: str | bytes | None = None, pos: int | None = None) -> None: ...\n\n@final\nclass Match(Generic[AnyStr]):\n    @property\n    def pos(self) -> int: ...\n    @property\n    def endpos(self) -> int: ...\n    @property\n    def lastindex(self) -> int | None: ...\n    @property\n    def lastgroup(self) -> str | None: ...\n    @property\n    def string(self) -> AnyStr: ...\n\n    # The regular expression object whose match() or search() method produced\n    # this match instance.\n    @property\n    def re(self) -> Pattern[AnyStr]: ...\n    @overload\n    def expand(self: Match[str], template: str) -> str: ...\n    @overload\n    def expand(self: Match[bytes], template: ReadableBuffer) -> bytes: ...\n    @overload\n    def expand(self, template: AnyStr) -> AnyStr: ...\n    # group() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def group(self, group: Literal[0] = 0, /) -> AnyStr: ...\n    @overload\n    def group(self, group: str | int, /) -> AnyStr | MaybeNone: ...\n    @overload\n    def group(self, group1: str | int, group2: str | int, /, *groups: str | int) -> tuple[AnyStr | MaybeNone, ...]: ...\n    # Each item of groups()'s return tuple is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groups(self) -> tuple[AnyStr | MaybeNone, ...]: ...\n    @overload\n    def groups(self, default: _T) -> tuple[AnyStr | _T, ...]: ...\n    # Each value in groupdict()'s return dict is either \"AnyStr\" or\n    # \"AnyStr | None\", depending on the pattern.\n    @overload\n    def groupdict(self) -> dict[str, AnyStr | MaybeNone]: ...\n    @overload\n    def groupdict(self, default: _T) -> dict[str, AnyStr | _T]: ...\n    def start(self, group: int | str = 0, /) -> int: ...\n    def end(self, group: int | str = 0, /) -> int: ...\n    def span(self, group: int | str = 0, /) -> tuple[int, int]: ...\n    @property\n    def regs(self) -> tuple[tuple[int, int], ...]: ...  # undocumented\n    # __getitem__() returns \"AnyStr\" or \"AnyStr | None\", depending on the pattern.\n    @overload\n    def __getitem__(self, key: Literal[0], /) -> AnyStr: ...\n    @overload\n    def __getitem__(self, key: int | str, /) -> AnyStr | MaybeNone: ...\n    def __copy__(self) -> Match[AnyStr]: ...\n    def __deepcopy__(self, memo: Any, /) -> Match[AnyStr]: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n@final\nclass Pattern(Generic[AnyStr]):\n    @property\n    def flags(self) -> int: ...\n    @property\n    def groupindex(self) -> Mapping[str, int]: ...\n    @property\n    def groups(self) -> int: ...\n    @property\n    def pattern(self) -> AnyStr: ...\n    @overload\n    def search(self: Pattern[str], string: str, pos: int = 0, endpos: int = sys.maxsize) -> Match[str] | None: ...\n    @overload\n    def search(self: Pattern[bytes], string: ReadableBuffer, pos: int = 0, endpos: int = sys.maxsize) -> Match[bytes] | None: ...\n    @overload\n    def search(self, string: AnyStr, pos: int = 0, endpos: int = sys.maxsize) -> Match[AnyStr] | None: ...\n    @overload\n    def match(self: Pattern[str], string: str, pos: int = 0, endpos: int = sys.maxsize) -> Match[str] | None: ...\n    @overload\n    def match(self: Pattern[bytes], string: ReadableBuffer, pos: int = 0, endpos: int = sys.maxsize) -> Match[bytes] | None: ...\n    @overload\n    def match(self, string: AnyStr, pos: int = 0, endpos: int = sys.maxsize) -> Match[AnyStr] | None: ...\n    @overload\n    def fullmatch(self: Pattern[str], string: str, pos: int = 0, endpos: int = sys.maxsize) -> Match[str] | None: ...\n    @overload\n    def fullmatch(\n        self: Pattern[bytes], string: ReadableBuffer, pos: int = 0, endpos: int = sys.maxsize\n    ) -> Match[bytes] | None: ...\n    @overload\n    def fullmatch(self, string: AnyStr, pos: int = 0, endpos: int = sys.maxsize) -> Match[AnyStr] | None: ...\n    @overload\n    def split(self: Pattern[str], string: str, maxsplit: int = 0) -> list[str | MaybeNone]: ...\n    @overload\n    def split(self: Pattern[bytes], string: ReadableBuffer, maxsplit: int = 0) -> list[bytes | MaybeNone]: ...\n    @overload\n    def split(self, string: AnyStr, maxsplit: int = 0) -> list[AnyStr | MaybeNone]: ...\n    # return type depends on the number of groups in the pattern\n    @overload\n    def findall(self: Pattern[str], string: str, pos: int = 0, endpos: int = sys.maxsize) -> list[Any]: ...\n    @overload\n    def findall(self: Pattern[bytes], string: ReadableBuffer, pos: int = 0, endpos: int = sys.maxsize) -> list[Any]: ...\n    @overload\n    def findall(self, string: AnyStr, pos: int = 0, endpos: int = sys.maxsize) -> list[AnyStr]: ...\n    @overload\n    def finditer(self: Pattern[str], string: str, pos: int = 0, endpos: int = sys.maxsize) -> Iterator[Match[str]]: ...\n    @overload\n    def finditer(\n        self: Pattern[bytes], string: ReadableBuffer, pos: int = 0, endpos: int = sys.maxsize\n    ) -> Iterator[Match[bytes]]: ...\n    @overload\n    def finditer(self, string: AnyStr, pos: int = 0, endpos: int = sys.maxsize) -> Iterator[Match[AnyStr]]: ...\n    @overload\n    def sub(self: Pattern[str], repl: str | Callable[[Match[str]], str], string: str, count: int = 0) -> str: ...\n    @overload\n    def sub(\n        self: Pattern[bytes],\n        repl: ReadableBuffer | Callable[[Match[bytes]], ReadableBuffer],\n        string: ReadableBuffer,\n        count: int = 0,\n    ) -> bytes: ...\n    @overload\n    def sub(self, repl: AnyStr | Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = 0) -> AnyStr: ...\n    @overload\n    def subn(self: Pattern[str], repl: str | Callable[[Match[str]], str], string: str, count: int = 0) -> tuple[str, int]: ...\n    @overload\n    def subn(\n        self: Pattern[bytes],\n        repl: ReadableBuffer | Callable[[Match[bytes]], ReadableBuffer],\n        string: ReadableBuffer,\n        count: int = 0,\n    ) -> tuple[bytes, int]: ...\n    @overload\n    def subn(self, repl: AnyStr | Callable[[Match[AnyStr]], AnyStr], string: AnyStr, count: int = 0) -> tuple[AnyStr, int]: ...\n    def __copy__(self) -> Pattern[AnyStr]: ...\n    def __deepcopy__(self, memo: Any, /) -> Pattern[AnyStr]: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n# ----- re variables and constants -----\n\nclass RegexFlag(enum.IntFlag):\n    A = sre_compile.SRE_FLAG_ASCII\n    ASCII = A\n    DEBUG = sre_compile.SRE_FLAG_DEBUG\n    I = sre_compile.SRE_FLAG_IGNORECASE\n    IGNORECASE = I\n    L = sre_compile.SRE_FLAG_LOCALE\n    LOCALE = L\n    M = sre_compile.SRE_FLAG_MULTILINE\n    MULTILINE = M\n    S = sre_compile.SRE_FLAG_DOTALL\n    DOTALL = S\n    X = sre_compile.SRE_FLAG_VERBOSE\n    VERBOSE = X\n    U = sre_compile.SRE_FLAG_UNICODE\n    UNICODE = U\n    if sys.version_info < (3, 13):\n        T = sre_compile.SRE_FLAG_TEMPLATE\n        TEMPLATE = T\n    if sys.version_info >= (3, 11):\n        NOFLAG = 0\n\nA: Final = RegexFlag.A\nASCII: Final = RegexFlag.ASCII\nDEBUG: Final = RegexFlag.DEBUG\nI: Final = RegexFlag.I\nIGNORECASE: Final = RegexFlag.IGNORECASE\nL: Final = RegexFlag.L\nLOCALE: Final = RegexFlag.LOCALE\nM: Final = RegexFlag.M\nMULTILINE: Final = RegexFlag.MULTILINE\nS: Final = RegexFlag.S\nDOTALL: Final = RegexFlag.DOTALL\nX: Final = RegexFlag.X\nVERBOSE: Final = RegexFlag.VERBOSE\nU: Final = RegexFlag.U\nUNICODE: Final = RegexFlag.UNICODE\nif sys.version_info < (3, 13):\n    T: Final = RegexFlag.T\n    TEMPLATE: Final = RegexFlag.TEMPLATE\nif sys.version_info >= (3, 11):\n    NOFLAG: Final = RegexFlag.NOFLAG\n_FlagsType: TypeAlias = int | RegexFlag\n\n# Type-wise the compile() overloads are unnecessary, they could also be modeled using\n# unions in the parameter types. However mypy has a bug regarding TypeVar\n# constraints (https://github.com/python/mypy/issues/11880),\n# which limits us here because AnyStr is a constrained TypeVar.\n\n# pattern arguments do *not* accept arbitrary buffers such as bytearray,\n# because the pattern must be hashable.\n@overload\ndef compile(pattern: AnyStr, flags: _FlagsType = 0) -> Pattern[AnyStr]: ...\n@overload\ndef compile(pattern: Pattern[AnyStr], flags: _FlagsType = 0) -> Pattern[AnyStr]: ...\n@overload\ndef search(pattern: str | Pattern[str], string: str, flags: _FlagsType = 0) -> Match[str] | None: ...\n@overload\ndef search(pattern: bytes | Pattern[bytes], string: ReadableBuffer, flags: _FlagsType = 0) -> Match[bytes] | None: ...\n@overload\ndef match(pattern: str | Pattern[str], string: str, flags: _FlagsType = 0) -> Match[str] | None: ...\n@overload\ndef match(pattern: bytes | Pattern[bytes], string: ReadableBuffer, flags: _FlagsType = 0) -> Match[bytes] | None: ...\n@overload\ndef fullmatch(pattern: str | Pattern[str], string: str, flags: _FlagsType = 0) -> Match[str] | None: ...\n@overload\ndef fullmatch(pattern: bytes | Pattern[bytes], string: ReadableBuffer, flags: _FlagsType = 0) -> Match[bytes] | None: ...\n@overload\ndef split(pattern: str | Pattern[str], string: str, maxsplit: int = 0, flags: _FlagsType = 0) -> list[str | MaybeNone]: ...\n@overload\ndef split(\n    pattern: bytes | Pattern[bytes], string: ReadableBuffer, maxsplit: int = 0, flags: _FlagsType = 0\n) -> list[bytes | MaybeNone]: ...\n@overload\ndef findall(pattern: str | Pattern[str], string: str, flags: _FlagsType = 0) -> list[Any]: ...\n@overload\ndef findall(pattern: bytes | Pattern[bytes], string: ReadableBuffer, flags: _FlagsType = 0) -> list[Any]: ...\n@overload\ndef finditer(pattern: str | Pattern[str], string: str, flags: _FlagsType = 0) -> Iterator[Match[str]]: ...\n@overload\ndef finditer(pattern: bytes | Pattern[bytes], string: ReadableBuffer, flags: _FlagsType = 0) -> Iterator[Match[bytes]]: ...\n@overload\ndef sub(\n    pattern: str | Pattern[str], repl: str | Callable[[Match[str]], str], string: str, count: int = 0, flags: _FlagsType = 0\n) -> str: ...\n@overload\ndef sub(\n    pattern: bytes | Pattern[bytes],\n    repl: ReadableBuffer | Callable[[Match[bytes]], ReadableBuffer],\n    string: ReadableBuffer,\n    count: int = 0,\n    flags: _FlagsType = 0,\n) -> bytes: ...\n@overload\ndef subn(\n    pattern: str | Pattern[str], repl: str | Callable[[Match[str]], str], string: str, count: int = 0, flags: _FlagsType = 0\n) -> tuple[str, int]: ...\n@overload\ndef subn(\n    pattern: bytes | Pattern[bytes],\n    repl: ReadableBuffer | Callable[[Match[bytes]], ReadableBuffer],\n    string: ReadableBuffer,\n    count: int = 0,\n    flags: _FlagsType = 0,\n) -> tuple[bytes, int]: ...\ndef escape(pattern: AnyStr) -> AnyStr: ...\ndef purge() -> None: ...\n\nif sys.version_info < (3, 13):\n    if sys.version_info >= (3, 11):\n        @deprecated(\"Deprecated since Python 3.11; removed in Python 3.13. Use `re.compile()` instead.\")\n        def template(pattern: AnyStr | Pattern[AnyStr], flags: _FlagsType = 0) -> Pattern[AnyStr]: ...  # undocumented\n    else:\n        def template(pattern: AnyStr | Pattern[AnyStr], flags: _FlagsType = 0) -> Pattern[AnyStr]: ...  # undocumented\n",
  "/typeshed/stdlib/readline.pyi": "import sys\nfrom _typeshed import StrOrBytesPath\nfrom collections.abc import Callable, Sequence\nfrom typing import Literal\nfrom typing_extensions import TypeAlias\n\nif sys.platform != \"win32\":\n    _Completer: TypeAlias = Callable[[str, int], str | None]\n    _CompDisp: TypeAlias = Callable[[str, Sequence[str], int], None]\n\n    def parse_and_bind(string: str, /) -> None: ...\n    def read_init_file(filename: StrOrBytesPath | None = None, /) -> None: ...\n    def get_line_buffer() -> str: ...\n    def insert_text(string: str, /) -> None: ...\n    def redisplay() -> None: ...\n    def read_history_file(filename: StrOrBytesPath | None = None, /) -> None: ...\n    def write_history_file(filename: StrOrBytesPath | None = None, /) -> None: ...\n    def append_history_file(nelements: int, filename: StrOrBytesPath | None = None, /) -> None: ...\n    def get_history_length() -> int: ...\n    def set_history_length(length: int, /) -> None: ...\n    def clear_history() -> None: ...\n    def get_current_history_length() -> int: ...\n    def get_history_item(index: int, /) -> str: ...\n    def remove_history_item(pos: int, /) -> None: ...\n    def replace_history_item(pos: int, line: str, /) -> None: ...\n    def add_history(string: str, /) -> None: ...\n    def set_auto_history(enabled: bool, /) -> None: ...\n    def set_startup_hook(function: Callable[[], object] | None = None, /) -> None: ...\n    def set_pre_input_hook(function: Callable[[], object] | None = None, /) -> None: ...\n    def set_completer(function: _Completer | None = None, /) -> None: ...\n    def get_completer() -> _Completer | None: ...\n    def get_completion_type() -> int: ...\n    def get_begidx() -> int: ...\n    def get_endidx() -> int: ...\n    def set_completer_delims(string: str, /) -> None: ...\n    def get_completer_delims() -> str: ...\n    def set_completion_display_matches_hook(function: _CompDisp | None = None, /) -> None: ...\n\n    if sys.version_info >= (3, 13):\n        backend: Literal[\"readline\", \"editline\"]\n",
  "/typeshed/stdlib/reprlib.pyi": "import sys\nfrom array import array\nfrom collections import deque\nfrom collections.abc import Callable\nfrom typing import Any\nfrom typing_extensions import TypeAlias\n\n__all__ = [\"Repr\", \"repr\", \"recursive_repr\"]\n\n_ReprFunc: TypeAlias = Callable[[Any], str]\n\ndef recursive_repr(fillvalue: str = \"...\") -> Callable[[_ReprFunc], _ReprFunc]: ...\n\nclass Repr:\n    maxlevel: int\n    maxdict: int\n    maxlist: int\n    maxtuple: int\n    maxset: int\n    maxfrozenset: int\n    maxdeque: int\n    maxarray: int\n    maxlong: int\n    maxstring: int\n    maxother: int\n    if sys.version_info >= (3, 11):\n        fillvalue: str\n    if sys.version_info >= (3, 12):\n        indent: str | int | None\n\n    if sys.version_info >= (3, 12):\n        def __init__(\n            self,\n            *,\n            maxlevel: int = 6,\n            maxtuple: int = 6,\n            maxlist: int = 6,\n            maxarray: int = 5,\n            maxdict: int = 4,\n            maxset: int = 6,\n            maxfrozenset: int = 6,\n            maxdeque: int = 6,\n            maxstring: int = 30,\n            maxlong: int = 40,\n            maxother: int = 30,\n            fillvalue: str = \"...\",\n            indent: str | int | None = None,\n        ) -> None: ...\n\n    def repr(self, x: Any) -> str: ...\n    def repr1(self, x: Any, level: int) -> str: ...\n    def repr_tuple(self, x: tuple[Any, ...], level: int) -> str: ...\n    def repr_list(self, x: list[Any], level: int) -> str: ...\n    def repr_array(self, x: array[Any], level: int) -> str: ...\n    def repr_set(self, x: set[Any], level: int) -> str: ...\n    def repr_frozenset(self, x: frozenset[Any], level: int) -> str: ...\n    def repr_deque(self, x: deque[Any], level: int) -> str: ...\n    def repr_dict(self, x: dict[Any, Any], level: int) -> str: ...\n    def repr_str(self, x: str, level: int) -> str: ...\n    def repr_int(self, x: int, level: int) -> str: ...\n    def repr_instance(self, x: Any, level: int) -> str: ...\n\naRepr: Repr\n\ndef repr(x: object) -> str: ...\n",
  "/typeshed/stdlib/resource.pyi": "import sys\nfrom _typeshed import structseq\nfrom typing import Final, final\n\nif sys.platform != \"win32\":\n    # Depends on resource.h\n    RLIMIT_AS: Final[int]\n    RLIMIT_CORE: Final[int]\n    RLIMIT_CPU: Final[int]\n    RLIMIT_DATA: Final[int]\n    RLIMIT_FSIZE: Final[int]\n    RLIMIT_MEMLOCK: Final[int]\n    RLIMIT_NOFILE: Final[int]\n    RLIMIT_NPROC: Final[int]\n    RLIMIT_RSS: Final[int]\n    RLIMIT_STACK: Final[int]\n    RLIM_INFINITY: Final[int]\n    RUSAGE_CHILDREN: Final[int]\n    RUSAGE_SELF: Final[int]\n    if sys.platform == \"linux\":\n        RLIMIT_MSGQUEUE: Final[int]\n        RLIMIT_NICE: Final[int]\n        RLIMIT_OFILE: Final[int]\n        RLIMIT_RTPRIO: Final[int]\n        RLIMIT_RTTIME: Final[int]\n        RLIMIT_SIGPENDING: Final[int]\n        RUSAGE_THREAD: Final[int]\n\n    @final\n    class struct_rusage(\n        structseq[float], tuple[float, float, int, int, int, int, int, int, int, int, int, int, int, int, int, int]\n    ):\n        if sys.version_info >= (3, 10):\n            __match_args__: Final = (\n                \"ru_utime\",\n                \"ru_stime\",\n                \"ru_maxrss\",\n                \"ru_ixrss\",\n                \"ru_idrss\",\n                \"ru_isrss\",\n                \"ru_minflt\",\n                \"ru_majflt\",\n                \"ru_nswap\",\n                \"ru_inblock\",\n                \"ru_oublock\",\n                \"ru_msgsnd\",\n                \"ru_msgrcv\",\n                \"ru_nsignals\",\n                \"ru_nvcsw\",\n                \"ru_nivcsw\",\n            )\n\n        @property\n        def ru_utime(self) -> float: ...\n        @property\n        def ru_stime(self) -> float: ...\n        @property\n        def ru_maxrss(self) -> int: ...\n        @property\n        def ru_ixrss(self) -> int: ...\n        @property\n        def ru_idrss(self) -> int: ...\n        @property\n        def ru_isrss(self) -> int: ...\n        @property\n        def ru_minflt(self) -> int: ...\n        @property\n        def ru_majflt(self) -> int: ...\n        @property\n        def ru_nswap(self) -> int: ...\n        @property\n        def ru_inblock(self) -> int: ...\n        @property\n        def ru_oublock(self) -> int: ...\n        @property\n        def ru_msgsnd(self) -> int: ...\n        @property\n        def ru_msgrcv(self) -> int: ...\n        @property\n        def ru_nsignals(self) -> int: ...\n        @property\n        def ru_nvcsw(self) -> int: ...\n        @property\n        def ru_nivcsw(self) -> int: ...\n\n    def getpagesize() -> int: ...\n    def getrlimit(resource: int, /) -> tuple[int, int]: ...\n    def getrusage(who: int, /) -> struct_rusage: ...\n    def setrlimit(resource: int, limits: tuple[int, int], /) -> None: ...\n    if sys.platform == \"linux\":\n        if sys.version_info >= (3, 12):\n            def prlimit(pid: int, resource: int, limits: tuple[int, int] | None = None, /) -> tuple[int, int]: ...\n        else:\n            def prlimit(pid: int, resource: int, limits: tuple[int, int] = ..., /) -> tuple[int, int]: ...\n    error = OSError\n",
  "/typeshed/stdlib/sys/__init__.pyi": "import sys\nfrom _typeshed import MaybeNone, OptExcInfo, ProfileFunction, StrOrBytesPath, TraceFunction, structseq\nfrom _typeshed.importlib import MetaPathFinderProtocol, PathEntryFinderProtocol\nfrom builtins import object as _object\nfrom collections.abc import AsyncGenerator, Callable, Sequence\nfrom io import TextIOWrapper\nfrom types import FrameType, ModuleType, TracebackType\nfrom typing import Any, Final, Literal, NoReturn, Protocol, TextIO, TypeVar, final, overload, type_check_only\nfrom typing_extensions import LiteralString, TypeAlias, deprecated\n\n_T = TypeVar(\"_T\")\n\n# see https://github.com/python/typeshed/issues/8513#issue-1333671093 for the rationale behind this alias\n_ExitCode: TypeAlias = str | int | None\n\n# ----- sys variables -----\nif sys.platform != \"win32\":\n    abiflags: str\nargv: list[str]\nbase_exec_prefix: str\nbase_prefix: str\nbyteorder: Literal[\"little\", \"big\"]\nbuiltin_module_names: Sequence[str]  # actually a tuple of strings\ncopyright: str\nif sys.platform == \"win32\":\n    dllhandle: int\ndont_write_bytecode: bool\ndisplayhook: Callable[[object], Any]\nexcepthook: Callable[[type[BaseException], BaseException, TracebackType | None], Any]\nexec_prefix: str\nexecutable: str\nfloat_repr_style: Literal[\"short\", \"legacy\"]\nhexversion: int\nlast_type: type[BaseException] | None\nlast_value: BaseException | None\nlast_traceback: TracebackType | None\nif sys.version_info >= (3, 12):\n    last_exc: BaseException  # or undefined.\nmaxsize: int\nmaxunicode: int\nmeta_path: list[MetaPathFinderProtocol]\nmodules: dict[str, ModuleType]\nif sys.version_info >= (3, 10):\n    orig_argv: list[str]\npath: list[str]\npath_hooks: list[Callable[[str], PathEntryFinderProtocol]]\npath_importer_cache: dict[str, PathEntryFinderProtocol | None]\nplatform: LiteralString\nplatlibdir: str\nprefix: str\npycache_prefix: str | None\nps1: object\nps2: object\n\n# TextIO is used instead of more specific types for the standard streams,\n# since they are often monkeypatched at runtime. At startup, the objects\n# are initialized to instances of TextIOWrapper, but can also be None under\n# some circumstances.\n#\n# To use methods from TextIOWrapper, use an isinstance check to ensure that\n# the streams have not been overridden:\n#\n# if isinstance(sys.stdout, io.TextIOWrapper):\n#    sys.stdout.reconfigure(...)\nstdin: TextIO | MaybeNone\nstdout: TextIO | MaybeNone\nstderr: TextIO | MaybeNone\n\nif sys.version_info >= (3, 10):\n    stdlib_module_names: frozenset[str]\n\n__stdin__: Final[TextIOWrapper | None]  # Contains the original value of stdin\n__stdout__: Final[TextIOWrapper | None]  # Contains the original value of stdout\n__stderr__: Final[TextIOWrapper | None]  # Contains the original value of stderr\ntracebacklimit: int | None\nversion: str\napi_version: int\nwarnoptions: Any\n#  Each entry is a tuple of the form (action, message, category, module,\n#    lineno)\nif sys.platform == \"win32\":\n    winver: str\n_xoptions: dict[Any, Any]\n\n# Type alias used as a mixin for structseq classes that cannot be instantiated at runtime\n# This can't be represented in the type system, so we just use `structseq[Any]`\n_UninstantiableStructseq: TypeAlias = structseq[Any]\n\nflags: _flags\n\n# This class is not exposed at runtime. It calls itself sys.flags.\n# As a tuple, it can have a length between 15 and 18. We don't model\n# the exact length here because that varies by patch version due to\n# the backported security fix int_max_str_digits. The exact length shouldn't\n# be relied upon. See #13031\n# This can be re-visited when typeshed drops support for 3.10,\n# at which point all supported versions will include int_max_str_digits\n# in all patch versions.\n# 3.9 is 15 or 16-tuple\n# 3.10 is 16 or 17-tuple\n# 3.11+ is an 18-tuple.\n@final\n@type_check_only\nclass _flags(_UninstantiableStructseq, tuple[int, ...]):\n    # `safe_path` was added in py311\n    if sys.version_info >= (3, 11):\n        __match_args__: Final = (\n            \"debug\",\n            \"inspect\",\n            \"interactive\",\n            \"optimize\",\n            \"dont_write_bytecode\",\n            \"no_user_site\",\n            \"no_site\",\n            \"ignore_environment\",\n            \"verbose\",\n            \"bytes_warning\",\n            \"quiet\",\n            \"hash_randomization\",\n            \"isolated\",\n            \"dev_mode\",\n            \"utf8_mode\",\n            \"warn_default_encoding\",\n            \"safe_path\",\n            \"int_max_str_digits\",\n        )\n    elif sys.version_info >= (3, 10):\n        __match_args__: Final = (\n            \"debug\",\n            \"inspect\",\n            \"interactive\",\n            \"optimize\",\n            \"dont_write_bytecode\",\n            \"no_user_site\",\n            \"no_site\",\n            \"ignore_environment\",\n            \"verbose\",\n            \"bytes_warning\",\n            \"quiet\",\n            \"hash_randomization\",\n            \"isolated\",\n            \"dev_mode\",\n            \"utf8_mode\",\n            \"warn_default_encoding\",\n            \"int_max_str_digits\",\n        )\n\n    @property\n    def debug(self) -> int: ...\n    @property\n    def inspect(self) -> int: ...\n    @property\n    def interactive(self) -> int: ...\n    @property\n    def optimize(self) -> int: ...\n    @property\n    def dont_write_bytecode(self) -> int: ...\n    @property\n    def no_user_site(self) -> int: ...\n    @property\n    def no_site(self) -> int: ...\n    @property\n    def ignore_environment(self) -> int: ...\n    @property\n    def verbose(self) -> int: ...\n    @property\n    def bytes_warning(self) -> int: ...\n    @property\n    def quiet(self) -> int: ...\n    @property\n    def hash_randomization(self) -> int: ...\n    @property\n    def isolated(self) -> int: ...\n    @property\n    def dev_mode(self) -> bool: ...\n    @property\n    def utf8_mode(self) -> int: ...\n    if sys.version_info >= (3, 10):\n        @property\n        def warn_default_encoding(self) -> int: ...\n    if sys.version_info >= (3, 11):\n        @property\n        def safe_path(self) -> bool: ...\n    if sys.version_info >= (3, 13):\n        @property\n        def gil(self) -> Literal[0, 1]: ...\n    if sys.version_info >= (3, 14):\n        @property\n        def thread_inherit_context(self) -> Literal[0, 1]: ...\n        @property\n        def context_aware_warnings(self) -> Literal[0, 1]: ...\n    # Whether or not this exists on lower versions of Python\n    # may depend on which patch release you're using\n    # (it was backported to all Python versions on 3.8+ as a security fix)\n    # Added in: 3.9.14, 3.10.7\n    # and present in all versions of 3.11 and later.\n    @property\n    def int_max_str_digits(self) -> int: ...\n\nfloat_info: _float_info\n\n# This class is not exposed at runtime. It calls itself sys.float_info.\n@final\n@type_check_only\nclass _float_info(structseq[float], tuple[float, int, int, float, int, int, int, int, float, int, int]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\n            \"max\",\n            \"max_exp\",\n            \"max_10_exp\",\n            \"min\",\n            \"min_exp\",\n            \"min_10_exp\",\n            \"dig\",\n            \"mant_dig\",\n            \"epsilon\",\n            \"radix\",\n            \"rounds\",\n        )\n\n    @property\n    def max(self) -> float: ...  # DBL_MAX\n    @property\n    def max_exp(self) -> int: ...  # DBL_MAX_EXP\n    @property\n    def max_10_exp(self) -> int: ...  # DBL_MAX_10_EXP\n    @property\n    def min(self) -> float: ...  # DBL_MIN\n    @property\n    def min_exp(self) -> int: ...  # DBL_MIN_EXP\n    @property\n    def min_10_exp(self) -> int: ...  # DBL_MIN_10_EXP\n    @property\n    def dig(self) -> int: ...  # DBL_DIG\n    @property\n    def mant_dig(self) -> int: ...  # DBL_MANT_DIG\n    @property\n    def epsilon(self) -> float: ...  # DBL_EPSILON\n    @property\n    def radix(self) -> int: ...  # FLT_RADIX\n    @property\n    def rounds(self) -> int: ...  # FLT_ROUNDS\n\nhash_info: _hash_info\n\n# This class is not exposed at runtime. It calls itself sys.hash_info.\n@final\n@type_check_only\nclass _hash_info(structseq[Any | int], tuple[int, int, int, int, int, str, int, int, int]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"width\", \"modulus\", \"inf\", \"nan\", \"imag\", \"algorithm\", \"hash_bits\", \"seed_bits\", \"cutoff\")\n\n    @property\n    def width(self) -> int: ...\n    @property\n    def modulus(self) -> int: ...\n    @property\n    def inf(self) -> int: ...\n    @property\n    def nan(self) -> int: ...\n    @property\n    def imag(self) -> int: ...\n    @property\n    def algorithm(self) -> str: ...\n    @property\n    def hash_bits(self) -> int: ...\n    @property\n    def seed_bits(self) -> int: ...\n    @property\n    def cutoff(self) -> int: ...  # undocumented\n\nimplementation: _implementation\n\n# This class isn't really a thing. At runtime, implementation is an instance\n# of types.SimpleNamespace. This allows for better typing.\n@type_check_only\nclass _implementation:\n    name: str\n    version: _version_info\n    hexversion: int\n    cache_tag: str\n    # Define __getattr__, as the documentation states:\n    # > sys.implementation may contain additional attributes specific to the Python implementation.\n    # > These non-standard attributes must start with an underscore, and are not described here.\n    def __getattr__(self, name: str) -> Any: ...\n\nint_info: _int_info\n\n# This class is not exposed at runtime. It calls itself sys.int_info.\n@final\n@type_check_only\nclass _int_info(structseq[int], tuple[int, int, int, int]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"bits_per_digit\", \"sizeof_digit\", \"default_max_str_digits\", \"str_digits_check_threshold\")\n\n    @property\n    def bits_per_digit(self) -> int: ...\n    @property\n    def sizeof_digit(self) -> int: ...\n    @property\n    def default_max_str_digits(self) -> int: ...\n    @property\n    def str_digits_check_threshold(self) -> int: ...\n\n_ThreadInfoName: TypeAlias = Literal[\"nt\", \"pthread\", \"pthread-stubs\", \"solaris\"]\n_ThreadInfoLock: TypeAlias = Literal[\"semaphore\", \"mutex+cond\"] | None\n\n# This class is not exposed at runtime. It calls itself sys.thread_info.\n@final\n@type_check_only\nclass _thread_info(_UninstantiableStructseq, tuple[_ThreadInfoName, _ThreadInfoLock, str | None]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"name\", \"lock\", \"version\")\n\n    @property\n    def name(self) -> _ThreadInfoName: ...\n    @property\n    def lock(self) -> _ThreadInfoLock: ...\n    @property\n    def version(self) -> str | None: ...\n\nthread_info: _thread_info\n_ReleaseLevel: TypeAlias = Literal[\"alpha\", \"beta\", \"candidate\", \"final\"]\n\n# This class is not exposed at runtime. It calls itself sys.version_info.\n@final\n@type_check_only\nclass _version_info(_UninstantiableStructseq, tuple[int, int, int, _ReleaseLevel, int]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"major\", \"minor\", \"micro\", \"releaselevel\", \"serial\")\n\n    @property\n    def major(self) -> int: ...\n    @property\n    def minor(self) -> int: ...\n    @property\n    def micro(self) -> int: ...\n    @property\n    def releaselevel(self) -> _ReleaseLevel: ...\n    @property\n    def serial(self) -> int: ...\n\nversion_info: _version_info\n\ndef call_tracing(func: Callable[..., _T], args: Any, /) -> _T: ...\n\nif sys.version_info >= (3, 13):\n    @deprecated(\"Deprecated since Python 3.13. Use `_clear_internal_caches()` instead.\")\n    def _clear_type_cache() -> None: ...\n\nelse:\n    def _clear_type_cache() -> None: ...\n\ndef _current_frames() -> dict[int, FrameType]: ...\ndef _getframe(depth: int = 0, /) -> FrameType: ...\n\n# documented -- see https://docs.python.org/3/library/sys.html#sys._current_exceptions\nif sys.version_info >= (3, 12):\n    def _current_exceptions() -> dict[int, BaseException | None]: ...\n\nelse:\n    def _current_exceptions() -> dict[int, OptExcInfo]: ...\n\nif sys.version_info >= (3, 12):\n    def _getframemodulename(depth: int = 0) -> str | None: ...\n\ndef _debugmallocstats() -> None: ...\ndef __displayhook__(object: object, /) -> None: ...\ndef __excepthook__(exctype: type[BaseException], value: BaseException, traceback: TracebackType | None, /) -> None: ...\ndef exc_info() -> OptExcInfo: ...\n\nif sys.version_info >= (3, 11):\n    def exception() -> BaseException | None: ...\n\ndef exit(status: _ExitCode = None, /) -> NoReturn: ...\n\nif sys.platform == \"android\":  # noqa: Y008\n    def getandroidapilevel() -> int: ...\n\ndef getallocatedblocks() -> int: ...\ndef getdefaultencoding() -> Literal[\"utf-8\"]: ...\n\nif sys.platform != \"win32\":\n    def getdlopenflags() -> int: ...\n\ndef getfilesystemencoding() -> LiteralString: ...\ndef getfilesystemencodeerrors() -> LiteralString: ...\ndef getrefcount(object: Any, /) -> int: ...\ndef getrecursionlimit() -> int: ...\ndef getsizeof(obj: object, default: int = ...) -> int: ...\ndef getswitchinterval() -> float: ...\ndef getprofile() -> ProfileFunction | None: ...\ndef setprofile(function: ProfileFunction | None, /) -> None: ...\ndef gettrace() -> TraceFunction | None: ...\ndef settrace(function: TraceFunction | None, /) -> None: ...\n\nif sys.platform == \"win32\":\n    # A tuple of length 5, even though it has more than 5 attributes.\n    @final\n    @type_check_only\n    class _WinVersion(_UninstantiableStructseq, tuple[int, int, int, int, str]):\n        @property\n        def major(self) -> int: ...\n        @property\n        def minor(self) -> int: ...\n        @property\n        def build(self) -> int: ...\n        @property\n        def platform(self) -> int: ...\n        @property\n        def service_pack(self) -> str: ...\n        @property\n        def service_pack_minor(self) -> int: ...\n        @property\n        def service_pack_major(self) -> int: ...\n        @property\n        def suite_mask(self) -> int: ...\n        @property\n        def product_type(self) -> int: ...\n        @property\n        def platform_version(self) -> tuple[int, int, int]: ...\n\n    def getwindowsversion() -> _WinVersion: ...\n\n@overload\ndef intern(string: LiteralString, /) -> LiteralString: ...\n@overload\ndef intern(string: str, /) -> str: ...  # type: ignore[misc]\n\n__interactivehook__: Callable[[], object]\n\nif sys.version_info >= (3, 13):\n    def _is_gil_enabled() -> bool: ...\n    def _clear_internal_caches() -> None: ...\n    def _is_interned(string: str, /) -> bool: ...\n\ndef is_finalizing() -> bool: ...\ndef breakpointhook(*args: Any, **kwargs: Any) -> Any: ...\n\n__breakpointhook__ = breakpointhook  # Contains the original value of breakpointhook\n\nif sys.platform != \"win32\":\n    def setdlopenflags(flags: int, /) -> None: ...\n\ndef setrecursionlimit(limit: int, /) -> None: ...\ndef setswitchinterval(interval: float, /) -> None: ...\ndef gettotalrefcount() -> int: ...  # Debug builds only\n\n# Doesn't exist at runtime, but exported in the stubs so pytest etc. can annotate their code more easily.\n@type_check_only\nclass UnraisableHookArgs(Protocol):\n    exc_type: type[BaseException]\n    exc_value: BaseException | None\n    exc_traceback: TracebackType | None\n    err_msg: str | None\n    object: _object\n\nunraisablehook: Callable[[UnraisableHookArgs], Any]\n\ndef __unraisablehook__(unraisable: UnraisableHookArgs, /) -> Any: ...\ndef addaudithook(hook: Callable[[str, tuple[Any, ...]], Any]) -> None: ...\ndef audit(event: str, /, *args: Any) -> None: ...\n\n_AsyncgenHook: TypeAlias = Callable[[AsyncGenerator[Any, Any]], None] | None\n\n# This class is not exposed at runtime. It calls itself builtins.asyncgen_hooks.\n@final\n@type_check_only\nclass _asyncgen_hooks(structseq[_AsyncgenHook], tuple[_AsyncgenHook, _AsyncgenHook]):\n    if sys.version_info >= (3, 10):\n        __match_args__: Final = (\"firstiter\", \"finalizer\")\n\n    @property\n    def firstiter(self) -> _AsyncgenHook: ...\n    @property\n    def finalizer(self) -> _AsyncgenHook: ...\n\ndef get_asyncgen_hooks() -> _asyncgen_hooks: ...\ndef set_asyncgen_hooks(firstiter: _AsyncgenHook = ..., finalizer: _AsyncgenHook = ...) -> None: ...\n\nif sys.platform == \"win32\":\n    if sys.version_info >= (3, 13):\n        @deprecated(\n            \"Deprecated since Python 3.13; will be removed in Python 3.16. \"\n            \"Use the `PYTHONLEGACYWINDOWSFSENCODING` environment variable instead.\"\n        )\n        def _enablelegacywindowsfsencoding() -> None: ...\n    else:\n        def _enablelegacywindowsfsencoding() -> None: ...\n\ndef get_coroutine_origin_tracking_depth() -> int: ...\ndef set_coroutine_origin_tracking_depth(depth: int) -> None: ...\n\n# The following two functions were added in 3.11.0, 3.10.7, and 3.9.14,\n# as part of the response to CVE-2020-10735\ndef set_int_max_str_digits(maxdigits: int) -> None: ...\ndef get_int_max_str_digits() -> int: ...\n\nif sys.version_info >= (3, 12):\n    if sys.version_info >= (3, 13):\n        def getunicodeinternedsize(*, _only_immortal: bool = False) -> int: ...\n    else:\n        def getunicodeinternedsize() -> int: ...\n\n    def deactivate_stack_trampoline() -> None: ...\n    def is_stack_trampoline_active() -> bool: ...\n    # It always exists, but raises on non-linux platforms:\n    if sys.platform == \"linux\":\n        def activate_stack_trampoline(backend: str, /) -> None: ...\n    else:\n        def activate_stack_trampoline(backend: str, /) -> NoReturn: ...\n\n    from . import _monitoring\n\n    monitoring = _monitoring\n\nif sys.version_info >= (3, 14):\n    def is_remote_debug_enabled() -> bool: ...\n    def remote_exec(pid: int, script: StrOrBytesPath) -> None: ...\n    def _is_immortal(op: object, /) -> bool: ...\n",
  "/typeshed/stdlib/sys/_monitoring.pyi": "# This py312+ module provides annotations for `sys.monitoring`.\n# It's named `sys._monitoring` in typeshed,\n# because trying to import `sys.monitoring` will fail at runtime!\n# At runtime, `sys.monitoring` has the unique status\n# of being a `types.ModuleType` instance that cannot be directly imported,\n# and exists in the `sys`-module namespace despite `sys` not being a package.\n\nimport sys\nfrom collections.abc import Callable\nfrom types import CodeType\nfrom typing import Any, Final, type_check_only\nfrom typing_extensions import deprecated\n\nDEBUGGER_ID: Final = 0\nCOVERAGE_ID: Final = 1\nPROFILER_ID: Final = 2\nOPTIMIZER_ID: Final = 5\n\ndef use_tool_id(tool_id: int, name: str, /) -> None: ...\n\nif sys.version_info >= (3, 14):\n    def clear_tool_id(tool_id: int, /) -> None: ...\n\ndef free_tool_id(tool_id: int, /) -> None: ...\ndef get_tool(tool_id: int, /) -> str | None: ...\n\nevents: Final[_events]\n\n@type_check_only\nclass _events:\n    CALL: Final[int]\n    C_RAISE: Final[int]\n    C_RETURN: Final[int]\n    EXCEPTION_HANDLED: Final[int]\n    INSTRUCTION: Final[int]\n    JUMP: Final[int]\n    LINE: Final[int]\n    NO_EVENTS: Final[int]\n    PY_RESUME: Final[int]\n    PY_RETURN: Final[int]\n    PY_START: Final[int]\n    PY_THROW: Final[int]\n    PY_UNWIND: Final[int]\n    PY_YIELD: Final[int]\n    RAISE: Final[int]\n    RERAISE: Final[int]\n    STOP_ITERATION: Final[int]\n    if sys.version_info >= (3, 14):\n        BRANCH_LEFT: Final[int]\n        BRANCH_RIGHT: Final[int]\n\n        @property\n        @deprecated(\"Deprecated since Python 3.14. Use `BRANCH_LEFT` or `BRANCH_RIGHT` instead.\")\n        def BRANCH(self) -> int: ...\n\n    else:\n        BRANCH: Final[int]\n\ndef get_events(tool_id: int, /) -> int: ...\ndef set_events(tool_id: int, event_set: int, /) -> None: ...\ndef get_local_events(tool_id: int, code: CodeType, /) -> int: ...\ndef set_local_events(tool_id: int, code: CodeType, event_set: int, /) -> int: ...\ndef restart_events() -> None: ...\n\nDISABLE: Final[object]\nMISSING: Final[object]\n\ndef register_callback(tool_id: int, event: int, func: Callable[..., Any] | None, /) -> Callable[..., Any] | None: ...\n",
  "/typeshed/stdlib/sysconfig.pyi": "import sys\nfrom typing import IO, Any, Literal, overload\nfrom typing_extensions import LiteralString, deprecated\n\n__all__ = [\n    \"get_config_h_filename\",\n    \"get_config_var\",\n    \"get_config_vars\",\n    \"get_makefile_filename\",\n    \"get_path\",\n    \"get_path_names\",\n    \"get_paths\",\n    \"get_platform\",\n    \"get_python_version\",\n    \"get_scheme_names\",\n    \"parse_config_h\",\n]\n\n@overload\n@deprecated(\"SO is deprecated, use EXT_SUFFIX. Support is removed in Python 3.11\")\ndef get_config_var(name: Literal[\"SO\"]) -> Any: ...\n@overload\ndef get_config_var(name: str) -> Any: ...\n@overload\ndef get_config_vars() -> dict[str, Any]: ...\n@overload\ndef get_config_vars(arg: str, /, *args: str) -> list[Any]: ...\ndef get_scheme_names() -> tuple[str, ...]: ...\n\nif sys.version_info >= (3, 10):\n    def get_default_scheme() -> LiteralString: ...\n    def get_preferred_scheme(key: Literal[\"prefix\", \"home\", \"user\"]) -> LiteralString: ...\n    # Documented -- see https://docs.python.org/3/library/sysconfig.html#sysconfig._get_preferred_schemes\n    def _get_preferred_schemes() -> dict[Literal[\"prefix\", \"home\", \"user\"], LiteralString]: ...\n\ndef get_path_names() -> tuple[str, ...]: ...\ndef get_path(name: str, scheme: str = ..., vars: dict[str, Any] | None = None, expand: bool = True) -> str: ...\ndef get_paths(scheme: str = ..., vars: dict[str, Any] | None = None, expand: bool = True) -> dict[str, str]: ...\ndef get_python_version() -> str: ...\ndef get_platform() -> str: ...\n\nif sys.version_info >= (3, 12):\n    @overload\n    def is_python_build() -> bool: ...\n    @overload\n    @deprecated(\"The `check_home` parameter is deprecated since Python 3.12; removed in Python 3.15.\")\n    def is_python_build(check_home: object = None) -> bool: ...\n\nelif sys.version_info >= (3, 11):\n    def is_python_build(check_home: object = None) -> bool: ...\n\nelse:\n    def is_python_build(check_home: bool = False) -> bool: ...\n\ndef parse_config_h(fp: IO[Any], vars: dict[str, Any] | None = None) -> dict[str, Any]: ...\ndef get_config_h_filename() -> str: ...\ndef get_makefile_filename() -> str: ...\n",
  "/typeshed/stdlib/syslog.pyi": "import sys\nfrom typing import Final, overload\n\nif sys.platform != \"win32\":\n    LOG_ALERT: Final = 1\n    LOG_AUTH: Final = 32\n    LOG_AUTHPRIV: Final = 80\n    LOG_CONS: Final = 2\n    LOG_CRIT: Final = 2\n    LOG_CRON: Final = 72\n    LOG_DAEMON: Final = 24\n    LOG_DEBUG: Final = 7\n    LOG_EMERG: Final = 0\n    LOG_ERR: Final = 3\n    LOG_INFO: Final = 6\n    LOG_KERN: Final = 0\n    LOG_LOCAL0: Final = 128\n    LOG_LOCAL1: Final = 136\n    LOG_LOCAL2: Final = 144\n    LOG_LOCAL3: Final = 152\n    LOG_LOCAL4: Final = 160\n    LOG_LOCAL5: Final = 168\n    LOG_LOCAL6: Final = 176\n    LOG_LOCAL7: Final = 184\n    LOG_LPR: Final = 48\n    LOG_MAIL: Final = 16\n    LOG_NDELAY: Final = 8\n    LOG_NEWS: Final = 56\n    LOG_NOTICE: Final = 5\n    LOG_NOWAIT: Final = 16\n    LOG_ODELAY: Final = 4\n    LOG_PERROR: Final = 32\n    LOG_PID: Final = 1\n    LOG_SYSLOG: Final = 40\n    LOG_USER: Final = 8\n    LOG_UUCP: Final = 64\n    LOG_WARNING: Final = 4\n\n    if sys.version_info >= (3, 13):\n        LOG_FTP: Final = 88\n\n        if sys.platform == \"darwin\":\n            LOG_INSTALL: Final = 112\n            LOG_LAUNCHD: Final = 192\n            LOG_NETINFO: Final = 96\n            LOG_RAS: Final = 120\n            LOG_REMOTEAUTH: Final = 104\n\n    def LOG_MASK(pri: int, /) -> int: ...\n    def LOG_UPTO(pri: int, /) -> int: ...\n    def closelog() -> None: ...\n    def openlog(ident: str = ..., logoption: int = ..., facility: int = ...) -> None: ...\n    def setlogmask(maskpri: int, /) -> int: ...\n    @overload\n    def syslog(priority: int, message: str) -> None: ...\n    @overload\n    def syslog(message: str) -> None: ...\n",
  "/typeshed/stdlib/types.pyi": "import sys\nfrom _typeshed import AnnotationForm, MaybeNone, SupportsKeysAndGetItem\nfrom _typeshed.importlib import LoaderProtocol\nfrom collections.abc import (\n    AsyncGenerator,\n    Awaitable,\n    Callable,\n    Coroutine,\n    Generator,\n    ItemsView,\n    Iterable,\n    Iterator,\n    KeysView,\n    Mapping,\n    MutableSequence,\n    ValuesView,\n)\nfrom importlib.machinery import ModuleSpec\nfrom typing import Any, ClassVar, Literal, TypeVar, final, overload\nfrom typing_extensions import ParamSpec, Self, TypeAliasType, TypeVarTuple, deprecated, disjoint_base\n\nif sys.version_info >= (3, 14):\n    from _typeshed import AnnotateFunc\n\n__all__ = [\n    \"FunctionType\",\n    \"LambdaType\",\n    \"CodeType\",\n    \"MappingProxyType\",\n    \"SimpleNamespace\",\n    \"GeneratorType\",\n    \"CoroutineType\",\n    \"AsyncGeneratorType\",\n    \"MethodType\",\n    \"BuiltinFunctionType\",\n    \"ModuleType\",\n    \"TracebackType\",\n    \"FrameType\",\n    \"GetSetDescriptorType\",\n    \"MemberDescriptorType\",\n    \"new_class\",\n    \"prepare_class\",\n    \"DynamicClassAttribute\",\n    \"coroutine\",\n    \"BuiltinMethodType\",\n    \"ClassMethodDescriptorType\",\n    \"MethodDescriptorType\",\n    \"MethodWrapperType\",\n    \"WrapperDescriptorType\",\n    \"resolve_bases\",\n    \"CellType\",\n    \"GenericAlias\",\n]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"EllipsisType\", \"NoneType\", \"NotImplementedType\", \"UnionType\"]\n\nif sys.version_info >= (3, 12):\n    __all__ += [\"get_original_bases\"]\n\nif sys.version_info >= (3, 13):\n    __all__ += [\"CapsuleType\"]\n\n# Note, all classes \"defined\" here require special handling.\n\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_KT_co = TypeVar(\"_KT_co\", covariant=True)\n_VT_co = TypeVar(\"_VT_co\", covariant=True)\n\n# Make sure this class definition stays roughly in line with `builtins.function`\n@final\nclass FunctionType:\n    @property\n    def __closure__(self) -> tuple[CellType, ...] | None: ...\n    __code__: CodeType\n    __defaults__: tuple[Any, ...] | None\n    __dict__: dict[str, Any]\n    @property\n    def __globals__(self) -> dict[str, Any]: ...\n    __name__: str\n    __qualname__: str\n    __annotations__: dict[str, AnnotationForm]\n    if sys.version_info >= (3, 14):\n        __annotate__: AnnotateFunc | None\n    __kwdefaults__: dict[str, Any] | None\n    if sys.version_info >= (3, 10):\n        @property\n        def __builtins__(self) -> dict[str, Any]: ...\n    if sys.version_info >= (3, 12):\n        __type_params__: tuple[TypeVar | ParamSpec | TypeVarTuple, ...]\n\n    __module__: str\n    if sys.version_info >= (3, 13):\n        def __new__(\n            cls,\n            code: CodeType,\n            globals: dict[str, Any],\n            name: str | None = None,\n            argdefs: tuple[object, ...] | None = None,\n            closure: tuple[CellType, ...] | None = None,\n            kwdefaults: dict[str, object] | None = None,\n        ) -> Self: ...\n    else:\n        def __new__(\n            cls,\n            code: CodeType,\n            globals: dict[str, Any],\n            name: str | None = None,\n            argdefs: tuple[object, ...] | None = None,\n            closure: tuple[CellType, ...] | None = None,\n        ) -> Self: ...\n\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    @overload\n    def __get__(self, instance: None, owner: type, /) -> FunctionType: ...\n    @overload\n    def __get__(self, instance: object, owner: type | None = None, /) -> MethodType: ...\n\nLambdaType = FunctionType\n\n@final\nclass CodeType:\n    def __eq__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n    @property\n    def co_argcount(self) -> int: ...\n    @property\n    def co_posonlyargcount(self) -> int: ...\n    @property\n    def co_kwonlyargcount(self) -> int: ...\n    @property\n    def co_nlocals(self) -> int: ...\n    @property\n    def co_stacksize(self) -> int: ...\n    @property\n    def co_flags(self) -> int: ...\n    @property\n    def co_code(self) -> bytes: ...\n    @property\n    def co_consts(self) -> tuple[Any, ...]: ...\n    @property\n    def co_names(self) -> tuple[str, ...]: ...\n    @property\n    def co_varnames(self) -> tuple[str, ...]: ...\n    @property\n    def co_filename(self) -> str: ...\n    @property\n    def co_name(self) -> str: ...\n    @property\n    def co_firstlineno(self) -> int: ...\n    if sys.version_info >= (3, 10):\n        @property\n        @deprecated(\"Deprecated since Python 3.10; will be removed in Python 3.15. Use `CodeType.co_lines()` instead.\")\n        def co_lnotab(self) -> bytes: ...\n    else:\n        @property\n        def co_lnotab(self) -> bytes: ...\n\n    @property\n    def co_freevars(self) -> tuple[str, ...]: ...\n    @property\n    def co_cellvars(self) -> tuple[str, ...]: ...\n    if sys.version_info >= (3, 10):\n        @property\n        def co_linetable(self) -> bytes: ...\n        def co_lines(self) -> Iterator[tuple[int, int, int | None]]: ...\n    if sys.version_info >= (3, 11):\n        @property\n        def co_exceptiontable(self) -> bytes: ...\n        @property\n        def co_qualname(self) -> str: ...\n        def co_positions(self) -> Iterable[tuple[int | None, int | None, int | None, int | None]]: ...\n    if sys.version_info >= (3, 14):\n        def co_branches(self) -> Iterator[tuple[int, int, int]]: ...\n\n    if sys.version_info >= (3, 11):\n        def __new__(\n            cls,\n            argcount: int,\n            posonlyargcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: tuple[object, ...],\n            names: tuple[str, ...],\n            varnames: tuple[str, ...],\n            filename: str,\n            name: str,\n            qualname: str,\n            firstlineno: int,\n            linetable: bytes,\n            exceptiontable: bytes,\n            freevars: tuple[str, ...] = ...,\n            cellvars: tuple[str, ...] = ...,\n            /,\n        ) -> Self: ...\n    elif sys.version_info >= (3, 10):\n        def __new__(\n            cls,\n            argcount: int,\n            posonlyargcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: tuple[object, ...],\n            names: tuple[str, ...],\n            varnames: tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            linetable: bytes,\n            freevars: tuple[str, ...] = ...,\n            cellvars: tuple[str, ...] = ...,\n            /,\n        ) -> Self: ...\n    else:\n        def __new__(\n            cls,\n            argcount: int,\n            posonlyargcount: int,\n            kwonlyargcount: int,\n            nlocals: int,\n            stacksize: int,\n            flags: int,\n            codestring: bytes,\n            constants: tuple[object, ...],\n            names: tuple[str, ...],\n            varnames: tuple[str, ...],\n            filename: str,\n            name: str,\n            firstlineno: int,\n            lnotab: bytes,\n            freevars: tuple[str, ...] = ...,\n            cellvars: tuple[str, ...] = ...,\n            /,\n        ) -> Self: ...\n    if sys.version_info >= (3, 11):\n        def replace(\n            self,\n            *,\n            co_argcount: int = -1,\n            co_posonlyargcount: int = -1,\n            co_kwonlyargcount: int = -1,\n            co_nlocals: int = -1,\n            co_stacksize: int = -1,\n            co_flags: int = -1,\n            co_firstlineno: int = -1,\n            co_code: bytes = ...,\n            co_consts: tuple[object, ...] = ...,\n            co_names: tuple[str, ...] = ...,\n            co_varnames: tuple[str, ...] = ...,\n            co_freevars: tuple[str, ...] = ...,\n            co_cellvars: tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_qualname: str = ...,\n            co_linetable: bytes = ...,\n            co_exceptiontable: bytes = ...,\n        ) -> Self: ...\n    elif sys.version_info >= (3, 10):\n        def replace(\n            self,\n            *,\n            co_argcount: int = -1,\n            co_posonlyargcount: int = -1,\n            co_kwonlyargcount: int = -1,\n            co_nlocals: int = -1,\n            co_stacksize: int = -1,\n            co_flags: int = -1,\n            co_firstlineno: int = -1,\n            co_code: bytes = ...,\n            co_consts: tuple[object, ...] = ...,\n            co_names: tuple[str, ...] = ...,\n            co_varnames: tuple[str, ...] = ...,\n            co_freevars: tuple[str, ...] = ...,\n            co_cellvars: tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_linetable: bytes = ...,\n        ) -> Self: ...\n    else:\n        def replace(\n            self,\n            *,\n            co_argcount: int = -1,\n            co_posonlyargcount: int = -1,\n            co_kwonlyargcount: int = -1,\n            co_nlocals: int = -1,\n            co_stacksize: int = -1,\n            co_flags: int = -1,\n            co_firstlineno: int = -1,\n            co_code: bytes = ...,\n            co_consts: tuple[object, ...] = ...,\n            co_names: tuple[str, ...] = ...,\n            co_varnames: tuple[str, ...] = ...,\n            co_freevars: tuple[str, ...] = ...,\n            co_cellvars: tuple[str, ...] = ...,\n            co_filename: str = ...,\n            co_name: str = ...,\n            co_lnotab: bytes = ...,\n        ) -> Self: ...\n\n    if sys.version_info >= (3, 13):\n        __replace__ = replace\n\n@final\nclass MappingProxyType(Mapping[_KT_co, _VT_co]):  # type: ignore[type-var]  # pyright: ignore[reportInvalidTypeArguments]\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    def __new__(cls, mapping: SupportsKeysAndGetItem[_KT_co, _VT_co]) -> Self: ...\n    def __getitem__(self, key: _KT_co, /) -> _VT_co: ...  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues]\n    def __iter__(self) -> Iterator[_KT_co]: ...\n    def __len__(self) -> int: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def copy(self) -> dict[_KT_co, _VT_co]: ...\n    def keys(self) -> KeysView[_KT_co]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def items(self) -> ItemsView[_KT_co, _VT_co]: ...\n    @overload\n    def get(self, key: _KT_co, /) -> _VT_co | None: ...  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues] # Covariant type as parameter\n    @overload\n    def get(self, key: _KT_co, default: _VT_co, /) -> _VT_co: ...  # type: ignore[misc] # pyright: ignore[reportGeneralTypeIssues] # Covariant type as parameter\n    @overload\n    def get(self, key: _KT_co, default: _T2, /) -> _VT_co | _T2: ...  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues] # Covariant type as parameter\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n    def __reversed__(self) -> Iterator[_KT_co]: ...\n    def __or__(self, value: Mapping[_T1, _T2], /) -> dict[_KT_co | _T1, _VT_co | _T2]: ...\n    def __ror__(self, value: Mapping[_T1, _T2], /) -> dict[_KT_co | _T1, _VT_co | _T2]: ...\n\nif sys.version_info >= (3, 12):\n    @disjoint_base\n    class SimpleNamespace:\n        __hash__: ClassVar[None]  # type: ignore[assignment]\n        if sys.version_info >= (3, 13):\n            def __init__(\n                self, mapping_or_iterable: Mapping[str, Any] | Iterable[tuple[str, Any]] = (), /, **kwargs: Any\n            ) -> None: ...\n        else:\n            def __init__(self, **kwargs: Any) -> None: ...\n\n        def __eq__(self, value: object, /) -> bool: ...\n        def __getattribute__(self, name: str, /) -> Any: ...\n        def __setattr__(self, name: str, value: Any, /) -> None: ...\n        def __delattr__(self, name: str, /) -> None: ...\n        if sys.version_info >= (3, 13):\n            def __replace__(self, **kwargs: Any) -> Self: ...\n\nelse:\n    class SimpleNamespace:\n        __hash__: ClassVar[None]  # type: ignore[assignment]\n        def __init__(self, **kwargs: Any) -> None: ...\n        def __eq__(self, value: object, /) -> bool: ...\n        def __getattribute__(self, name: str, /) -> Any: ...\n        def __setattr__(self, name: str, value: Any, /) -> None: ...\n        def __delattr__(self, name: str, /) -> None: ...\n\n@disjoint_base\nclass ModuleType:\n    __name__: str\n    __file__: str | None\n    @property\n    def __dict__(self) -> dict[str, Any]: ...  # type: ignore[override]\n    __loader__: LoaderProtocol | None\n    __package__: str | None\n    __path__: MutableSequence[str]\n    __spec__: ModuleSpec | None\n    # N.B. Although this is the same type as `builtins.object.__doc__`,\n    # it is deliberately redeclared here. Most symbols declared in the namespace\n    # of `types.ModuleType` are available as \"implicit globals\" within a module's\n    # namespace, but this is not true for symbols declared in the namespace of `builtins.object`.\n    # Redeclaring `__doc__` here helps some type checkers understand that `__doc__` is available\n    # as an implicit global in all modules, similar to `__name__`, `__file__`, `__spec__`, etc.\n    __doc__: str | None\n    __annotations__: dict[str, AnnotationForm]\n    if sys.version_info >= (3, 14):\n        __annotate__: AnnotateFunc | None\n\n    def __init__(self, name: str, doc: str | None = ...) -> None: ...\n    # __getattr__ doesn't exist at runtime,\n    # but having it here in typeshed makes dynamic imports\n    # using `builtins.__import__` or `importlib.import_module` less painful\n    def __getattr__(self, name: str) -> Any: ...\n\n@final\nclass CellType:\n    def __new__(cls, contents: object = ..., /) -> Self: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n    cell_contents: Any\n\n_YieldT_co = TypeVar(\"_YieldT_co\", covariant=True)\n_SendT_contra = TypeVar(\"_SendT_contra\", contravariant=True, default=None)\n_ReturnT_co = TypeVar(\"_ReturnT_co\", covariant=True, default=None)\n\n@final\nclass GeneratorType(Generator[_YieldT_co, _SendT_contra, _ReturnT_co]):\n    @property\n    def gi_code(self) -> CodeType: ...\n    @property\n    def gi_frame(self) -> FrameType: ...\n    @property\n    def gi_running(self) -> bool: ...\n    @property\n    def gi_yieldfrom(self) -> Iterator[_YieldT_co] | None: ...\n    if sys.version_info >= (3, 11):\n        @property\n        def gi_suspended(self) -> bool: ...\n    __name__: str\n    __qualname__: str\n    def __iter__(self) -> Self: ...\n    def __next__(self) -> _YieldT_co: ...\n    def send(self, arg: _SendT_contra, /) -> _YieldT_co: ...\n    @overload\n    def throw(\n        self, typ: type[BaseException], val: BaseException | object = ..., tb: TracebackType | None = ..., /\n    ) -> _YieldT_co: ...\n    @overload\n    def throw(self, typ: BaseException, val: None = None, tb: TracebackType | None = ..., /) -> _YieldT_co: ...\n    if sys.version_info >= (3, 13):\n        def __class_getitem__(cls, item: Any, /) -> Any: ...\n\n@final\nclass AsyncGeneratorType(AsyncGenerator[_YieldT_co, _SendT_contra]):\n    @property\n    def ag_await(self) -> Awaitable[Any] | None: ...\n    @property\n    def ag_code(self) -> CodeType: ...\n    @property\n    def ag_frame(self) -> FrameType: ...\n    @property\n    def ag_running(self) -> bool: ...\n    __name__: str\n    __qualname__: str\n    if sys.version_info >= (3, 12):\n        @property\n        def ag_suspended(self) -> bool: ...\n\n    def __aiter__(self) -> Self: ...\n    def __anext__(self) -> Coroutine[Any, Any, _YieldT_co]: ...\n    def asend(self, val: _SendT_contra, /) -> Coroutine[Any, Any, _YieldT_co]: ...\n    @overload\n    async def athrow(\n        self, typ: type[BaseException], val: BaseException | object = ..., tb: TracebackType | None = ..., /\n    ) -> _YieldT_co: ...\n    @overload\n    async def athrow(self, typ: BaseException, val: None = None, tb: TracebackType | None = ..., /) -> _YieldT_co: ...\n    def aclose(self) -> Coroutine[Any, Any, None]: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\n# Non-default variations to accommodate coroutines\n_SendT_nd_contra = TypeVar(\"_SendT_nd_contra\", contravariant=True)\n_ReturnT_nd_co = TypeVar(\"_ReturnT_nd_co\", covariant=True)\n\n@final\nclass CoroutineType(Coroutine[_YieldT_co, _SendT_nd_contra, _ReturnT_nd_co]):\n    __name__: str\n    __qualname__: str\n    @property\n    def cr_await(self) -> Any | None: ...\n    @property\n    def cr_code(self) -> CodeType: ...\n    if sys.version_info >= (3, 12):\n        @property\n        def cr_frame(self) -> FrameType | None: ...\n    else:\n        @property\n        def cr_frame(self) -> FrameType: ...\n\n    @property\n    def cr_running(self) -> bool: ...\n    @property\n    def cr_origin(self) -> tuple[tuple[str, int, str], ...] | None: ...\n    if sys.version_info >= (3, 11):\n        @property\n        def cr_suspended(self) -> bool: ...\n\n    def close(self) -> None: ...\n    def __await__(self) -> Generator[Any, None, _ReturnT_nd_co]: ...\n    def send(self, arg: _SendT_nd_contra, /) -> _YieldT_co: ...\n    @overload\n    def throw(\n        self, typ: type[BaseException], val: BaseException | object = ..., tb: TracebackType | None = ..., /\n    ) -> _YieldT_co: ...\n    @overload\n    def throw(self, typ: BaseException, val: None = None, tb: TracebackType | None = ..., /) -> _YieldT_co: ...\n    if sys.version_info >= (3, 13):\n        def __class_getitem__(cls, item: Any, /) -> Any: ...\n\n@final\nclass MethodType:\n    @property\n    def __closure__(self) -> tuple[CellType, ...] | None: ...  # inherited from the added function\n    @property\n    def __code__(self) -> CodeType: ...  # inherited from the added function\n    @property\n    def __defaults__(self) -> tuple[Any, ...] | None: ...  # inherited from the added function\n    @property\n    def __func__(self) -> Callable[..., Any]: ...\n    @property\n    def __self__(self) -> object: ...\n    @property\n    def __name__(self) -> str: ...  # inherited from the added function\n    @property\n    def __qualname__(self) -> str: ...  # inherited from the added function\n    def __new__(cls, func: Callable[..., Any], instance: object, /) -> Self: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n\n    if sys.version_info >= (3, 13):\n        def __get__(self, instance: object, owner: type | None = None, /) -> Self: ...\n\n    def __eq__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n\n@final\nclass BuiltinFunctionType:\n    @property\n    def __self__(self) -> object | ModuleType: ...\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n\nBuiltinMethodType = BuiltinFunctionType\n\n@final\nclass WrapperDescriptorType:\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    @property\n    def __objclass__(self) -> type: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...\n\n@final\nclass MethodWrapperType:\n    @property\n    def __self__(self) -> object: ...\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    @property\n    def __objclass__(self) -> type: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __ne__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n\n@final\nclass MethodDescriptorType:\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    @property\n    def __objclass__(self) -> type: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...\n\n@final\nclass ClassMethodDescriptorType:\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    @property\n    def __objclass__(self) -> type: ...\n    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...\n    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...\n\n@final\nclass TracebackType:\n    def __new__(cls, tb_next: TracebackType | None, tb_frame: FrameType, tb_lasti: int, tb_lineno: int) -> Self: ...\n    tb_next: TracebackType | None\n    # the rest are read-only\n    @property\n    def tb_frame(self) -> FrameType: ...\n    @property\n    def tb_lasti(self) -> int: ...\n    @property\n    def tb_lineno(self) -> int: ...\n\n@final\nclass FrameType:\n    @property\n    def f_back(self) -> FrameType | None: ...\n    @property\n    def f_builtins(self) -> dict[str, Any]: ...\n    @property\n    def f_code(self) -> CodeType: ...\n    @property\n    def f_globals(self) -> dict[str, Any]: ...\n    @property\n    def f_lasti(self) -> int: ...\n    # see discussion in #6769: f_lineno *can* sometimes be None,\n    # but you should probably file a bug report with CPython if you encounter it being None in the wild.\n    # An `int | None` annotation here causes too many false-positive errors, so applying `int | Any`.\n    @property\n    def f_lineno(self) -> int | MaybeNone: ...\n    @property\n    def f_locals(self) -> dict[str, Any]: ...\n    f_trace: Callable[[FrameType, str, Any], Any] | None\n    f_trace_lines: bool\n    f_trace_opcodes: bool\n    def clear(self) -> None: ...\n    if sys.version_info >= (3, 14):\n        @property\n        def f_generator(self) -> GeneratorType[Any, Any, Any] | CoroutineType[Any, Any, Any] | None: ...\n\n@final\nclass GetSetDescriptorType:\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    @property\n    def __objclass__(self) -> type: ...\n    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...\n    def __set__(self, instance: Any, value: Any, /) -> None: ...\n    def __delete__(self, instance: Any, /) -> None: ...\n\n@final\nclass MemberDescriptorType:\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __qualname__(self) -> str: ...\n    @property\n    def __objclass__(self) -> type: ...\n    def __get__(self, instance: Any, owner: type | None = None, /) -> Any: ...\n    def __set__(self, instance: Any, value: Any, /) -> None: ...\n    def __delete__(self, instance: Any, /) -> None: ...\n\ndef new_class(\n    name: str,\n    bases: Iterable[object] = (),\n    kwds: dict[str, Any] | None = None,\n    exec_body: Callable[[dict[str, Any]], object] | None = None,\n) -> type: ...\ndef resolve_bases(bases: Iterable[object]) -> tuple[Any, ...]: ...\ndef prepare_class(\n    name: str, bases: tuple[type, ...] = (), kwds: dict[str, Any] | None = None\n) -> tuple[type, dict[str, Any], dict[str, Any]]: ...\n\nif sys.version_info >= (3, 12):\n    def get_original_bases(cls: type, /) -> tuple[Any, ...]: ...\n\n# Does not actually inherit from property, but saying it does makes sure that\n# pyright handles this class correctly.\nclass DynamicClassAttribute(property):\n    fget: Callable[[Any], Any] | None\n    fset: Callable[[Any, Any], object] | None  # type: ignore[assignment]\n    fdel: Callable[[Any], object] | None  # type: ignore[assignment]\n    overwrite_doc: bool\n    __isabstractmethod__: bool\n    def __init__(\n        self,\n        fget: Callable[[Any], Any] | None = None,\n        fset: Callable[[Any, Any], object] | None = None,\n        fdel: Callable[[Any], object] | None = None,\n        doc: str | None = None,\n    ) -> None: ...\n    def __get__(self, instance: Any, ownerclass: type | None = None) -> Any: ...\n    def __set__(self, instance: Any, value: Any) -> None: ...\n    def __delete__(self, instance: Any) -> None: ...\n    def getter(self, fget: Callable[[Any], Any]) -> DynamicClassAttribute: ...\n    def setter(self, fset: Callable[[Any, Any], object]) -> DynamicClassAttribute: ...\n    def deleter(self, fdel: Callable[[Any], object]) -> DynamicClassAttribute: ...\n\n_Fn = TypeVar(\"_Fn\", bound=Callable[..., object])\n_R = TypeVar(\"_R\")\n_P = ParamSpec(\"_P\")\n\n# it's not really an Awaitable, but can be used in an await expression. Real type: Generator & Awaitable\n@overload\ndef coroutine(func: Callable[_P, Generator[Any, Any, _R]]) -> Callable[_P, Awaitable[_R]]: ...\n@overload\ndef coroutine(func: _Fn) -> _Fn: ...\n@disjoint_base\nclass GenericAlias:\n    @property\n    def __origin__(self) -> type | TypeAliasType: ...\n    @property\n    def __args__(self) -> tuple[Any, ...]: ...\n    @property\n    def __parameters__(self) -> tuple[Any, ...]: ...\n    def __new__(cls, origin: type, args: Any, /) -> Self: ...\n    def __getitem__(self, typeargs: Any, /) -> GenericAlias: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __mro_entries__(self, bases: Iterable[object], /) -> tuple[type, ...]: ...\n    if sys.version_info >= (3, 11):\n        @property\n        def __unpacked__(self) -> bool: ...\n        @property\n        def __typing_unpacked_tuple_args__(self) -> tuple[Any, ...] | None: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, value: Any, /) -> UnionType: ...\n        def __ror__(self, value: Any, /) -> UnionType: ...\n\n    # GenericAlias delegates attr access to `__origin__`\n    def __getattr__(self, name: str) -> Any: ...\n\nif sys.version_info >= (3, 10):\n    @final\n    class NoneType:\n        def __bool__(self) -> Literal[False]: ...\n\n    @final\n    class EllipsisType: ...\n\n    @final\n    class NotImplementedType(Any): ...\n\n    @final\n    class UnionType:\n        @property\n        def __args__(self) -> tuple[Any, ...]: ...\n        @property\n        def __parameters__(self) -> tuple[Any, ...]: ...\n        # `(int | str) | Literal[\"foo\"]` returns a generic alias to an instance of `_SpecialForm` (`Union`).\n        # Normally we'd express this using the return type of `_SpecialForm.__ror__`,\n        # but because `UnionType.__or__` accepts `Any`, type checkers will use\n        # the return type of `UnionType.__or__` to infer the result of this operation\n        # rather than `_SpecialForm.__ror__`. To mitigate this, we use `| Any`\n        # in the return type of `UnionType.__(r)or__`.\n        def __or__(self, value: Any, /) -> UnionType | Any: ...\n        def __ror__(self, value: Any, /) -> UnionType | Any: ...\n        def __eq__(self, value: object, /) -> bool: ...\n        def __hash__(self) -> int: ...\n        # you can only subscript a `UnionType` instance if at least one of the elements\n        # in the union is a generic alias instance that has a non-empty `__parameters__`\n        def __getitem__(self, parameters: Any) -> object: ...\n\nif sys.version_info >= (3, 13):\n    @final\n    class CapsuleType: ...\n",
  "/typeshed/stdlib/typing.pyi": "# Since this module defines \"overload\" it is not recognized by Ruff as typing.overload\n# TODO: The collections import is required, otherwise mypy crashes.\n# https://github.com/python/mypy/issues/16744\nimport collections  # noqa: F401  # pyright: ignore[reportUnusedImport]\nimport sys\nimport typing_extensions\nfrom _collections_abc import dict_items, dict_keys, dict_values\nfrom _typeshed import IdentityFunction, ReadableBuffer, SupportsGetItem, SupportsGetItemViewable, SupportsKeysAndGetItem, Viewable\nfrom abc import ABCMeta, abstractmethod\nfrom re import Match as Match, Pattern as Pattern\nfrom types import (\n    BuiltinFunctionType,\n    CodeType,\n    FunctionType,\n    GenericAlias,\n    MethodDescriptorType,\n    MethodType,\n    MethodWrapperType,\n    ModuleType,\n    TracebackType,\n    WrapperDescriptorType,\n)\nfrom typing_extensions import Never as _Never, ParamSpec as _ParamSpec, deprecated\n\nif sys.version_info >= (3, 14):\n    from _typeshed import EvaluateFunc\n\n    from annotationlib import Format\n\nif sys.version_info >= (3, 10):\n    from types import UnionType\n\n__all__ = [\n    \"AbstractSet\",\n    \"Annotated\",\n    \"Any\",\n    \"AnyStr\",\n    \"AsyncContextManager\",\n    \"AsyncGenerator\",\n    \"AsyncIterable\",\n    \"AsyncIterator\",\n    \"Awaitable\",\n    \"BinaryIO\",\n    \"ByteString\",\n    \"Callable\",\n    \"ChainMap\",\n    \"ClassVar\",\n    \"Collection\",\n    \"Container\",\n    \"ContextManager\",\n    \"Coroutine\",\n    \"Counter\",\n    \"DefaultDict\",\n    \"Deque\",\n    \"Dict\",\n    \"Final\",\n    \"ForwardRef\",\n    \"FrozenSet\",\n    \"Generator\",\n    \"Generic\",\n    \"Hashable\",\n    \"IO\",\n    \"ItemsView\",\n    \"Iterable\",\n    \"Iterator\",\n    \"KeysView\",\n    \"List\",\n    \"Literal\",\n    \"Mapping\",\n    \"MappingView\",\n    \"Match\",\n    \"MutableMapping\",\n    \"MutableSequence\",\n    \"MutableSet\",\n    \"NamedTuple\",\n    \"NewType\",\n    \"NoReturn\",\n    \"Optional\",\n    \"OrderedDict\",\n    \"Pattern\",\n    \"Protocol\",\n    \"Reversible\",\n    \"Sequence\",\n    \"Set\",\n    \"Sized\",\n    \"SupportsAbs\",\n    \"SupportsBytes\",\n    \"SupportsComplex\",\n    \"SupportsFloat\",\n    \"SupportsIndex\",\n    \"SupportsInt\",\n    \"SupportsRound\",\n    \"Text\",\n    \"TextIO\",\n    \"Tuple\",\n    \"Type\",\n    \"TypeVar\",\n    \"TypedDict\",\n    \"Union\",\n    \"ValuesView\",\n    \"TYPE_CHECKING\",\n    \"cast\",\n    \"final\",\n    \"get_args\",\n    \"get_origin\",\n    \"get_type_hints\",\n    \"no_type_check\",\n    \"no_type_check_decorator\",\n    \"overload\",\n    \"runtime_checkable\",\n]\n\nif sys.version_info >= (3, 14):\n    __all__ += [\"evaluate_forward_ref\"]\n\nif sys.version_info >= (3, 10):\n    __all__ += [\"Concatenate\", \"ParamSpec\", \"ParamSpecArgs\", \"ParamSpecKwargs\", \"TypeAlias\", \"TypeGuard\", \"is_typeddict\"]\n\nif sys.version_info >= (3, 11):\n    __all__ += [\n        \"LiteralString\",\n        \"Never\",\n        \"NotRequired\",\n        \"Required\",\n        \"Self\",\n        \"TypeVarTuple\",\n        \"Unpack\",\n        \"assert_never\",\n        \"assert_type\",\n        \"clear_overloads\",\n        \"dataclass_transform\",\n        \"get_overloads\",\n        \"reveal_type\",\n    ]\n\nif sys.version_info >= (3, 12):\n    __all__ += [\"TypeAliasType\", \"override\"]\n\nif sys.version_info >= (3, 13):\n    __all__ += [\"get_protocol_members\", \"is_protocol\", \"NoDefault\", \"TypeIs\", \"ReadOnly\"]\n\n# We can't use this name here because it leads to issues with mypy, likely\n# due to an import cycle. Below instead we use Any with a comment.\n# from _typeshed import AnnotationForm\n\nclass Any: ...\n\nclass _Final:\n    __slots__ = (\"__weakref__\",)\n\ndef final(f: _T) -> _T: ...\n@final\nclass TypeVar:\n    @property\n    def __name__(self) -> str: ...\n    @property\n    def __bound__(self) -> Any | None: ...  # AnnotationForm\n    @property\n    def __constraints__(self) -> tuple[Any, ...]: ...  # AnnotationForm\n    @property\n    def __covariant__(self) -> bool: ...\n    @property\n    def __contravariant__(self) -> bool: ...\n    if sys.version_info >= (3, 12):\n        @property\n        def __infer_variance__(self) -> bool: ...\n    if sys.version_info >= (3, 13):\n        @property\n        def __default__(self) -> Any: ...  # AnnotationForm\n    if sys.version_info >= (3, 13):\n        def __new__(\n            cls,\n            name: str,\n            *constraints: Any,  # AnnotationForm\n            bound: Any | None = None,  # AnnotationForm\n            contravariant: bool = False,\n            covariant: bool = False,\n            infer_variance: bool = False,\n            default: Any = ...,  # AnnotationForm\n        ) -> Self: ...\n    elif sys.version_info >= (3, 12):\n        def __new__(\n            cls,\n            name: str,\n            *constraints: Any,  # AnnotationForm\n            bound: Any | None = None,  # AnnotationForm\n            covariant: bool = False,\n            contravariant: bool = False,\n            infer_variance: bool = False,\n        ) -> Self: ...\n    elif sys.version_info >= (3, 11):\n        def __new__(\n            cls,\n            name: str,\n            *constraints: Any,  # AnnotationForm\n            bound: Any | None = None,  # AnnotationForm\n            covariant: bool = False,\n            contravariant: bool = False,\n        ) -> Self: ...\n    else:\n        def __init__(\n            self,\n            name: str,\n            *constraints: Any,  # AnnotationForm\n            bound: Any | None = None,  # AnnotationForm\n            covariant: bool = False,\n            contravariant: bool = False,\n        ) -> None: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, right: Any, /) -> _SpecialForm: ...  # AnnotationForm\n        def __ror__(self, left: Any, /) -> _SpecialForm: ...  # AnnotationForm\n    if sys.version_info >= (3, 11):\n        def __typing_subst__(self, arg: Any, /) -> Any: ...\n    if sys.version_info >= (3, 13):\n        def __typing_prepare_subst__(self, alias: Any, args: Any, /) -> tuple[Any, ...]: ...\n        def has_default(self) -> bool: ...\n    if sys.version_info >= (3, 14):\n        @property\n        def evaluate_bound(self) -> EvaluateFunc | None: ...\n        @property\n        def evaluate_constraints(self) -> EvaluateFunc | None: ...\n        @property\n        def evaluate_default(self) -> EvaluateFunc | None: ...\n\n# N.B. Keep this definition in sync with typing_extensions._SpecialForm\n@final\nclass _SpecialForm(_Final):\n    __slots__ = (\"_name\", \"__doc__\", \"_getitem\")\n    def __getitem__(self, parameters: Any) -> object: ...\n    if sys.version_info >= (3, 10):\n        def __or__(self, other: Any) -> _SpecialForm: ...\n        def __ror__(self, other: Any) -> _SpecialForm: ...\n\nUnion: _SpecialForm\nProtocol: _SpecialForm\nCallable: _SpecialForm\nType: _SpecialForm\nNoReturn: _SpecialForm\nClassVar: _SpecialForm\n\nOptional: _SpecialForm\nTuple: _SpecialForm\nFinal: _SpecialForm\n\nLiteral: _SpecialForm\nTypedDict: _SpecialForm\n\nif sys.version_info >= (3, 11):\n    Self: _SpecialForm\n    Never: _SpecialForm\n    Unpack: _SpecialForm\n    Required: _SpecialForm\n    NotRequired: _SpecialForm\n    LiteralString: _SpecialForm\n\n    @final\n    class TypeVarTuple:\n        @property\n        def __name__(self) -> str: ...\n        if sys.version_info >= (3, 13):\n            @property\n            def __default__(self) -> Any: ...  # AnnotationForm\n            def has_default(self) -> bool: ...\n        if sys.version_info >= (3, 13):\n            def __new__(cls, name: str, *, default: Any = ...) -> Self: ...  # AnnotationForm\n        elif sys.version_info >= (3, 12):\n            def __new__(cls, name: str) -> Self: ...\n        else:\n            def __init__(self, name: str) -> None: ...\n\n        def __iter__(self) -> Any: ...\n        def __typing_subst__(self, arg: Never, /) -> Never: ...\n        def __typing_prepare_subst__(self, alias: Any, args: Any, /) -> tuple[Any, ...]: ...\n        if sys.version_info >= (3, 14):\n            @property\n            def evaluate_default(self) -> EvaluateFunc | None: ...\n\nif sys.version_info >= (3, 10):\n    @final\n    class ParamSpecArgs:\n        @property\n        def __origin__(self) -> ParamSpec: ...\n        if sys.version_info >= (3, 12):\n            def __new__(cls, origin: ParamSpec) -> Self: ...\n        else:\n            def __init__(self, origin: ParamSpec) -> None: ...\n\n        def __eq__(self, other: object, /) -> bool: ...\n        __hash__: ClassVar[None]  # type: ignore[assignment]\n\n    @final\n    class ParamSpecKwargs:\n        @property\n        def __origin__(self) -> ParamSpec: ...\n        if sys.version_info >= (3, 12):\n            def __new__(cls, origin: ParamSpec) -> Self: ...\n        else:\n            def __init__(self, origin: ParamSpec) -> None: ...\n\n        def __eq__(self, other: object, /) -> bool: ...\n        __hash__: ClassVar[None]  # type: ignore[assignment]\n\n    @final\n    class ParamSpec:\n        @property\n        def __name__(self) -> str: ...\n        @property\n        def __bound__(self) -> Any | None: ...  # AnnotationForm\n        @property\n        def __covariant__(self) -> bool: ...\n        @property\n        def __contravariant__(self) -> bool: ...\n        if sys.version_info >= (3, 12):\n            @property\n            def __infer_variance__(self) -> bool: ...\n        if sys.version_info >= (3, 13):\n            @property\n            def __default__(self) -> Any: ...  # AnnotationForm\n        if sys.version_info >= (3, 13):\n            def __new__(\n                cls,\n                name: str,\n                *,\n                bound: Any | None = None,  # AnnotationForm\n                contravariant: bool = False,\n                covariant: bool = False,\n                infer_variance: bool = False,\n                default: Any = ...,  # AnnotationForm\n            ) -> Self: ...\n        elif sys.version_info >= (3, 12):\n            def __new__(\n                cls,\n                name: str,\n                *,\n                bound: Any | None = None,  # AnnotationForm\n                contravariant: bool = False,\n                covariant: bool = False,\n                infer_variance: bool = False,\n            ) -> Self: ...\n        elif sys.version_info >= (3, 11):\n            def __new__(\n                cls,\n                name: str,\n                *,\n                bound: Any | None = None,  # AnnotationForm\n                contravariant: bool = False,\n                covariant: bool = False,\n            ) -> Self: ...\n        else:\n            def __init__(\n                self,\n                name: str,\n                *,\n                bound: Any | None = None,  # AnnotationForm\n                contravariant: bool = False,\n                covariant: bool = False,\n            ) -> None: ...\n\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n        if sys.version_info >= (3, 11):\n            def __typing_subst__(self, arg: Any, /) -> Any: ...\n            def __typing_prepare_subst__(self, alias: Any, args: Any, /) -> tuple[Any, ...]: ...\n\n        def __or__(self, right: Any, /) -> _SpecialForm: ...\n        def __ror__(self, left: Any, /) -> _SpecialForm: ...\n        if sys.version_info >= (3, 13):\n            def has_default(self) -> bool: ...\n        if sys.version_info >= (3, 14):\n            @property\n            def evaluate_default(self) -> EvaluateFunc | None: ...\n\n    Concatenate: _SpecialForm\n    TypeAlias: _SpecialForm\n    TypeGuard: _SpecialForm\n\n    class NewType:\n        def __init__(self, name: str, tp: Any) -> None: ...  # AnnotationForm\n        if sys.version_info >= (3, 11):\n            @staticmethod\n            def __call__(x: _T, /) -> _T: ...\n        else:\n            def __call__(self, x: _T) -> _T: ...\n\n        def __or__(self, other: Any) -> _SpecialForm: ...\n        def __ror__(self, other: Any) -> _SpecialForm: ...\n        __supertype__: type | NewType\n        __name__: str\n\nelse:\n    def NewType(name: str, tp: Any) -> Any: ...\n\n_F = TypeVar(\"_F\", bound=Callable[..., Any])\n_P = _ParamSpec(\"_P\")\n_T = TypeVar(\"_T\")\n\n_FT = TypeVar(\"_FT\", bound=Callable[..., Any] | type)\n\n# These type variables are used by the container types.\n_S = TypeVar(\"_S\")\n_KT = TypeVar(\"_KT\")  # Key type.\n_VT = TypeVar(\"_VT\")  # Value type.\n_T_co = TypeVar(\"_T_co\", covariant=True)  # Any type covariant containers.\n_KT_co = TypeVar(\"_KT_co\", covariant=True)  # Key type covariant containers.\n_VT_co = TypeVar(\"_VT_co\", covariant=True)  # Value type covariant containers.\n_TC = TypeVar(\"_TC\", bound=type[object])\n\ndef overload(func: _F) -> _F: ...\ndef no_type_check(arg: _F) -> _F: ...\n\nif sys.version_info >= (3, 13):\n    @deprecated(\"Deprecated since Python 3.13; removed in Python 3.15.\")\n    def no_type_check_decorator(decorator: Callable[_P, _T]) -> Callable[_P, _T]: ...\n\nelse:\n    def no_type_check_decorator(decorator: Callable[_P, _T]) -> Callable[_P, _T]: ...\n\n# This itself is only available during type checking\ndef type_check_only(func_or_cls: _FT) -> _FT: ...\n\n# Type aliases and type constructors\n\n@type_check_only\nclass _Alias:\n    # Class for defining generic aliases for library types.\n    def __getitem__(self, typeargs: Any) -> Any: ...\n\nList = _Alias()\nDict = _Alias()\nDefaultDict = _Alias()\nSet = _Alias()\nFrozenSet = _Alias()\nCounter = _Alias()\nDeque = _Alias()\nChainMap = _Alias()\n\nOrderedDict = _Alias()\n\nAnnotated: _SpecialForm\n\n# Predefined type variables.\nAnyStr = TypeVar(\"AnyStr\", str, bytes)  # noqa: Y001\n\n@type_check_only\nclass _Generic:\n    if sys.version_info < (3, 12):\n        __slots__ = ()\n\n    if sys.version_info >= (3, 10):\n        @classmethod\n        def __class_getitem__(cls, args: TypeVar | ParamSpec | tuple[TypeVar | ParamSpec, ...]) -> _Final: ...\n    else:\n        @classmethod\n        def __class_getitem__(cls, args: TypeVar | tuple[TypeVar, ...]) -> _Final: ...\n\nGeneric: type[_Generic]\n\nclass _ProtocolMeta(ABCMeta):\n    if sys.version_info >= (3, 12):\n        def __init__(cls, *args: Any, **kwargs: Any) -> None: ...\n\n# Abstract base classes.\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n@runtime_checkable\nclass SupportsInt(Protocol, metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def __int__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsFloat(Protocol, metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def __float__(self) -> float: ...\n\n@runtime_checkable\nclass SupportsComplex(Protocol, metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def __complex__(self) -> complex: ...\n\n@runtime_checkable\nclass SupportsBytes(Protocol, metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def __bytes__(self) -> bytes: ...\n\n@runtime_checkable\nclass SupportsIndex(Protocol, metaclass=ABCMeta):\n    __slots__ = ()\n    @abstractmethod\n    def __index__(self) -> int: ...\n\n@runtime_checkable\nclass SupportsAbs(Protocol[_T_co]):\n    __slots__ = ()\n    @abstractmethod\n    def __abs__(self) -> _T_co: ...\n\n@runtime_checkable\nclass SupportsRound(Protocol[_T_co]):\n    __slots__ = ()\n    @overload\n    @abstractmethod\n    def __round__(self) -> int: ...\n    @overload\n    @abstractmethod\n    def __round__(self, ndigits: int, /) -> _T_co: ...\n\n@runtime_checkable\nclass Sized(Protocol, metaclass=ABCMeta):\n    @abstractmethod\n    def __len__(self) -> int: ...\n\n@runtime_checkable\nclass Hashable(Protocol, metaclass=ABCMeta):\n    # TODO: This is special, in that a subclass of a hashable class may not be hashable\n    #   (for example, list vs. object). It's not obvious how to represent this. This class\n    #   is currently mostly useless for static checking.\n    @abstractmethod\n    def __hash__(self) -> int: ...\n\n@runtime_checkable\nclass Iterable(Protocol[_T_co]):\n    @abstractmethod\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Iterator(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __next__(self) -> _T_co: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n\n@runtime_checkable\nclass Reversible(Iterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\n_YieldT_co = TypeVar(\"_YieldT_co\", covariant=True)\n_SendT_contra = TypeVar(\"_SendT_contra\", contravariant=True, default=None)\n_ReturnT_co = TypeVar(\"_ReturnT_co\", covariant=True, default=None)\n\n@runtime_checkable\nclass Generator(Iterator[_YieldT_co], Protocol[_YieldT_co, _SendT_contra, _ReturnT_co]):\n    def __next__(self) -> _YieldT_co: ...\n    @abstractmethod\n    def send(self, value: _SendT_contra, /) -> _YieldT_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, typ: type[BaseException], val: BaseException | object = None, tb: TracebackType | None = None, /\n    ) -> _YieldT_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, typ: BaseException, val: None = None, tb: TracebackType | None = None, /) -> _YieldT_co: ...\n    if sys.version_info >= (3, 13):\n        def close(self) -> _ReturnT_co | None: ...\n    else:\n        def close(self) -> None: ...\n\n    def __iter__(self) -> Generator[_YieldT_co, _SendT_contra, _ReturnT_co]: ...\n\n# NOTE: Prior to Python 3.13 these aliases are lacking the second _ExitT_co parameter\nif sys.version_info >= (3, 13):\n    from contextlib import AbstractAsyncContextManager as AsyncContextManager, AbstractContextManager as ContextManager\nelse:\n    from contextlib import AbstractAsyncContextManager, AbstractContextManager\n\n    @runtime_checkable\n    class ContextManager(AbstractContextManager[_T_co, bool | None], Protocol[_T_co]): ...\n\n    @runtime_checkable\n    class AsyncContextManager(AbstractAsyncContextManager[_T_co, bool | None], Protocol[_T_co]): ...\n\n@runtime_checkable\nclass Awaitable(Protocol[_T_co]):\n    @abstractmethod\n    def __await__(self) -> Generator[Any, Any, _T_co]: ...\n\n# Non-default variations to accommodate coroutines, and `AwaitableGenerator` having a 4th type parameter.\n_SendT_nd_contra = TypeVar(\"_SendT_nd_contra\", contravariant=True)\n_ReturnT_nd_co = TypeVar(\"_ReturnT_nd_co\", covariant=True)\n\nclass Coroutine(Awaitable[_ReturnT_nd_co], Generic[_YieldT_co, _SendT_nd_contra, _ReturnT_nd_co]):\n    __name__: str\n    __qualname__: str\n\n    @abstractmethod\n    def send(self, value: _SendT_nd_contra, /) -> _YieldT_co: ...\n    @overload\n    @abstractmethod\n    def throw(\n        self, typ: type[BaseException], val: BaseException | object = None, tb: TracebackType | None = None, /\n    ) -> _YieldT_co: ...\n    @overload\n    @abstractmethod\n    def throw(self, typ: BaseException, val: None = None, tb: TracebackType | None = None, /) -> _YieldT_co: ...\n    @abstractmethod\n    def close(self) -> None: ...\n\n# NOTE: This type does not exist in typing.py or PEP 484 but mypy needs it to exist.\n# The parameters correspond to Generator, but the 4th is the original type.\n# Obsolete, use _typeshed._type_checker_internals.AwaitableGenerator instead.\n@type_check_only\nclass AwaitableGenerator(\n    Awaitable[_ReturnT_nd_co],\n    Generator[_YieldT_co, _SendT_nd_contra, _ReturnT_nd_co],\n    Generic[_YieldT_co, _SendT_nd_contra, _ReturnT_nd_co, _S],\n    metaclass=ABCMeta,\n): ...\n\n@runtime_checkable\nclass AsyncIterable(Protocol[_T_co]):\n    @abstractmethod\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\n@runtime_checkable\nclass AsyncIterator(AsyncIterable[_T_co], Protocol[_T_co]):\n    @abstractmethod\n    def __anext__(self) -> Awaitable[_T_co]: ...\n    def __aiter__(self) -> AsyncIterator[_T_co]: ...\n\n@runtime_checkable\nclass AsyncGenerator(AsyncIterator[_YieldT_co], Protocol[_YieldT_co, _SendT_contra]):\n    def __anext__(self) -> Coroutine[Any, Any, _YieldT_co]: ...\n    @abstractmethod\n    def asend(self, value: _SendT_contra, /) -> Coroutine[Any, Any, _YieldT_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(\n        self, typ: type[BaseException], val: BaseException | object = None, tb: TracebackType | None = None, /\n    ) -> Coroutine[Any, Any, _YieldT_co]: ...\n    @overload\n    @abstractmethod\n    def athrow(\n        self, typ: BaseException, val: None = None, tb: TracebackType | None = None, /\n    ) -> Coroutine[Any, Any, _YieldT_co]: ...\n    def aclose(self) -> Coroutine[Any, Any, None]: ...\n\n@runtime_checkable\nclass Container(Protocol[_T_co]):\n    # This is generic more on vibes than anything else\n    @abstractmethod\n    def __contains__(self, x: object, /) -> bool: ...\n\n@runtime_checkable\nclass Collection(Iterable[_T_co], Container[_T_co], Protocol[_T_co]):\n    # Implement Sized (but don't have it as a base class).\n    @abstractmethod\n    def __len__(self) -> int: ...\n\nclass Sequence(Reversible[_T_co], Collection[_T_co]):\n    @overload\n    @abstractmethod\n    def __getitem__(self, index: int) -> _T_co: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, index: slice) -> Sequence[_T_co]: ...\n    # Mixin methods\n    def index(self, value: Any, start: int = 0, stop: int = ...) -> int: ...\n    def count(self, value: Any) -> int: ...\n    def __contains__(self, value: object) -> bool: ...\n    def __iter__(self) -> Iterator[_T_co]: ...\n    def __reversed__(self) -> Iterator[_T_co]: ...\n\nclass MutableSequence(Sequence[_T]):\n    @abstractmethod\n    def insert(self, index: int, value: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, index: int) -> _T: ...\n    @overload\n    @abstractmethod\n    def __getitem__(self, index: slice) -> MutableSequence[_T]: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, index: int, value: _T) -> None: ...\n    @overload\n    @abstractmethod\n    def __setitem__(self, index: slice, value: Iterable[_T]) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, index: int) -> None: ...\n    @overload\n    @abstractmethod\n    def __delitem__(self, index: slice) -> None: ...\n    # Mixin methods\n    def append(self, value: _T) -> None: ...\n    def clear(self) -> None: ...\n    def extend(self, values: Iterable[_T]) -> None: ...\n    def reverse(self) -> None: ...\n    def pop(self, index: int = -1) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __iadd__(self, values: Iterable[_T]) -> typing_extensions.Self: ...\n\nclass AbstractSet(Collection[_T_co]):\n    @abstractmethod\n    def __contains__(self, x: object) -> bool: ...\n    def _hash(self) -> int: ...\n    # Mixin methods\n    def __le__(self, other: AbstractSet[Any]) -> bool: ...\n    def __lt__(self, other: AbstractSet[Any]) -> bool: ...\n    def __gt__(self, other: AbstractSet[Any]) -> bool: ...\n    def __ge__(self, other: AbstractSet[Any]) -> bool: ...\n    def __and__(self, other: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __or__(self, other: AbstractSet[_T]) -> AbstractSet[_T_co | _T]: ...\n    def __sub__(self, other: AbstractSet[Any]) -> AbstractSet[_T_co]: ...\n    def __xor__(self, other: AbstractSet[_T]) -> AbstractSet[_T_co | _T]: ...\n    def __eq__(self, other: object) -> bool: ...\n    def isdisjoint(self, other: Iterable[Any]) -> bool: ...\n\nclass MutableSet(AbstractSet[_T]):\n    @abstractmethod\n    def add(self, value: _T) -> None: ...\n    @abstractmethod\n    def discard(self, value: _T) -> None: ...\n    # Mixin methods\n    def clear(self) -> None: ...\n    def pop(self) -> _T: ...\n    def remove(self, value: _T) -> None: ...\n    def __ior__(self, it: AbstractSet[_T]) -> typing_extensions.Self: ...  # type: ignore[override,misc]\n    def __iand__(self, it: AbstractSet[Any]) -> typing_extensions.Self: ...\n    def __ixor__(self, it: AbstractSet[_T]) -> typing_extensions.Self: ...  # type: ignore[override,misc]\n    def __isub__(self, it: AbstractSet[Any]) -> typing_extensions.Self: ...\n\nclass MappingView(Sized):\n    __slots__ = (\"_mapping\",)\n    def __init__(self, mapping: Sized) -> None: ...  # undocumented\n    def __len__(self) -> int: ...\n\nclass ItemsView(MappingView, AbstractSet[tuple[_KT_co, _VT_co]], Generic[_KT_co, _VT_co]):\n    def __init__(self, mapping: SupportsGetItemViewable[_KT_co, _VT_co]) -> None: ...  # undocumented\n    def __and__(self, other: Iterable[Any]) -> set[tuple[_KT_co, _VT_co]]: ...\n    def __rand__(self, other: Iterable[_T]) -> set[_T]: ...\n    def __contains__(self, item: tuple[object, object]) -> bool: ...  # type: ignore[override]\n    def __iter__(self) -> Iterator[tuple[_KT_co, _VT_co]]: ...\n    def __or__(self, other: Iterable[_T]) -> set[tuple[_KT_co, _VT_co] | _T]: ...\n    def __ror__(self, other: Iterable[_T]) -> set[tuple[_KT_co, _VT_co] | _T]: ...\n    def __sub__(self, other: Iterable[Any]) -> set[tuple[_KT_co, _VT_co]]: ...\n    def __rsub__(self, other: Iterable[_T]) -> set[_T]: ...\n    def __xor__(self, other: Iterable[_T]) -> set[tuple[_KT_co, _VT_co] | _T]: ...\n    def __rxor__(self, other: Iterable[_T]) -> set[tuple[_KT_co, _VT_co] | _T]: ...\n\nclass KeysView(MappingView, AbstractSet[_KT_co]):\n    def __init__(self, mapping: Viewable[_KT_co]) -> None: ...  # undocumented\n    def __and__(self, other: Iterable[Any]) -> set[_KT_co]: ...\n    def __rand__(self, other: Iterable[_T]) -> set[_T]: ...\n    def __contains__(self, key: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT_co]: ...\n    def __or__(self, other: Iterable[_T]) -> set[_KT_co | _T]: ...\n    def __ror__(self, other: Iterable[_T]) -> set[_KT_co | _T]: ...\n    def __sub__(self, other: Iterable[Any]) -> set[_KT_co]: ...\n    def __rsub__(self, other: Iterable[_T]) -> set[_T]: ...\n    def __xor__(self, other: Iterable[_T]) -> set[_KT_co | _T]: ...\n    def __rxor__(self, other: Iterable[_T]) -> set[_KT_co | _T]: ...\n\nclass ValuesView(MappingView, Collection[_VT_co]):\n    def __init__(self, mapping: SupportsGetItemViewable[Any, _VT_co]) -> None: ...  # undocumented\n    def __contains__(self, value: object) -> bool: ...\n    def __iter__(self) -> Iterator[_VT_co]: ...\n\n# note for Mapping.get and MutableMapping.pop and MutableMapping.setdefault\n# In _collections_abc.py the parameters are positional-or-keyword,\n# but dict and types.MappingProxyType (the vast majority of Mapping types)\n# don't allow keyword arguments.\n\nclass Mapping(Collection[_KT], Generic[_KT, _VT_co]):\n    # TODO: We wish the key type could also be covariant, but that doesn't work,\n    # see discussion in https://github.com/python/typing/pull/273.\n    @abstractmethod\n    def __getitem__(self, key: _KT, /) -> _VT_co: ...\n    # Mixin methods\n    @overload\n    def get(self, key: _KT, /) -> _VT_co | None: ...\n    @overload\n    def get(self, key: _KT, default: _VT_co, /) -> _VT_co: ...  # type: ignore[misc] # pyright: ignore[reportGeneralTypeIssues] # Covariant type as parameter\n    @overload\n    def get(self, key: _KT, default: _T, /) -> _VT_co | _T: ...\n    def items(self) -> ItemsView[_KT, _VT_co]: ...\n    def keys(self) -> KeysView[_KT]: ...\n    def values(self) -> ValuesView[_VT_co]: ...\n    def __contains__(self, key: object, /) -> bool: ...\n    def __eq__(self, other: object, /) -> bool: ...\n\nclass MutableMapping(Mapping[_KT, _VT]):\n    @abstractmethod\n    def __setitem__(self, key: _KT, value: _VT, /) -> None: ...\n    @abstractmethod\n    def __delitem__(self, key: _KT, /) -> None: ...\n    def clear(self) -> None: ...\n    @overload\n    def pop(self, key: _KT, /) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _VT, /) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _T, /) -> _VT | _T: ...\n    def popitem(self) -> tuple[_KT, _VT]: ...\n    # This overload should be allowed only if the value type is compatible with None.\n    #\n    # Keep the following methods in line with MutableMapping.setdefault, modulo positional-only differences:\n    # -- collections.OrderedDict.setdefault\n    # -- collections.ChainMap.setdefault\n    # -- weakref.WeakKeyDictionary.setdefault\n    @overload\n    def setdefault(self: MutableMapping[_KT, _T | None], key: _KT, default: None = None, /) -> _T | None: ...\n    @overload\n    def setdefault(self, key: _KT, default: _VT, /) -> _VT: ...\n    # 'update' used to take a Union, but using overloading is better.\n    # The second overloaded type here is a bit too general, because\n    # Mapping[tuple[_KT, _VT], W] is a subclass of Iterable[tuple[_KT, _VT]],\n    # but will always have the behavior of the first overloaded type\n    # at runtime, leading to keys of a mix of types _KT and tuple[_KT, _VT].\n    # We don't currently have any way of forcing all Mappings to use\n    # the first overload, but by using overloading rather than a Union,\n    # mypy will commit to using the first overload when the argument is\n    # known to be a Mapping with unknown type parameters, which is closer\n    # to the behavior we want. See mypy issue  #1430.\n    #\n    # Various mapping classes have __ior__ methods that should be kept roughly in line with .update():\n    # -- dict.__ior__\n    # -- os._Environ.__ior__\n    # -- collections.UserDict.__ior__\n    # -- collections.ChainMap.__ior__\n    # -- peewee.attrdict.__add__\n    # -- peewee.attrdict.__iadd__\n    # -- weakref.WeakValueDictionary.__ior__\n    # -- weakref.WeakKeyDictionary.__ior__\n    @overload\n    def update(self, m: SupportsKeysAndGetItem[_KT, _VT], /) -> None: ...\n    @overload\n    def update(self: SupportsGetItem[str, _VT], m: SupportsKeysAndGetItem[str, _VT], /, **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, m: Iterable[tuple[_KT, _VT]], /) -> None: ...\n    @overload\n    def update(self: SupportsGetItem[str, _VT], m: Iterable[tuple[str, _VT]], /, **kwargs: _VT) -> None: ...\n    @overload\n    def update(self: SupportsGetItem[str, _VT], **kwargs: _VT) -> None: ...\n\nText = str\n\nTYPE_CHECKING: Final[bool]\n\n# In stubs, the arguments of the IO class are marked as positional-only.\n# This differs from runtime, but better reflects the fact that in reality\n# classes deriving from IO use different names for the arguments.\nclass IO(Generic[AnyStr]):\n    # At runtime these are all abstract properties,\n    # but making them abstract in the stub is hugely disruptive, for not much gain.\n    # See #8726\n    __slots__ = ()\n    @property\n    def mode(self) -> str: ...\n    # Usually str, but may be bytes if a bytes path was passed to open(). See #10737.\n    # If PEP 696 becomes available, we may want to use a defaulted TypeVar here.\n    @property\n    def name(self) -> str | Any: ...\n    @abstractmethod\n    def close(self) -> None: ...\n    @property\n    def closed(self) -> bool: ...\n    @abstractmethod\n    def fileno(self) -> int: ...\n    @abstractmethod\n    def flush(self) -> None: ...\n    @abstractmethod\n    def isatty(self) -> bool: ...\n    @abstractmethod\n    def read(self, n: int = -1, /) -> AnyStr: ...\n    @abstractmethod\n    def readable(self) -> bool: ...\n    @abstractmethod\n    def readline(self, limit: int = -1, /) -> AnyStr: ...\n    @abstractmethod\n    def readlines(self, hint: int = -1, /) -> list[AnyStr]: ...\n    @abstractmethod\n    def seek(self, offset: int, whence: int = 0, /) -> int: ...\n    @abstractmethod\n    def seekable(self) -> bool: ...\n    @abstractmethod\n    def tell(self) -> int: ...\n    @abstractmethod\n    def truncate(self, size: int | None = None, /) -> int: ...\n    @abstractmethod\n    def writable(self) -> bool: ...\n    @abstractmethod\n    @overload\n    def write(self: IO[bytes], s: ReadableBuffer, /) -> int: ...\n    @abstractmethod\n    @overload\n    def write(self, s: AnyStr, /) -> int: ...\n    @abstractmethod\n    @overload\n    def writelines(self: IO[bytes], lines: Iterable[ReadableBuffer], /) -> None: ...\n    @abstractmethod\n    @overload\n    def writelines(self, lines: Iterable[AnyStr], /) -> None: ...\n    @abstractmethod\n    def __next__(self) -> AnyStr: ...\n    @abstractmethod\n    def __iter__(self) -> Iterator[AnyStr]: ...\n    @abstractmethod\n    def __enter__(self) -> IO[AnyStr]: ...\n    @abstractmethod\n    def __exit__(\n        self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None, /\n    ) -> None: ...\n\nclass BinaryIO(IO[bytes]):\n    __slots__ = ()\n    @abstractmethod\n    def __enter__(self) -> BinaryIO: ...\n\nclass TextIO(IO[str]):\n    # See comment regarding the @properties in the `IO` class\n    __slots__ = ()\n    @property\n    def buffer(self) -> BinaryIO: ...\n    @property\n    def encoding(self) -> str: ...\n    @property\n    def errors(self) -> str | None: ...\n    @property\n    def line_buffering(self) -> int: ...  # int on PyPy, bool on CPython\n    @property\n    def newlines(self) -> Any: ...  # None, str or tuple\n    @abstractmethod\n    def __enter__(self) -> TextIO: ...\n\nByteString: typing_extensions.TypeAlias = bytes | bytearray | memoryview\n\n# Functions\n\n_get_type_hints_obj_allowed_types: typing_extensions.TypeAlias = (  # noqa: Y042\n    object\n    | Callable[..., Any]\n    | FunctionType\n    | BuiltinFunctionType\n    | MethodType\n    | ModuleType\n    | WrapperDescriptorType\n    | MethodWrapperType\n    | MethodDescriptorType\n)\n\nif sys.version_info >= (3, 14):\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types,\n        globalns: dict[str, Any] | None = None,\n        localns: Mapping[str, Any] | None = None,\n        include_extras: bool = False,\n        *,\n        format: Format | None = None,\n    ) -> dict[str, Any]: ...  # AnnotationForm\n\nelse:\n    def get_type_hints(\n        obj: _get_type_hints_obj_allowed_types,\n        globalns: dict[str, Any] | None = None,\n        localns: Mapping[str, Any] | None = None,\n        include_extras: bool = False,\n    ) -> dict[str, Any]: ...  # AnnotationForm\n\ndef get_args(tp: Any) -> tuple[Any, ...]: ...  # AnnotationForm\n\nif sys.version_info >= (3, 10):\n    @overload\n    def get_origin(tp: ParamSpecArgs | ParamSpecKwargs) -> ParamSpec: ...\n    @overload\n    def get_origin(tp: UnionType) -> type[UnionType]: ...\n\n@overload\ndef get_origin(tp: GenericAlias) -> type: ...\n@overload\ndef get_origin(tp: Any) -> Any | None: ...  # AnnotationForm\n@overload\ndef cast(typ: type[_T], val: Any) -> _T: ...\n@overload\ndef cast(typ: str, val: Any) -> Any: ...\n@overload\ndef cast(typ: object, val: Any) -> Any: ...\n\nif sys.version_info >= (3, 11):\n    def reveal_type(obj: _T, /) -> _T: ...\n    def assert_never(arg: Never, /) -> Never: ...\n    def assert_type(val: _T, typ: Any, /) -> _T: ...  # AnnotationForm\n    def clear_overloads() -> None: ...\n    def get_overloads(func: Callable[..., object]) -> Sequence[Callable[..., object]]: ...\n    def dataclass_transform(\n        *,\n        eq_default: bool = True,\n        order_default: bool = False,\n        kw_only_default: bool = False,\n        frozen_default: bool = False,  # on 3.11, runtime accepts it as part of kwargs\n        field_specifiers: tuple[type[Any] | Callable[..., Any], ...] = (),\n        **kwargs: Any,\n    ) -> IdentityFunction: ...\n\n# Type constructors\n\n# Obsolete, will be changed to a function. Use _typeshed._type_checker_internals.NamedTupleFallback instead.\nclass NamedTuple(tuple[Any, ...]):\n    _field_defaults: ClassVar[dict[str, Any]]\n    _fields: ClassVar[tuple[str, ...]]\n    # __orig_bases__ sometimes exists on <3.12, but not consistently\n    # So we only add it to the stub on 3.12+.\n    if sys.version_info >= (3, 12):\n        __orig_bases__: ClassVar[tuple[Any, ...]]\n\n    @overload\n    def __init__(self, typename: str, fields: Iterable[tuple[str, Any]], /) -> None: ...\n    @overload\n    @deprecated(\"Creating a typing.NamedTuple using keyword arguments is deprecated and support will be removed in Python 3.15\")\n    def __init__(self, typename: str, fields: None = None, /, **kwargs: Any) -> None: ...\n    @classmethod\n    def _make(cls, iterable: Iterable[Any]) -> typing_extensions.Self: ...\n    def _asdict(self) -> dict[str, Any]: ...\n    def _replace(self, **kwargs: Any) -> typing_extensions.Self: ...\n    if sys.version_info >= (3, 13):\n        def __replace__(self, **kwargs: Any) -> typing_extensions.Self: ...\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\n# N.B. Keep this mostly in sync with typing_extensions._TypedDict/mypy_extensions._TypedDict\n# Obsolete, use _typeshed._type_checker_internals.TypedDictFallback instead.\n@type_check_only\nclass _TypedDict(Mapping[str, object], metaclass=ABCMeta):\n    __total__: ClassVar[bool]\n    __required_keys__: ClassVar[frozenset[str]]\n    __optional_keys__: ClassVar[frozenset[str]]\n    # __orig_bases__ sometimes exists on <3.12, but not consistently,\n    # so we only add it to the stub on 3.12+\n    if sys.version_info >= (3, 12):\n        __orig_bases__: ClassVar[tuple[Any, ...]]\n    if sys.version_info >= (3, 13):\n        __readonly_keys__: ClassVar[frozenset[str]]\n        __mutable_keys__: ClassVar[frozenset[str]]\n\n    def copy(self) -> typing_extensions.Self: ...\n    # Using Never so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: _Never, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: _Never, default: _T = ...) -> object: ...  # pyright: ignore[reportInvalidTypeVarUse]\n    def update(self, m: typing_extensions.Self, /) -> None: ...\n    def __delitem__(self, k: _Never) -> None: ...\n    def items(self) -> dict_items[str, object]: ...\n    def keys(self) -> dict_keys[str, object]: ...\n    def values(self) -> dict_values[str, object]: ...\n    @overload\n    def __or__(self, value: typing_extensions.Self, /) -> typing_extensions.Self: ...\n    @overload\n    def __or__(self, value: dict[str, Any], /) -> dict[str, object]: ...\n    @overload\n    def __ror__(self, value: typing_extensions.Self, /) -> typing_extensions.Self: ...\n    @overload\n    def __ror__(self, value: dict[str, Any], /) -> dict[str, object]: ...\n    # supposedly incompatible definitions of __or__ and __ior__\n    def __ior__(self, value: typing_extensions.Self, /) -> typing_extensions.Self: ...  # type: ignore[misc]\n\nif sys.version_info >= (3, 14):\n    from annotationlib import ForwardRef as ForwardRef\n\n    def evaluate_forward_ref(\n        forward_ref: ForwardRef,\n        *,\n        owner: object = None,\n        globals: dict[str, Any] | None = None,\n        locals: Mapping[str, Any] | None = None,\n        type_params: tuple[TypeVar, ParamSpec, TypeVarTuple] | None = None,\n        format: Format | None = None,\n    ) -> Any: ...  # AnnotationForm\n\nelse:\n    @final\n    class ForwardRef(_Final):\n        __slots__ = (\n            \"__forward_arg__\",\n            \"__forward_code__\",\n            \"__forward_evaluated__\",\n            \"__forward_value__\",\n            \"__forward_is_argument__\",\n            \"__forward_is_class__\",\n            \"__forward_module__\",\n        )\n        __forward_arg__: str\n        __forward_code__: CodeType\n        __forward_evaluated__: bool\n        __forward_value__: Any | None  # AnnotationForm\n        __forward_is_argument__: bool\n        __forward_is_class__: bool\n        __forward_module__: Any | None\n\n        def __init__(self, arg: str, is_argument: bool = True, module: Any | None = None, *, is_class: bool = False) -> None: ...\n\n        if sys.version_info >= (3, 13):\n            @overload\n            @deprecated(\n                \"Failing to pass a value to the 'type_params' parameter of ForwardRef._evaluate() is deprecated, \"\n                \"as it leads to incorrect behaviour when evaluating a stringified annotation \"\n                \"that references a PEP 695 type parameter. It will be disallowed in Python 3.15.\"\n            )\n            def _evaluate(\n                self, globalns: dict[str, Any] | None, localns: Mapping[str, Any] | None, *, recursive_guard: frozenset[str]\n            ) -> Any | None: ...  # AnnotationForm\n            @overload\n            def _evaluate(\n                self,\n                globalns: dict[str, Any] | None,\n                localns: Mapping[str, Any] | None,\n                type_params: tuple[TypeVar | ParamSpec | TypeVarTuple, ...],\n                *,\n                recursive_guard: frozenset[str],\n            ) -> Any | None: ...  # AnnotationForm\n        elif sys.version_info >= (3, 12):\n            def _evaluate(\n                self,\n                globalns: dict[str, Any] | None,\n                localns: Mapping[str, Any] | None,\n                type_params: tuple[TypeVar | ParamSpec | TypeVarTuple, ...] | None = None,\n                *,\n                recursive_guard: frozenset[str],\n            ) -> Any | None: ...  # AnnotationForm\n        else:\n            def _evaluate(\n                self, globalns: dict[str, Any] | None, localns: Mapping[str, Any] | None, recursive_guard: frozenset[str]\n            ) -> Any | None: ...  # AnnotationForm\n\n        def __eq__(self, other: object) -> bool: ...\n        def __hash__(self) -> int: ...\n        if sys.version_info >= (3, 11):\n            def __or__(self, other: Any) -> _SpecialForm: ...\n            def __ror__(self, other: Any) -> _SpecialForm: ...\n\nif sys.version_info >= (3, 10):\n    def is_typeddict(tp: object) -> bool: ...\n\ndef _type_repr(obj: object) -> str: ...\n\nif sys.version_info >= (3, 12):\n    _TypeParameter: typing_extensions.TypeAlias = (\n        TypeVar\n        | typing_extensions.TypeVar\n        | ParamSpec\n        | typing_extensions.ParamSpec\n        | TypeVarTuple\n        | typing_extensions.TypeVarTuple\n    )\n\n    def override(method: _F, /) -> _F: ...\n    @final\n    class TypeAliasType:\n        def __new__(cls, name: str, value: Any, *, type_params: tuple[_TypeParameter, ...] = ()) -> Self: ...\n        @property\n        def __value__(self) -> Any: ...  # AnnotationForm\n        @property\n        def __type_params__(self) -> tuple[_TypeParameter, ...]: ...\n        @property\n        def __parameters__(self) -> tuple[Any, ...]: ...  # AnnotationForm\n        @property\n        def __name__(self) -> str: ...\n        # It's writable on types, but not on instances of TypeAliasType.\n        @property\n        def __module__(self) -> str | None: ...  # type: ignore[override]\n        def __getitem__(self, parameters: Any, /) -> GenericAlias: ...  # AnnotationForm\n        def __or__(self, right: Any, /) -> _SpecialForm: ...\n        def __ror__(self, left: Any, /) -> _SpecialForm: ...\n        if sys.version_info >= (3, 14):\n            @property\n            def evaluate_value(self) -> EvaluateFunc: ...\n\nif sys.version_info >= (3, 13):\n    def is_protocol(tp: type, /) -> bool: ...\n    def get_protocol_members(tp: type, /) -> frozenset[str]: ...\n    @final\n    @type_check_only\n    class _NoDefaultType: ...\n\n    NoDefault: _NoDefaultType\n    TypeIs: _SpecialForm\n    ReadOnly: _SpecialForm\n",
  "/typeshed/stdlib/typing_extensions.pyi": "import abc\nimport enum\nimport sys\nfrom _collections_abc import dict_items, dict_keys, dict_values\nfrom _typeshed import AnnotationForm, IdentityFunction, Incomplete, Unused\nfrom collections.abc import (\n    AsyncGenerator as AsyncGenerator,\n    AsyncIterable as AsyncIterable,\n    AsyncIterator as AsyncIterator,\n    Awaitable as Awaitable,\n    Collection as Collection,\n    Container as Container,\n    Coroutine as Coroutine,\n    Generator as Generator,\n    Hashable as Hashable,\n    ItemsView as ItemsView,\n    Iterable as Iterable,\n    Iterator as Iterator,\n    KeysView as KeysView,\n    Mapping as Mapping,\n    MappingView as MappingView,\n    MutableMapping as MutableMapping,\n    MutableSequence as MutableSequence,\n    MutableSet as MutableSet,\n    Reversible as Reversible,\n    Sequence as Sequence,\n    Sized as Sized,\n    ValuesView as ValuesView,\n)\nfrom contextlib import AbstractAsyncContextManager as AsyncContextManager, AbstractContextManager as ContextManager\nfrom re import Match as Match, Pattern as Pattern\nfrom types import GenericAlias, ModuleType\nfrom typing import (  # noqa: Y022,Y037,Y038,Y039,UP035\n    IO as IO,\n    TYPE_CHECKING as TYPE_CHECKING,\n    AbstractSet as AbstractSet,\n    Any as Any,\n    AnyStr as AnyStr,\n    BinaryIO as BinaryIO,\n    Callable as Callable,\n    ChainMap as ChainMap,\n    ClassVar as ClassVar,\n    Counter as Counter,\n    DefaultDict as DefaultDict,\n    Deque as Deque,\n    Dict as Dict,\n    ForwardRef as ForwardRef,\n    FrozenSet as FrozenSet,\n    Generic as Generic,\n    List as List,\n    NoReturn as NoReturn,\n    Optional as Optional,\n    Set as Set,\n    Text as Text,\n    TextIO as TextIO,\n    Tuple as Tuple,\n    Type as Type,\n    TypedDict as TypedDict,\n    TypeVar as _TypeVar,\n    Union as Union,\n    _Alias,\n    _SpecialForm,\n    cast as cast,\n    no_type_check as no_type_check,\n    no_type_check_decorator as no_type_check_decorator,\n    overload as overload,\n    type_check_only,\n)\n\nif sys.version_info >= (3, 10):\n    from types import UnionType\n\n# Please keep order the same as at runtime.\n__all__ = [\n    # Super-special typing primitives.\n    \"Any\",\n    \"ClassVar\",\n    \"Concatenate\",\n    \"Final\",\n    \"LiteralString\",\n    \"ParamSpec\",\n    \"ParamSpecArgs\",\n    \"ParamSpecKwargs\",\n    \"Self\",\n    \"Type\",\n    \"TypeVar\",\n    \"TypeVarTuple\",\n    \"Unpack\",\n    # ABCs (from collections.abc).\n    \"Awaitable\",\n    \"AsyncIterator\",\n    \"AsyncIterable\",\n    \"Coroutine\",\n    \"AsyncGenerator\",\n    \"AsyncContextManager\",\n    \"Buffer\",\n    \"ChainMap\",\n    # Concrete collection types.\n    \"ContextManager\",\n    \"Counter\",\n    \"Deque\",\n    \"DefaultDict\",\n    \"NamedTuple\",\n    \"OrderedDict\",\n    \"TypedDict\",\n    # Structural checks, a.k.a. protocols.\n    \"SupportsAbs\",\n    \"SupportsBytes\",\n    \"SupportsComplex\",\n    \"SupportsFloat\",\n    \"SupportsIndex\",\n    \"SupportsInt\",\n    \"SupportsRound\",\n    \"Reader\",\n    \"Writer\",\n    # One-off things.\n    \"Annotated\",\n    \"assert_never\",\n    \"assert_type\",\n    \"clear_overloads\",\n    \"dataclass_transform\",\n    \"deprecated\",\n    \"disjoint_base\",\n    \"Doc\",\n    \"evaluate_forward_ref\",\n    \"get_overloads\",\n    \"final\",\n    \"Format\",\n    \"get_annotations\",\n    \"get_args\",\n    \"get_origin\",\n    \"get_original_bases\",\n    \"get_protocol_members\",\n    \"get_type_hints\",\n    \"IntVar\",\n    \"is_protocol\",\n    \"is_typeddict\",\n    \"Literal\",\n    \"NewType\",\n    \"overload\",\n    \"override\",\n    \"Protocol\",\n    \"Sentinel\",\n    \"reveal_type\",\n    \"runtime\",\n    \"runtime_checkable\",\n    \"Text\",\n    \"TypeAlias\",\n    \"TypeAliasType\",\n    \"TypeForm\",\n    \"TypeGuard\",\n    \"TypeIs\",\n    \"TYPE_CHECKING\",\n    \"type_repr\",\n    \"Never\",\n    \"NoReturn\",\n    \"ReadOnly\",\n    \"Required\",\n    \"NotRequired\",\n    \"NoDefault\",\n    \"NoExtraItems\",\n    # Pure aliases, have always been in typing\n    \"AbstractSet\",\n    \"AnyStr\",\n    \"BinaryIO\",\n    \"Callable\",\n    \"Collection\",\n    \"Container\",\n    \"Dict\",\n    \"ForwardRef\",\n    \"FrozenSet\",\n    \"Generator\",\n    \"Generic\",\n    \"Hashable\",\n    \"IO\",\n    \"ItemsView\",\n    \"Iterable\",\n    \"Iterator\",\n    \"KeysView\",\n    \"List\",\n    \"Mapping\",\n    \"MappingView\",\n    \"Match\",\n    \"MutableMapping\",\n    \"MutableSequence\",\n    \"MutableSet\",\n    \"Optional\",\n    \"Pattern\",\n    \"Reversible\",\n    \"Sequence\",\n    \"Set\",\n    \"Sized\",\n    \"TextIO\",\n    \"Tuple\",\n    \"Union\",\n    \"ValuesView\",\n    \"cast\",\n    \"no_type_check\",\n    \"no_type_check_decorator\",\n    # Added dynamically\n    \"CapsuleType\",\n]\n\n_T = _TypeVar(\"_T\")\n_F = _TypeVar(\"_F\", bound=Callable[..., Any])\n_TC = _TypeVar(\"_TC\", bound=type[object])\n_T_co = _TypeVar(\"_T_co\", covariant=True)  # Any type covariant containers.\n_T_contra = _TypeVar(\"_T_contra\", contravariant=True)\n\n# Do not import (and re-export) Protocol or runtime_checkable from\n# typing module because type checkers need to be able to distinguish\n# typing.Protocol and typing_extensions.Protocol so they can properly\n# warn users about potential runtime exceptions when using typing.Protocol\n# on older versions of Python.\nProtocol: _SpecialForm\n\ndef runtime_checkable(cls: _TC) -> _TC: ...\n\n# This alias for above is kept here for backwards compatibility.\nruntime = runtime_checkable\nFinal: _SpecialForm\n\ndef final(f: _F) -> _F: ...\ndef disjoint_base(cls: _TC) -> _TC: ...\n\nLiteral: _SpecialForm\n\ndef IntVar(name: str) -> Any: ...  # returns a new TypeVar\n\n# Internal mypy fallback type for all typed dicts (does not exist at runtime)\n# N.B. Keep this mostly in sync with typing._TypedDict/mypy_extensions._TypedDict\n@type_check_only\nclass _TypedDict(Mapping[str, object], metaclass=abc.ABCMeta):\n    __required_keys__: ClassVar[frozenset[str]]\n    __optional_keys__: ClassVar[frozenset[str]]\n    __total__: ClassVar[bool]\n    __orig_bases__: ClassVar[tuple[Any, ...]]\n    # PEP 705\n    __readonly_keys__: ClassVar[frozenset[str]]\n    __mutable_keys__: ClassVar[frozenset[str]]\n    # PEP 728\n    __closed__: ClassVar[bool | None]\n    __extra_items__: ClassVar[AnnotationForm]\n    def copy(self) -> Self: ...\n    # Using Never so that only calls using mypy plugin hook that specialize the signature\n    # can go through.\n    def setdefault(self, k: Never, default: object) -> object: ...\n    # Mypy plugin hook for 'pop' expects that 'default' has a type variable type.\n    def pop(self, k: Never, default: _T = ...) -> object: ...  # pyright: ignore[reportInvalidTypeVarUse]\n    def update(self, m: Self, /) -> None: ...\n    def items(self) -> dict_items[str, object]: ...\n    def keys(self) -> dict_keys[str, object]: ...\n    def values(self) -> dict_values[str, object]: ...\n    def __delitem__(self, k: Never) -> None: ...\n    @overload\n    def __or__(self, value: Self, /) -> Self: ...\n    @overload\n    def __or__(self, value: dict[str, Any], /) -> dict[str, object]: ...\n    @overload\n    def __ror__(self, value: Self, /) -> Self: ...\n    @overload\n    def __ror__(self, value: dict[str, Any], /) -> dict[str, object]: ...\n    # supposedly incompatible definitions of `__ior__` and `__or__`:\n    # Since this module defines \"Self\" it is not recognized by Ruff as typing_extensions.Self\n    def __ior__(self, value: Self, /) -> Self: ...  # type: ignore[misc]\n\nOrderedDict = _Alias()\n\nif sys.version_info >= (3, 13):\n    from typing import get_type_hints as get_type_hints\nelse:\n    def get_type_hints(\n        obj: Any, globalns: dict[str, Any] | None = None, localns: Mapping[str, Any] | None = None, include_extras: bool = False\n    ) -> dict[str, AnnotationForm]: ...\n\ndef get_args(tp: AnnotationForm) -> tuple[AnnotationForm, ...]: ...\n\nif sys.version_info >= (3, 10):\n    @overload\n    def get_origin(tp: UnionType) -> type[UnionType]: ...\n\n@overload\ndef get_origin(tp: GenericAlias) -> type: ...\n@overload\ndef get_origin(tp: ParamSpecArgs | ParamSpecKwargs) -> ParamSpec: ...\n@overload\ndef get_origin(tp: AnnotationForm) -> AnnotationForm | None: ...\n\nAnnotated: _SpecialForm\n_AnnotatedAlias: Any  # undocumented\n\n# New and changed things in 3.10\nif sys.version_info >= (3, 10):\n    from typing import (\n        Concatenate as Concatenate,\n        ParamSpecArgs as ParamSpecArgs,\n        ParamSpecKwargs as ParamSpecKwargs,\n        TypeAlias as TypeAlias,\n        TypeGuard as TypeGuard,\n        is_typeddict as is_typeddict,\n    )\nelse:\n    @final\n    class ParamSpecArgs:\n        @property\n        def __origin__(self) -> ParamSpec: ...\n        def __init__(self, origin: ParamSpec) -> None: ...\n\n    @final\n    class ParamSpecKwargs:\n        @property\n        def __origin__(self) -> ParamSpec: ...\n        def __init__(self, origin: ParamSpec) -> None: ...\n\n    Concatenate: _SpecialForm\n    TypeAlias: _SpecialForm\n    TypeGuard: _SpecialForm\n    def is_typeddict(tp: object) -> bool: ...\n\n# New and changed things in 3.11\nif sys.version_info >= (3, 11):\n    from typing import (\n        LiteralString as LiteralString,\n        NamedTuple as NamedTuple,\n        Never as Never,\n        NewType as NewType,\n        NotRequired as NotRequired,\n        Required as Required,\n        Self as Self,\n        Unpack as Unpack,\n        assert_never as assert_never,\n        assert_type as assert_type,\n        clear_overloads as clear_overloads,\n        dataclass_transform as dataclass_transform,\n        get_overloads as get_overloads,\n        reveal_type as reveal_type,\n    )\nelse:\n    Self: _SpecialForm\n    Never: _SpecialForm\n    def reveal_type(obj: _T, /) -> _T: ...\n    def assert_never(arg: Never, /) -> Never: ...\n    def assert_type(val: _T, typ: AnnotationForm, /) -> _T: ...\n    def clear_overloads() -> None: ...\n    def get_overloads(func: Callable[..., object]) -> Sequence[Callable[..., object]]: ...\n\n    Required: _SpecialForm\n    NotRequired: _SpecialForm\n    LiteralString: _SpecialForm\n    Unpack: _SpecialForm\n\n    def dataclass_transform(\n        *,\n        eq_default: bool = True,\n        order_default: bool = False,\n        kw_only_default: bool = False,\n        frozen_default: bool = False,\n        field_specifiers: tuple[type[Any] | Callable[..., Any], ...] = (),\n        **kwargs: object,\n    ) -> IdentityFunction: ...\n\n    class NamedTuple(tuple[Any, ...]):\n        _field_defaults: ClassVar[dict[str, Any]]\n        _fields: ClassVar[tuple[str, ...]]\n        __orig_bases__: ClassVar[tuple[Any, ...]]\n        @overload\n        def __init__(self, typename: str, fields: Iterable[tuple[str, Any]] = ...) -> None: ...\n        @overload\n        def __init__(self, typename: str, fields: None = None, **kwargs: Any) -> None: ...\n        @classmethod\n        def _make(cls, iterable: Iterable[Any]) -> Self: ...\n        def _asdict(self) -> dict[str, Any]: ...\n        def _replace(self, **kwargs: Any) -> Self: ...\n\n    class NewType:\n        def __init__(self, name: str, tp: AnnotationForm) -> None: ...\n        def __call__(self, obj: _T, /) -> _T: ...\n        __supertype__: type | NewType\n        __name__: str\n        if sys.version_info >= (3, 10):\n            def __or__(self, other: Any) -> _SpecialForm: ...\n            def __ror__(self, other: Any) -> _SpecialForm: ...\n\nif sys.version_info >= (3, 12):\n    from collections.abc import Buffer as Buffer\n    from types import get_original_bases as get_original_bases\n    from typing import (\n        SupportsAbs as SupportsAbs,\n        SupportsBytes as SupportsBytes,\n        SupportsComplex as SupportsComplex,\n        SupportsFloat as SupportsFloat,\n        SupportsIndex as SupportsIndex,\n        SupportsInt as SupportsInt,\n        SupportsRound as SupportsRound,\n        override as override,\n    )\nelse:\n    def override(arg: _F, /) -> _F: ...\n    def get_original_bases(cls: type, /) -> tuple[Any, ...]: ...\n\n    # mypy and pyright object to this being both ABC and Protocol.\n    # At runtime it inherits from ABC and is not a Protocol, but it is on the\n    # allowlist for use as a Protocol.\n    @runtime_checkable\n    class Buffer(Protocol, abc.ABC):  # type: ignore[misc]  # pyright: ignore[reportGeneralTypeIssues]\n        # Not actually a Protocol at runtime; see\n        # https://github.com/python/typeshed/issues/10224 for why we're defining it this way\n        def __buffer__(self, flags: int, /) -> memoryview: ...\n\n    @runtime_checkable\n    class SupportsInt(Protocol, metaclass=abc.ABCMeta):\n        __slots__ = ()\n        @abc.abstractmethod\n        def __int__(self) -> int: ...\n\n    @runtime_checkable\n    class SupportsFloat(Protocol, metaclass=abc.ABCMeta):\n        __slots__ = ()\n        @abc.abstractmethod\n        def __float__(self) -> float: ...\n\n    @runtime_checkable\n    class SupportsComplex(Protocol, metaclass=abc.ABCMeta):\n        __slots__ = ()\n        @abc.abstractmethod\n        def __complex__(self) -> complex: ...\n\n    @runtime_checkable\n    class SupportsBytes(Protocol, metaclass=abc.ABCMeta):\n        __slots__ = ()\n        @abc.abstractmethod\n        def __bytes__(self) -> bytes: ...\n\n    @runtime_checkable\n    class SupportsIndex(Protocol, metaclass=abc.ABCMeta):\n        __slots__ = ()\n        @abc.abstractmethod\n        def __index__(self) -> int: ...\n\n    @runtime_checkable\n    class SupportsAbs(Protocol[_T_co]):\n        __slots__ = ()\n        @abc.abstractmethod\n        def __abs__(self) -> _T_co: ...\n\n    @runtime_checkable\n    class SupportsRound(Protocol[_T_co]):\n        __slots__ = ()\n        @overload\n        @abc.abstractmethod\n        def __round__(self) -> int: ...\n        @overload\n        @abc.abstractmethod\n        def __round__(self, ndigits: int, /) -> _T_co: ...\n\nif sys.version_info >= (3, 14):\n    from io import Reader as Reader, Writer as Writer\nelse:\n    @runtime_checkable\n    class Reader(Protocol[_T_co]):\n        __slots__ = ()\n        @abc.abstractmethod\n        def read(self, size: int = ..., /) -> _T_co: ...\n\n    @runtime_checkable\n    class Writer(Protocol[_T_contra]):\n        __slots__ = ()\n        @abc.abstractmethod\n        def write(self, data: _T_contra, /) -> int: ...\n\nif sys.version_info >= (3, 13):\n    from types import CapsuleType as CapsuleType\n    from typing import (\n        NoDefault as NoDefault,\n        ParamSpec as ParamSpec,\n        ReadOnly as ReadOnly,\n        TypeIs as TypeIs,\n        TypeVar as TypeVar,\n        TypeVarTuple as TypeVarTuple,\n        get_protocol_members as get_protocol_members,\n        is_protocol as is_protocol,\n    )\n    from warnings import deprecated as deprecated\nelse:\n    def is_protocol(tp: type, /) -> bool: ...\n    def get_protocol_members(tp: type, /) -> frozenset[str]: ...\n    @final\n    @type_check_only\n    class _NoDefaultType: ...\n\n    NoDefault: _NoDefaultType\n    @final\n    class CapsuleType: ...\n\n    class deprecated:\n        message: LiteralString\n        category: type[Warning] | None\n        stacklevel: int\n        def __init__(self, message: LiteralString, /, *, category: type[Warning] | None = ..., stacklevel: int = 1) -> None: ...\n        def __call__(self, arg: _T, /) -> _T: ...\n\n    @final\n    class TypeVar:\n        @property\n        def __name__(self) -> str: ...\n        @property\n        def __bound__(self) -> AnnotationForm | None: ...\n        @property\n        def __constraints__(self) -> tuple[AnnotationForm, ...]: ...\n        @property\n        def __covariant__(self) -> bool: ...\n        @property\n        def __contravariant__(self) -> bool: ...\n        @property\n        def __infer_variance__(self) -> bool: ...\n        @property\n        def __default__(self) -> AnnotationForm: ...\n        def __init__(\n            self,\n            name: str,\n            *constraints: AnnotationForm,\n            bound: AnnotationForm | None = None,\n            covariant: bool = False,\n            contravariant: bool = False,\n            default: AnnotationForm = ...,\n            infer_variance: bool = False,\n        ) -> None: ...\n        def has_default(self) -> bool: ...\n        def __typing_prepare_subst__(self, alias: Any, args: Any) -> tuple[Any, ...]: ...\n        if sys.version_info >= (3, 10):\n            def __or__(self, right: Any) -> _SpecialForm: ...\n            def __ror__(self, left: Any) -> _SpecialForm: ...\n        if sys.version_info >= (3, 11):\n            def __typing_subst__(self, arg: Any) -> Any: ...\n\n    @final\n    class ParamSpec:\n        @property\n        def __name__(self) -> str: ...\n        @property\n        def __bound__(self) -> AnnotationForm | None: ...\n        @property\n        def __covariant__(self) -> bool: ...\n        @property\n        def __contravariant__(self) -> bool: ...\n        @property\n        def __infer_variance__(self) -> bool: ...\n        @property\n        def __default__(self) -> AnnotationForm: ...\n        def __init__(\n            self,\n            name: str,\n            *,\n            bound: None | AnnotationForm | str = None,\n            contravariant: bool = False,\n            covariant: bool = False,\n            default: AnnotationForm = ...,\n        ) -> None: ...\n        @property\n        def args(self) -> ParamSpecArgs: ...\n        @property\n        def kwargs(self) -> ParamSpecKwargs: ...\n        def has_default(self) -> bool: ...\n        def __typing_prepare_subst__(self, alias: Any, args: Any) -> tuple[Any, ...]: ...\n        if sys.version_info >= (3, 10):\n            def __or__(self, right: Any) -> _SpecialForm: ...\n            def __ror__(self, left: Any) -> _SpecialForm: ...\n\n    @final\n    class TypeVarTuple:\n        @property\n        def __name__(self) -> str: ...\n        @property\n        def __default__(self) -> AnnotationForm: ...\n        def __init__(self, name: str, *, default: AnnotationForm = ...) -> None: ...\n        def __iter__(self) -> Any: ...  # Unpack[Self]\n        def has_default(self) -> bool: ...\n        def __typing_prepare_subst__(self, alias: Any, args: Any) -> tuple[Any, ...]: ...\n\n    ReadOnly: _SpecialForm\n    TypeIs: _SpecialForm\n\n# TypeAliasType was added in Python 3.12, but had significant changes in 3.14.\nif sys.version_info >= (3, 14):\n    from typing import TypeAliasType as TypeAliasType\nelse:\n    @final\n    class TypeAliasType:\n        def __init__(\n            self, name: str, value: AnnotationForm, *, type_params: tuple[TypeVar | ParamSpec | TypeVarTuple, ...] = ()\n        ) -> None: ...\n        @property\n        def __value__(self) -> AnnotationForm: ...\n        @property\n        def __type_params__(self) -> tuple[TypeVar | ParamSpec | TypeVarTuple, ...]: ...\n        @property\n        # `__parameters__` can include special forms if a `TypeVarTuple` was\n        # passed as a `type_params` element to the constructor method.\n        def __parameters__(self) -> tuple[TypeVar | ParamSpec | AnnotationForm, ...]: ...\n        @property\n        def __name__(self) -> str: ...\n        # It's writable on types, but not on instances of TypeAliasType.\n        @property\n        def __module__(self) -> str | None: ...  # type: ignore[override]\n        # Returns typing._GenericAlias, which isn't stubbed.\n        def __getitem__(self, parameters: Incomplete | tuple[Incomplete, ...]) -> AnnotationForm: ...\n        def __init_subclass__(cls, *args: Unused, **kwargs: Unused) -> NoReturn: ...\n        if sys.version_info >= (3, 10):\n            def __or__(self, right: Any, /) -> _SpecialForm: ...\n            def __ror__(self, left: Any, /) -> _SpecialForm: ...\n\n# PEP 727\nclass Doc:\n    documentation: str\n    def __init__(self, documentation: str, /) -> None: ...\n    def __hash__(self) -> int: ...\n    def __eq__(self, other: object) -> bool: ...\n\n# PEP 728\n@type_check_only\nclass _NoExtraItemsType: ...\n\nNoExtraItems: _NoExtraItemsType\n\n# PEP 747\nTypeForm: _SpecialForm\n\n# PEP 649/749\nif sys.version_info >= (3, 14):\n    from typing import evaluate_forward_ref as evaluate_forward_ref\n\n    from annotationlib import Format as Format, get_annotations as get_annotations, type_repr as type_repr\nelse:\n    class Format(enum.IntEnum):\n        VALUE = 1\n        VALUE_WITH_FAKE_GLOBALS = 2\n        FORWARDREF = 3\n        STRING = 4\n\n    @overload\n    def get_annotations(\n        obj: Any,  # any object with __annotations__ or __annotate__\n        *,\n        globals: Mapping[str, Any] | None = None,  # value types depend on the key\n        locals: Mapping[str, Any] | None = None,  # value types depend on the key\n        eval_str: bool = False,\n        format: Literal[Format.STRING],\n    ) -> dict[str, str]: ...\n    @overload\n    def get_annotations(\n        obj: Any,  # any object with __annotations__ or __annotate__\n        *,\n        globals: Mapping[str, Any] | None = None,  # value types depend on the key\n        locals: Mapping[str, Any] | None = None,  # value types depend on the key\n        eval_str: bool = False,\n        format: Literal[Format.FORWARDREF],\n    ) -> dict[str, AnnotationForm | ForwardRef]: ...\n    @overload\n    def get_annotations(\n        obj: Any,  # any object with __annotations__ or __annotate__\n        *,\n        globals: Mapping[str, Any] | None = None,  # value types depend on the key\n        locals: Mapping[str, Any] | None = None,  # value types depend on the key\n        eval_str: bool = False,\n        format: Format = Format.VALUE,  # noqa: Y011\n    ) -> dict[str, AnnotationForm]: ...\n    @overload\n    def evaluate_forward_ref(\n        forward_ref: ForwardRef,\n        *,\n        owner: Callable[..., object] | type[object] | ModuleType | None = None,  # any callable, class, or module\n        globals: Mapping[str, Any] | None = None,  # value types depend on the key\n        locals: Mapping[str, Any] | None = None,  # value types depend on the key\n        type_params: Iterable[TypeVar | ParamSpec | TypeVarTuple] | None = None,\n        format: Literal[Format.STRING],\n        _recursive_guard: Container[str] = ...,\n    ) -> str: ...\n    @overload\n    def evaluate_forward_ref(\n        forward_ref: ForwardRef,\n        *,\n        owner: Callable[..., object] | type[object] | ModuleType | None = None,  # any callable, class, or module\n        globals: Mapping[str, Any] | None = None,  # value types depend on the key\n        locals: Mapping[str, Any] | None = None,  # value types depend on the key\n        type_params: Iterable[TypeVar | ParamSpec | TypeVarTuple] | None = None,\n        format: Literal[Format.FORWARDREF],\n        _recursive_guard: Container[str] = ...,\n    ) -> AnnotationForm | ForwardRef: ...\n    @overload\n    def evaluate_forward_ref(\n        forward_ref: ForwardRef,\n        *,\n        owner: Callable[..., object] | type[object] | ModuleType | None = None,  # any callable, class, or module\n        globals: Mapping[str, Any] | None = None,  # value types depend on the key\n        locals: Mapping[str, Any] | None = None,  # value types depend on the key\n        type_params: Iterable[TypeVar | ParamSpec | TypeVarTuple] | None = None,\n        format: Format | None = None,\n        _recursive_guard: Container[str] = ...,\n    ) -> AnnotationForm: ...\n    def type_repr(value: object) -> str: ...\n\n# PEP 661\nclass Sentinel:\n    def __init__(self, name: str, repr: str | None = None) -> None: ...\n    if sys.version_info >= (3, 14):\n        def __or__(self, other: Any) -> UnionType: ...  # other can be any type form legal for unions\n        def __ror__(self, other: Any) -> UnionType: ...  # other can be any type form legal for unions\n    elif sys.version_info >= (3, 10):\n        def __or__(self, other: Any) -> _SpecialForm: ...  # other can be any type form legal for unions\n        def __ror__(self, other: Any) -> _SpecialForm: ...  # other can be any type form legal for unions\n",
  "/typeshed/stdlib/warnings.pyi": "import re\nimport sys\nfrom _warnings import warn as warn, warn_explicit as warn_explicit\nfrom collections.abc import Sequence\nfrom types import ModuleType, TracebackType\nfrom typing import Any, Generic, Literal, TextIO, overload\nfrom typing_extensions import LiteralString, TypeAlias, TypeVar\n\n__all__ = [\n    \"warn\",\n    \"warn_explicit\",\n    \"showwarning\",\n    \"formatwarning\",\n    \"filterwarnings\",\n    \"simplefilter\",\n    \"resetwarnings\",\n    \"catch_warnings\",\n]\n\nif sys.version_info >= (3, 13):\n    __all__ += [\"deprecated\"]\n\n_T = TypeVar(\"_T\")\n_W_co = TypeVar(\"_W_co\", bound=list[WarningMessage] | None, default=list[WarningMessage] | None, covariant=True)\n\nif sys.version_info >= (3, 14):\n    _ActionKind: TypeAlias = Literal[\"default\", \"error\", \"ignore\", \"always\", \"module\", \"once\"]\nelse:\n    _ActionKind: TypeAlias = Literal[\"default\", \"error\", \"ignore\", \"always\", \"all\", \"module\", \"once\"]\nfilters: Sequence[tuple[str, re.Pattern[str] | None, type[Warning], re.Pattern[str] | None, int]]  # undocumented, do not mutate\n\ndef showwarning(\n    message: Warning | str,\n    category: type[Warning],\n    filename: str,\n    lineno: int,\n    file: TextIO | None = None,\n    line: str | None = None,\n) -> None: ...\ndef formatwarning(\n    message: Warning | str, category: type[Warning], filename: str, lineno: int, line: str | None = None\n) -> str: ...\ndef filterwarnings(\n    action: _ActionKind, message: str = \"\", category: type[Warning] = ..., module: str = \"\", lineno: int = 0, append: bool = False\n) -> None: ...\ndef simplefilter(action: _ActionKind, category: type[Warning] = ..., lineno: int = 0, append: bool = False) -> None: ...\ndef resetwarnings() -> None: ...\n\nclass _OptionError(Exception): ...\n\nclass WarningMessage:\n    message: Warning | str\n    category: type[Warning]\n    filename: str\n    lineno: int\n    file: TextIO | None\n    line: str | None\n    source: Any | None\n    def __init__(\n        self,\n        message: Warning | str,\n        category: type[Warning],\n        filename: str,\n        lineno: int,\n        file: TextIO | None = None,\n        line: str | None = None,\n        source: Any | None = None,\n    ) -> None: ...\n\nclass catch_warnings(Generic[_W_co]):\n    if sys.version_info >= (3, 11):\n        @overload\n        def __init__(\n            self: catch_warnings[None],\n            *,\n            record: Literal[False] = False,\n            module: ModuleType | None = None,\n            action: _ActionKind | None = None,\n            category: type[Warning] = ...,\n            lineno: int = 0,\n            append: bool = False,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self: catch_warnings[list[WarningMessage]],\n            *,\n            record: Literal[True],\n            module: ModuleType | None = None,\n            action: _ActionKind | None = None,\n            category: type[Warning] = ...,\n            lineno: int = 0,\n            append: bool = False,\n        ) -> None: ...\n        @overload\n        def __init__(\n            self,\n            *,\n            record: bool,\n            module: ModuleType | None = None,\n            action: _ActionKind | None = None,\n            category: type[Warning] = ...,\n            lineno: int = 0,\n            append: bool = False,\n        ) -> None: ...\n    else:\n        @overload\n        def __init__(self: catch_warnings[None], *, record: Literal[False] = False, module: ModuleType | None = None) -> None: ...\n        @overload\n        def __init__(\n            self: catch_warnings[list[WarningMessage]], *, record: Literal[True], module: ModuleType | None = None\n        ) -> None: ...\n        @overload\n        def __init__(self, *, record: bool, module: ModuleType | None = None) -> None: ...\n\n    def __enter__(self) -> _W_co: ...\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -> None: ...\n\nif sys.version_info >= (3, 13):\n    class deprecated:\n        message: LiteralString\n        category: type[Warning] | None\n        stacklevel: int\n        def __init__(self, message: LiteralString, /, *, category: type[Warning] | None = ..., stacklevel: int = 1) -> None: ...\n        def __call__(self, arg: _T, /) -> _T: ...\n",
  "/typeshed/stdlib/weakref.pyi": "from _typeshed import SupportsKeysAndGetItem\nfrom _weakref import getweakrefcount as getweakrefcount, getweakrefs as getweakrefs, proxy as proxy\nfrom _weakrefset import WeakSet as WeakSet\nfrom collections.abc import Callable, Iterable, Iterator, Mapping, MutableMapping\nfrom types import GenericAlias\nfrom typing import Any, ClassVar, Generic, TypeVar, final, overload\nfrom typing_extensions import ParamSpec, Self, disjoint_base\n\n__all__ = [\n    \"ref\",\n    \"proxy\",\n    \"getweakrefcount\",\n    \"getweakrefs\",\n    \"WeakKeyDictionary\",\n    \"ReferenceType\",\n    \"ProxyType\",\n    \"CallableProxyType\",\n    \"ProxyTypes\",\n    \"WeakValueDictionary\",\n    \"WeakSet\",\n    \"WeakMethod\",\n    \"finalize\",\n]\n\n_T = TypeVar(\"_T\")\n_T1 = TypeVar(\"_T1\")\n_T2 = TypeVar(\"_T2\")\n_KT = TypeVar(\"_KT\")\n_VT = TypeVar(\"_VT\")\n_CallableT = TypeVar(\"_CallableT\", bound=Callable[..., Any])\n_P = ParamSpec(\"_P\")\n\nProxyTypes: tuple[type[Any], ...]\n\n# These classes are implemented in C and imported from _weakref at runtime. However,\n# they consider themselves to live in the weakref module for sys.version_info >= (3, 11),\n# so defining their stubs here means we match their __module__ value.\n# Prior to 3.11 they did not declare a module for themselves and ended up looking like they\n# came from the builtin module at runtime, which was just wrong, and we won't attempt to\n# duplicate that.\n\n@final\nclass CallableProxyType(Generic[_CallableT]):  # \"weakcallableproxy\"\n    def __eq__(self, value: object, /) -> bool: ...\n    def __getattr__(self, attr: str) -> Any: ...\n    __call__: _CallableT\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n\n@final\nclass ProxyType(Generic[_T]):  # \"weakproxy\"\n    def __eq__(self, value: object, /) -> bool: ...\n    def __getattr__(self, attr: str) -> Any: ...\n    __hash__: ClassVar[None]  # type: ignore[assignment]\n\n@disjoint_base\nclass ReferenceType(Generic[_T]):  # \"weakref\"\n    __callback__: Callable[[Self], Any]\n    def __new__(cls, o: _T, callback: Callable[[Self], Any] | None = ..., /) -> Self: ...\n    def __call__(self) -> _T | None: ...\n    def __eq__(self, value: object, /) -> bool: ...\n    def __hash__(self) -> int: ...\n    def __class_getitem__(cls, item: Any, /) -> GenericAlias: ...\n\nref = ReferenceType\n\n# everything below here is implemented in weakref.py\n\nclass WeakMethod(ref[_CallableT]):\n    __slots__ = (\"_func_ref\", \"_meth_type\", \"_alive\", \"__weakref__\")\n    def __new__(cls, meth: _CallableT, callback: Callable[[Self], Any] | None = None) -> Self: ...\n    def __call__(self) -> _CallableT | None: ...\n    def __eq__(self, other: object) -> bool: ...\n    def __ne__(self, other: object) -> bool: ...\n    def __hash__(self) -> int: ...\n\nclass WeakValueDictionary(MutableMapping[_KT, _VT]):\n    @overload\n    def __init__(self) -> None: ...\n    @overload\n    def __init__(\n        self: WeakValueDictionary[_KT, _VT],  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n        other: Mapping[_KT, _VT] | Iterable[tuple[_KT, _VT]],\n        /,\n    ) -> None: ...\n    @overload\n    def __init__(\n        self: WeakValueDictionary[str, _VT],  # pyright: ignore[reportInvalidTypeVarUse]  #11780\n        other: Mapping[str, _VT] | Iterable[tuple[str, _VT]] = (),\n        /,\n        **kwargs: _VT,\n    ) -> None: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, key: _KT) -> _VT: ...\n    def __setitem__(self, key: _KT, value: _VT) -> None: ...\n    def __delitem__(self, key: _KT) -> None: ...\n    def __contains__(self, key: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def copy(self) -> WeakValueDictionary[_KT, _VT]: ...\n    __copy__ = copy\n    def __deepcopy__(self, memo: Any) -> Self: ...\n    @overload\n    def get(self, key: _KT, default: None = None) -> _VT | None: ...\n    @overload\n    def get(self, key: _KT, default: _VT) -> _VT: ...\n    @overload\n    def get(self, key: _KT, default: _T) -> _VT | _T: ...\n    # These are incompatible with Mapping\n    def keys(self) -> Iterator[_KT]: ...  # type: ignore[override]\n    def values(self) -> Iterator[_VT]: ...  # type: ignore[override]\n    def items(self) -> Iterator[tuple[_KT, _VT]]: ...  # type: ignore[override]\n    def itervaluerefs(self) -> Iterator[KeyedRef[_KT, _VT]]: ...\n    def valuerefs(self) -> list[KeyedRef[_KT, _VT]]: ...\n    def setdefault(self, key: _KT, default: _VT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _VT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _T) -> _VT | _T: ...\n    @overload\n    def update(self, other: SupportsKeysAndGetItem[_KT, _VT], /, **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, other: Iterable[tuple[_KT, _VT]], /, **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, other: None = None, /, **kwargs: _VT) -> None: ...\n    def __or__(self, other: Mapping[_T1, _T2]) -> WeakValueDictionary[_KT | _T1, _VT | _T2]: ...\n    def __ror__(self, other: Mapping[_T1, _T2]) -> WeakValueDictionary[_KT | _T1, _VT | _T2]: ...\n    # WeakValueDictionary.__ior__ should be kept roughly in line with MutableMapping.update()\n    @overload  # type: ignore[misc]\n    def __ior__(self, other: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...\n    @overload\n    def __ior__(self, other: Iterable[tuple[_KT, _VT]]) -> Self: ...\n\nclass KeyedRef(ref[_T], Generic[_KT, _T]):\n    __slots__ = (\"key\",)\n    key: _KT\n    def __new__(type, ob: _T, callback: Callable[[Self], Any], key: _KT) -> Self: ...\n    def __init__(self, ob: _T, callback: Callable[[Self], Any], key: _KT) -> None: ...\n\nclass WeakKeyDictionary(MutableMapping[_KT, _VT]):\n    @overload\n    def __init__(self, dict: None = None) -> None: ...\n    @overload\n    def __init__(self, dict: Mapping[_KT, _VT] | Iterable[tuple[_KT, _VT]]) -> None: ...\n    def __len__(self) -> int: ...\n    def __getitem__(self, key: _KT) -> _VT: ...\n    def __setitem__(self, key: _KT, value: _VT) -> None: ...\n    def __delitem__(self, key: _KT) -> None: ...\n    def __contains__(self, key: object) -> bool: ...\n    def __iter__(self) -> Iterator[_KT]: ...\n    def copy(self) -> WeakKeyDictionary[_KT, _VT]: ...\n    __copy__ = copy\n    def __deepcopy__(self, memo: Any) -> Self: ...\n    @overload\n    def get(self, key: _KT, default: None = None) -> _VT | None: ...\n    @overload\n    def get(self, key: _KT, default: _VT) -> _VT: ...\n    @overload\n    def get(self, key: _KT, default: _T) -> _VT | _T: ...\n    # These are incompatible with Mapping\n    def keys(self) -> Iterator[_KT]: ...  # type: ignore[override]\n    def values(self) -> Iterator[_VT]: ...  # type: ignore[override]\n    def items(self) -> Iterator[tuple[_KT, _VT]]: ...  # type: ignore[override]\n    def keyrefs(self) -> list[ref[_KT]]: ...\n    # Keep WeakKeyDictionary.setdefault in line with MutableMapping.setdefault, modulo positional-only differences\n    @overload\n    def setdefault(self: WeakKeyDictionary[_KT, _VT | None], key: _KT, default: None = None) -> _VT: ...\n    @overload\n    def setdefault(self, key: _KT, default: _VT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _VT) -> _VT: ...\n    @overload\n    def pop(self, key: _KT, default: _T) -> _VT | _T: ...\n    @overload\n    def update(self, dict: SupportsKeysAndGetItem[_KT, _VT], /, **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, dict: Iterable[tuple[_KT, _VT]], /, **kwargs: _VT) -> None: ...\n    @overload\n    def update(self, dict: None = None, /, **kwargs: _VT) -> None: ...\n    def __or__(self, other: Mapping[_T1, _T2]) -> WeakKeyDictionary[_KT | _T1, _VT | _T2]: ...\n    def __ror__(self, other: Mapping[_T1, _T2]) -> WeakKeyDictionary[_KT | _T1, _VT | _T2]: ...\n    # WeakKeyDictionary.__ior__ should be kept roughly in line with MutableMapping.update()\n    @overload  # type: ignore[misc]\n    def __ior__(self, other: SupportsKeysAndGetItem[_KT, _VT]) -> Self: ...\n    @overload\n    def __ior__(self, other: Iterable[tuple[_KT, _VT]]) -> Self: ...\n\nclass finalize(Generic[_P, _T]):\n    __slots__ = ()\n    def __init__(self, obj: _T, func: Callable[_P, Any], /, *args: _P.args, **kwargs: _P.kwargs) -> None: ...\n    def __call__(self, _: Any = None) -> Any | None: ...\n    def detach(self) -> tuple[_T, Callable[_P, Any], tuple[Any, ...], dict[str, Any]] | None: ...\n    def peek(self) -> tuple[_T, Callable[_P, Any], tuple[Any, ...], dict[str, Any]] | None: ...\n    @property\n    def alive(self) -> bool: ...\n    atexit: bool\n"
}