/**
 * Minimal Python builtins stub for basedpyright browser version.
 * This provides type information for Python's built-in functions and types.
 */

export const BUILTINS_STUB = `
# Minimal builtins.pyi for browser-basedpyright
from typing import Any, Callable, Generic, Iterable, Iterator, Mapping, Sequence, TypeVar, Union, overload

_T = TypeVar('_T')
_T_co = TypeVar('_T_co', covariant=True)
_KT = TypeVar('_KT')
_VT = TypeVar('_VT')

# Basic types
class object:
    def __init__(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...

class type(Generic[_T]):
    def __init__(self, o: object) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...

class int:
    def __init__(self, x: Union[str, bytes, int, float] = ...) -> None: ...
    def __add__(self, other: int) -> int: ...
    def __sub__(self, other: int) -> int: ...
    def __mul__(self, other: int) -> int: ...
    def __truediv__(self, other: int) -> float: ...
    def __floordiv__(self, other: int) -> int: ...
    def __mod__(self, other: int) -> int: ...
    def __pow__(self, other: int) -> int: ...
    def __neg__(self) -> int: ...
    def __pos__(self) -> int: ...
    def __abs__(self) -> int: ...
    def __lt__(self, other: int) -> bool: ...
    def __le__(self, other: int) -> bool: ...
    def __gt__(self, other: int) -> bool: ...
    def __ge__(self, other: int) -> bool: ...

class float:
    def __init__(self, x: Union[str, bytes, int, float] = ...) -> None: ...
    def __add__(self, other: float) -> float: ...
    def __sub__(self, other: float) -> float: ...
    def __mul__(self, other: float) -> float: ...
    def __truediv__(self, other: float) -> float: ...
    def __neg__(self) -> float: ...
    def __pos__(self) -> float: ...
    def __abs__(self) -> float: ...
    def __lt__(self, other: float) -> bool: ...
    def __le__(self, other: float) -> bool: ...
    def __gt__(self, other: float) -> bool: ...
    def __ge__(self, other: float) -> bool: ...

class complex:
    def __init__(self, real: float = ..., imag: float = ...) -> None: ...

class bool(int):
    def __init__(self, x: object = ...) -> None: ...

class str(Sequence[str]):
    def __init__(self, o: object = ...) -> None: ...
    def __add__(self, other: str) -> str: ...
    def __mul__(self, n: int) -> str: ...
    def __contains__(self, item: str) -> bool: ...
    def __getitem__(self, key: Union[int, slice]) -> str: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...
    def format(self, *args: Any, **kwargs: Any) -> str: ...
    def join(self, iterable: Iterable[str]) -> str: ...
    def split(self, sep: str | None = ..., maxsplit: int = ...) -> list[str]: ...
    def strip(self, chars: str | None = ...) -> str: ...
    def lstrip(self, chars: str | None = ...) -> str: ...
    def rstrip(self, chars: str | None = ...) -> str: ...
    def lower(self) -> str: ...
    def upper(self) -> str: ...
    def replace(self, old: str, new: str, count: int = ...) -> str: ...
    def startswith(self, prefix: Union[str, tuple[str, ...]], start: int = ..., end: int = ...) -> bool: ...
    def endswith(self, suffix: Union[str, tuple[str, ...]], start: int = ..., end: int = ...) -> bool: ...
    def find(self, sub: str, start: int = ..., end: int = ...) -> int: ...
    def index(self, sub: str, start: int = ..., end: int = ...) -> int: ...
    def count(self, sub: str, start: int = ..., end: int = ...) -> int: ...
    def isalpha(self) -> bool: ...
    def isdigit(self) -> bool: ...
    def isalnum(self) -> bool: ...
    def isspace(self) -> bool: ...
    def encode(self, encoding: str = ..., errors: str = ...) -> bytes: ...

class bytes(Sequence[int]):
    def __init__(self, o: Union[Iterable[int], int, str, bytes] = ...) -> None: ...
    def __add__(self, other: bytes) -> bytes: ...
    def __contains__(self, item: Union[int, bytes]) -> bool: ...
    def __getitem__(self, key: Union[int, slice]) -> Union[int, bytes]: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def decode(self, encoding: str = ..., errors: str = ...) -> str: ...

class bytearray(Sequence[int]):
    def __init__(self, o: Union[Iterable[int], int, str, bytes] = ...) -> None: ...
    def __add__(self, other: Union[bytes, bytearray]) -> bytearray: ...
    def __contains__(self, item: Union[int, bytes]) -> bool: ...
    def __getitem__(self, key: Union[int, slice]) -> Union[int, bytearray]: ...
    def __setitem__(self, key: Union[int, slice], value: Union[int, Iterable[int]]) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...

class list(Generic[_T]):
    def __init__(self, iterable: Iterable[_T] = ...) -> None: ...
    def __contains__(self, item: object) -> bool: ...
    def __getitem__(self, key: Union[int, slice]) -> Union[_T, list[_T]]: ...
    def __setitem__(self, key: Union[int, slice], value: Union[_T, Iterable[_T]]) -> None: ...
    def __delitem__(self, key: Union[int, slice]) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_T]: ...
    def __add__(self, other: list[_T]) -> list[_T]: ...
    def __mul__(self, n: int) -> list[_T]: ...
    def append(self, item: _T) -> None: ...
    def extend(self, iterable: Iterable[_T]) -> None: ...
    def insert(self, index: int, item: _T) -> None: ...
    def remove(self, item: _T) -> None: ...
    def pop(self, index: int = ...) -> _T: ...
    def clear(self) -> None: ...
    def index(self, item: _T, start: int = ..., stop: int = ...) -> int: ...
    def count(self, item: _T) -> int: ...
    def sort(self, *, key: Callable[[_T], Any] | None = ..., reverse: bool = ...) -> None: ...
    def reverse(self) -> None: ...
    def copy(self) -> list[_T]: ...

class dict(Generic[_KT, _VT]):
    def __init__(self, **kwargs: _VT) -> None: ...
    @overload
    def __init__(self, mapping: Mapping[_KT, _VT]) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[tuple[_KT, _VT]]) -> None: ...
    def __contains__(self, key: object) -> bool: ...
    def __getitem__(self, key: _KT) -> _VT: ...
    def __setitem__(self, key: _KT, value: _VT) -> None: ...
    def __delitem__(self, key: _KT) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_KT]: ...
    def keys(self) -> Iterable[_KT]: ...
    def values(self) -> Iterable[_VT]: ...
    def items(self) -> Iterable[tuple[_KT, _VT]]: ...
    def get(self, key: _KT, default: _VT | None = ...) -> _VT | None: ...
    def pop(self, key: _KT, default: _VT = ...) -> _VT: ...
    def update(self, other: Mapping[_KT, _VT] = ..., **kwargs: _VT) -> None: ...
    def clear(self) -> None: ...
    def copy(self) -> dict[_KT, _VT]: ...

class set(Generic[_T]):
    def __init__(self, iterable: Iterable[_T] = ...) -> None: ...
    def __contains__(self, item: object) -> bool: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_T]: ...
    def add(self, item: _T) -> None: ...
    def remove(self, item: _T) -> None: ...
    def discard(self, item: _T) -> None: ...
    def pop(self) -> _T: ...
    def clear(self) -> None: ...
    def union(self, *others: Iterable[_T]) -> set[_T]: ...
    def intersection(self, *others: Iterable[_T]) -> set[_T]: ...
    def difference(self, *others: Iterable[_T]) -> set[_T]: ...
    def copy(self) -> set[_T]: ...

class frozenset(Generic[_T]):
    def __init__(self, iterable: Iterable[_T] = ...) -> None: ...
    def __contains__(self, item: object) -> bool: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_T]: ...
    def union(self, *others: Iterable[_T]) -> frozenset[_T]: ...
    def intersection(self, *others: Iterable[_T]) -> frozenset[_T]: ...
    def difference(self, *others: Iterable[_T]) -> frozenset[_T]: ...
    def copy(self) -> frozenset[_T]: ...

class tuple(Generic[_T_co]):
    def __init__(self, iterable: Iterable[_T_co] = ...) -> None: ...
    def __contains__(self, item: object) -> bool: ...
    def __getitem__(self, key: Union[int, slice]) -> Any: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_T_co]: ...
    def __add__(self, other: tuple[_T_co, ...]) -> tuple[_T_co, ...]: ...
    def __mul__(self, n: int) -> tuple[_T_co, ...]: ...
    def count(self, item: _T_co) -> int: ...
    def index(self, item: _T_co, start: int = ..., stop: int = ...) -> int: ...

class range:
    def __init__(self, stop: int) -> None: ...
    @overload
    def __init__(self, start: int, stop: int, step: int = ...) -> None: ...
    def __contains__(self, item: int) -> bool: ...
    def __getitem__(self, key: Union[int, slice]) -> Union[int, range]: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[int]: ...
    def count(self, item: int) -> int: ...
    def index(self, item: int) -> int: ...

class slice:
    start: int | None
    stop: int | None
    step: int | None
    def __init__(self, stop: int | None) -> None: ...
    @overload
    def __init__(self, start: int | None, stop: int | None, step: int | None = ...) -> None: ...

# Constants
None: None
True: bool
False: bool
Ellipsis: ellipsis

class ellipsis: ...

# Built-in functions
def print(*values: object, sep: str = ..., end: str = ..., file: Any = ..., flush: bool = ...) -> None: ...
def input(prompt: str = ...) -> str: ...
def len(obj: Sized) -> int: ...
def abs(x: Any) -> Any: ...
def round(number: float, ndigits: int | None = ...) -> float: ...
def min(*args: _T, key: Callable[[_T], Any] | None = ..., default: _T = ...) -> _T: ...
def max(*args: _T, key: Callable[[_T], Any] | None = ..., default: _T = ...) -> _T: ...
def sum(iterable: Iterable[_T], start: _T = ...) -> _T: ...
def sorted(iterable: Iterable[_T], *, key: Callable[[_T], Any] | None = ..., reverse: bool = ...) -> list[_T]: ...
def reversed(seq: Sequence[_T]) -> Iterator[_T]: ...
def enumerate(iterable: Iterable[_T], start: int = ...) -> Iterator[tuple[int, _T]]: ...
def zip(*iterables: Iterable[Any]) -> Iterator[tuple[Any, ...]]: ...
def map(func: Callable[..., _T], *iterables: Iterable[Any]) -> Iterator[_T]: ...
def filter(func: Callable[[_T], bool] | None, iterable: Iterable[_T]) -> Iterator[_T]: ...
def any(iterable: Iterable[object]) -> bool: ...
def all(iterable: Iterable[object]) -> bool: ...
def isinstance(obj: object, classinfo: type | tuple[type, ...]) -> bool: ...
def issubclass(cls: type, classinfo: type | tuple[type, ...]) -> bool: ...
def hasattr(obj: object, name: str) -> bool: ...
def getattr(obj: object, name: str, default: _T = ...) -> Any: ...
def setattr(obj: object, name: str, value: Any) -> None: ...
def delattr(obj: object, name: str) -> None: ...
def callable(obj: object) -> bool: ...
def repr(obj: object) -> str: ...
def ascii(obj: object) -> str: ...
def bin(x: int) -> str: ...
def oct(x: int) -> str: ...
def hex(x: int) -> str: ...
def ord(c: str) -> int: ...
def chr(i: int) -> str: ...
def hash(obj: object) -> int: ...
def id(obj: object) -> int: ...
def iter(obj: Iterable[_T]) -> Iterator[_T]: ...
def next(iterator: Iterator[_T], default: _T = ...) -> _T: ...
def open(file: str, mode: str = ..., buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ..., closefd: bool = ..., opener: Callable[[str, int], int] | None = ...) -> Any: ...
def pow(base: int, exp: int, mod: int | None = ...) -> int: ...
def divmod(x: int, y: int) -> tuple[int, int]: ...
def format(value: object, format_spec: str = ...) -> str: ...
def vars(obj: object = ...) -> dict[str, Any]: ...
def dir(obj: object = ...) -> list[str]: ...
def globals() -> dict[str, Any]: ...
def locals() -> dict[str, Any]: ...
def exec(source: str | bytes, globals: dict[str, Any] | None = ..., locals: Mapping[str, Any] | None = ...) -> None: ...
def eval(source: str, globals: dict[str, Any] | None = ..., locals: Mapping[str, Any] | None = ...) -> Any: ...
def compile(source: str | bytes, filename: str, mode: str, flags: int = ..., dont_inherit: bool = ..., optimize: int = ...) -> Any: ...

# Protocol classes
class Sized:
    def __len__(self) -> int: ...

class Hashable:
    def __hash__(self) -> int: ...

# Decorators
def staticmethod(f: Callable[..., _T]) -> staticmethod[_T]: ...
def classmethod(f: Callable[..., _T]) -> classmethod[_T]: ...
def property(fget: Callable[[Any], _T] | None = ..., fset: Callable[[Any, _T], None] | None = ..., fdel: Callable[[Any], None] | None = ..., doc: str | None = ...) -> property: ...

# Exception classes
class BaseException:
    args: tuple[Any, ...]
    def __init__(self, *args: object) -> None: ...
    def __str__(self) -> str: ...

class Exception(BaseException): ...
class TypeError(Exception): ...
class ValueError(Exception): ...
class AttributeError(Exception): ...
class KeyError(Exception): ...
class IndexError(Exception): ...
class RuntimeError(Exception): ...
class StopIteration(Exception):
    value: Any
class GeneratorExit(BaseException): ...
class SystemExit(BaseException):
    code: int | str | None
class KeyboardInterrupt(BaseException): ...
class ImportError(Exception): ...
class ModuleNotFoundError(ImportError): ...
class OSError(Exception): ...
class FileNotFoundError(OSError): ...
class PermissionError(OSError): ...
class IOError(OSError): ...
class NameError(Exception): ...
class UnboundLocalError(NameError): ...
class ZeroDivisionError(Exception): ...
class OverflowError(Exception): ...
class FloatingPointError(Exception): ...
class ArithmeticError(Exception): ...
class AssertionError(Exception): ...
class NotImplementedError(Exception): ...
class RecursionError(Exception): ...
class MemoryError(Exception): ...
class SyntaxError(Exception): ...
class IndentationError(SyntaxError): ...
class TabError(IndentationError): ...
class LookupError(Exception): ...
class UnicodeError(ValueError): ...
class UnicodeDecodeError(UnicodeError): ...
class UnicodeEncodeError(UnicodeError): ...
class Warning(Exception): ...
class DeprecationWarning(Warning): ...
class PendingDeprecationWarning(Warning): ...
class RuntimeWarning(Warning): ...
class SyntaxWarning(Warning): ...
class UserWarning(Warning): ...
class FutureWarning(Warning): ...
class ImportWarning(Warning): ...
class UnicodeWarning(Warning): ...
class BytesWarning(Warning): ...
class ResourceWarning(Warning): ...

# Super
def super(t: type = ..., obj: object = ...) -> super: ...

# NotImplemented
NotImplemented: Any
`;

/**
 * Minimal typing module stub for browser-basedpyright.
 * Provides core typing constructs that builtins.pyi imports.
 */
export const TYPING_STUB = `
# Minimal typing.pyi for browser-basedpyright
from collections.abc import Callable as Callable, Iterable as Iterable, Iterator as Iterator, Mapping as Mapping, Sequence as Sequence

class _SpecialForm:
    def __getitem__(self, params: object) -> object: ...

Any: _SpecialForm
Union: _SpecialForm
Optional: _SpecialForm
Literal: _SpecialForm
Final: _SpecialForm
ClassVar: _SpecialForm
Annotated: _SpecialForm
TypeAlias: _SpecialForm
Concatenate: _SpecialForm
TypeGuard: _SpecialForm
Never: _SpecialForm
NoReturn: _SpecialForm
Self: _SpecialForm
Required: _SpecialForm
NotRequired: _SpecialForm
Unpack: _SpecialForm
TypeVarTuple: _SpecialForm

class TypeVar:
    def __init__(
        self,
        name: str,
        *constraints: type,
        bound: type | None = ...,
        covariant: bool = ...,
        contravariant: bool = ...
    ) -> None: ...

class ParamSpec:
    def __init__(self, name: str) -> None: ...

class Generic: ...
class Protocol: ...
class NamedTuple: ...
class TypedDict: ...

def overload(func: Callable[..., object]) -> Callable[..., object]: ...
def final(f: object) -> object: ...
def cast(typ: type, val: object) -> object: ...
def assert_type(val: object, typ: type) -> None: ...
def reveal_type(obj: object) -> None: ...
def get_type_hints(obj: object) -> dict[str, object]: ...
def get_origin(tp: object) -> object | None: ...
def get_args(tp: object) -> tuple[object, ...]: ...

TYPE_CHECKING: bool

# Type aliases
List = list
Dict = dict
Set = set
FrozenSet = frozenset
Tuple = tuple
Type = type
`;

/**
 * Minimal _typeshed module stub for browser-basedpyright.
 * Provides internal type definitions used by typeshed stubs.
 */
export const TYPESHED_STUB = `
# Minimal _typeshed/__init__.pyi for browser-basedpyright
from typing import Any, Protocol, TypeVar

_T = TypeVar('_T')
_T_co = TypeVar('_T_co', covariant=True)
_T_contra = TypeVar('_T_contra', contravariant=True)

class SupportsRead(Protocol[_T_co]):
    def read(self, __length: int = ...) -> _T_co: ...

class SupportsWrite(Protocol[_T_contra]):
    def write(self, __s: _T_contra) -> object: ...

class SupportsReadline(Protocol[_T_co]):
    def readline(self, __length: int = ...) -> _T_co: ...

class SupportsNoArgReadline(Protocol[_T_co]):
    def readline(self) -> _T_co: ...

# Common type aliases
ReadableBuffer = bytes | bytearray | memoryview
WriteableBuffer = bytearray | memoryview
ReadOnlyBuffer = bytes | memoryview

StrPath = str
BytesPath = bytes
StrOrBytesPath = str | bytes

FileDescriptor = int
FileDescriptorLike = int

OpenTextMode = str
OpenBinaryMode = str

Incomplete = Any
Unused = object
`;

/**
 * Minimal collections.abc module stub for browser-basedpyright.
 * Provides abstract base classes that typing.pyi imports.
 */
export const COLLECTIONS_ABC_STUB = `
# Minimal collections/abc.pyi for browser-basedpyright
from typing import TypeVar, Generic

_T = TypeVar('_T')
_T_co = TypeVar('_T_co', covariant=True)
_T_contra = TypeVar('_T_contra', contravariant=True)
_KT = TypeVar('_KT')
_VT = TypeVar('_VT')
_VT_co = TypeVar('_VT_co', covariant=True)

class Iterable(Generic[_T_co]):
    def __iter__(self) -> Iterator[_T_co]: ...

class Iterator(Iterable[_T_co]):
    def __next__(self) -> _T_co: ...

class Reversible(Iterable[_T_co]):
    def __reversed__(self) -> Iterator[_T_co]: ...

class Container(Generic[_T_co]):
    def __contains__(self, __x: object) -> bool: ...

class Collection(Sized, Iterable[_T_co], Container[_T_co]): ...

class Callable(Generic[_T_co]): ...

class Sized:
    def __len__(self) -> int: ...

class Hashable:
    def __hash__(self) -> int: ...

class Mapping(Collection[_KT], Generic[_KT, _VT_co]):
    def __getitem__(self, __key: _KT) -> _VT_co: ...
    def keys(self) -> Iterable[_KT]: ...
    def items(self) -> Iterable[tuple[_KT, _VT_co]]: ...
    def values(self) -> Iterable[_VT_co]: ...

class MutableMapping(Mapping[_KT, _VT]):
    def __setitem__(self, __key: _KT, __value: _VT) -> None: ...
    def __delitem__(self, __key: _KT) -> None: ...

class Sequence(Reversible[_T_co], Collection[_T_co]):
    def __getitem__(self, index: int) -> _T_co: ...
    def index(self, value: object, start: int = ..., stop: int = ...) -> int: ...
    def count(self, value: object) -> int: ...

class MutableSequence(Sequence[_T]):
    def __setitem__(self, index: int, value: _T) -> None: ...
    def __delitem__(self, index: int) -> None: ...
    def insert(self, index: int, value: _T) -> None: ...
    def append(self, value: _T) -> None: ...
    def clear(self) -> None: ...
    def reverse(self) -> None: ...
    def extend(self, values: Iterable[_T]) -> None: ...
    def pop(self, index: int = ...) -> _T: ...
    def remove(self, value: _T) -> None: ...

class Set(Collection[_T_co]):
    def __contains__(self, __x: object) -> bool: ...
    def __le__(self, __other: Set[object]) -> bool: ...
    def __lt__(self, __other: Set[object]) -> bool: ...
    def __ge__(self, __other: Set[object]) -> bool: ...
    def __gt__(self, __other: Set[object]) -> bool: ...
    def __and__(self, __other: Set[object]) -> Set[_T_co]: ...
    def __or__(self, __other: Set[_T]) -> Set[_T_co | _T]: ...
    def __sub__(self, __other: Set[object]) -> Set[_T_co]: ...
    def __xor__(self, __other: Set[_T]) -> Set[_T_co | _T]: ...
    def isdisjoint(self, __other: Iterable[object]) -> bool: ...

class MutableSet(Set[_T]):
    def add(self, __value: _T) -> None: ...
    def discard(self, __value: _T) -> None: ...
    def remove(self, __value: _T) -> None: ...
    def pop(self) -> _T: ...
    def clear(self) -> None: ...

class Generator(Iterator[_T_co], Generic[_T_co, _T_contra, _VT_co]):
    def send(self, __value: _T_contra) -> _T_co: ...
    def throw(self, __typ: type, __val: object = ..., __tb: object = ...) -> _T_co: ...
    def close(self) -> None: ...

class Awaitable(Generic[_T_co]):
    def __await__(self) -> Generator[object, None, _T_co]: ...

class Coroutine(Awaitable[_T_co], Generic[_T_co, _T_contra, _VT_co]): ...

class AsyncIterable(Generic[_T_co]):
    def __aiter__(self) -> AsyncIterator[_T_co]: ...

class AsyncIterator(AsyncIterable[_T_co]):
    def __anext__(self) -> Awaitable[_T_co]: ...

class AsyncGenerator(AsyncIterator[_T_co], Generic[_T_co, _T_contra]): ...
`;
